// Code generated by ent, DO NOT EDIT.

package dao

import (
	"aisecurity/ent/dao/admin"
	"aisecurity/ent/dao/predicate"
	"aisecurity/ent/dao/sweep"
	"aisecurity/ent/dao/sweepresult"
	"aisecurity/ent/dao/sweepresultdetails"
	"aisecurity/ent/dao/sweepschedule"
	"aisecurity/structs/types"
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/dialect/sql/sqljson"
	"entgo.io/ent/schema/field"
)

// SweepResultUpdate is the builder for updating SweepResult entities.
type SweepResultUpdate struct {
	config
	hooks    []Hook
	mutation *SweepResultMutation
}

// Where appends a list predicates to the SweepResultUpdate builder.
func (sru *SweepResultUpdate) Where(ps ...predicate.SweepResult) *SweepResultUpdate {
	sru.mutation.Where(ps...)
	return sru
}

// SetDeleteTime sets the "delete_time" field.
func (sru *SweepResultUpdate) SetDeleteTime(t time.Time) *SweepResultUpdate {
	sru.mutation.SetDeleteTime(t)
	return sru
}

// SetNillableDeleteTime sets the "delete_time" field if the given value is not nil.
func (sru *SweepResultUpdate) SetNillableDeleteTime(t *time.Time) *SweepResultUpdate {
	if t != nil {
		sru.SetDeleteTime(*t)
	}
	return sru
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (sru *SweepResultUpdate) ClearDeleteTime() *SweepResultUpdate {
	sru.mutation.ClearDeleteTime()
	return sru
}

// SetUpdaterID sets the "updater_id" field.
func (sru *SweepResultUpdate) SetUpdaterID(i int) *SweepResultUpdate {
	sru.mutation.SetUpdaterID(i)
	return sru
}

// SetUpdateTime sets the "update_time" field.
func (sru *SweepResultUpdate) SetUpdateTime(t time.Time) *SweepResultUpdate {
	sru.mutation.SetUpdateTime(t)
	return sru
}

// SetSweepID sets the "sweep_id" field.
func (sru *SweepResultUpdate) SetSweepID(i int) *SweepResultUpdate {
	sru.mutation.SetSweepID(i)
	return sru
}

// SetSweepScheduleID sets the "sweep_schedule_id" field.
func (sru *SweepResultUpdate) SetSweepScheduleID(i int) *SweepResultUpdate {
	sru.mutation.SetSweepScheduleID(i)
	return sru
}

// SetCheckInTime sets the "check_in_time" field.
func (sru *SweepResultUpdate) SetCheckInTime(t time.Time) *SweepResultUpdate {
	sru.mutation.SetCheckInTime(t)
	return sru
}

// SetNillableCheckInTime sets the "check_in_time" field if the given value is not nil.
func (sru *SweepResultUpdate) SetNillableCheckInTime(t *time.Time) *SweepResultUpdate {
	if t != nil {
		sru.SetCheckInTime(*t)
	}
	return sru
}

// ClearCheckInTime clears the value of the "check_in_time" field.
func (sru *SweepResultUpdate) ClearCheckInTime() *SweepResultUpdate {
	sru.mutation.ClearCheckInTime()
	return sru
}

// SetCheckInImage sets the "check_in_image" field.
func (sru *SweepResultUpdate) SetCheckInImage(ti types.UploadedImage) *SweepResultUpdate {
	sru.mutation.SetCheckInImage(ti)
	return sru
}

// SetNillableCheckInImage sets the "check_in_image" field if the given value is not nil.
func (sru *SweepResultUpdate) SetNillableCheckInImage(ti *types.UploadedImage) *SweepResultUpdate {
	if ti != nil {
		sru.SetCheckInImage(*ti)
	}
	return sru
}

// ClearCheckInImage clears the value of the "check_in_image" field.
func (sru *SweepResultUpdate) ClearCheckInImage() *SweepResultUpdate {
	sru.mutation.ClearCheckInImage()
	return sru
}

// SetSweepJobs sets the "sweep_jobs" field.
func (sru *SweepResultUpdate) SetSweepJobs(tj []*types.SweepJob) *SweepResultUpdate {
	sru.mutation.SetSweepJobs(tj)
	return sru
}

// AppendSweepJobs appends tj to the "sweep_jobs" field.
func (sru *SweepResultUpdate) AppendSweepJobs(tj []*types.SweepJob) *SweepResultUpdate {
	sru.mutation.AppendSweepJobs(tj)
	return sru
}

// ClearSweepJobs clears the value of the "sweep_jobs" field.
func (sru *SweepResultUpdate) ClearSweepJobs() *SweepResultUpdate {
	sru.mutation.ClearSweepJobs()
	return sru
}

// SetUpdater sets the "updater" edge to the Admin entity.
func (sru *SweepResultUpdate) SetUpdater(a *Admin) *SweepResultUpdate {
	return sru.SetUpdaterID(a.ID)
}

// SetSweep sets the "sweep" edge to the Sweep entity.
func (sru *SweepResultUpdate) SetSweep(s *Sweep) *SweepResultUpdate {
	return sru.SetSweepID(s.ID)
}

// SetSweepSchedule sets the "sweep_schedule" edge to the SweepSchedule entity.
func (sru *SweepResultUpdate) SetSweepSchedule(s *SweepSchedule) *SweepResultUpdate {
	return sru.SetSweepScheduleID(s.ID)
}

// AddSweepResultDetailIDs adds the "sweep_result_details" edge to the SweepResultDetails entity by IDs.
func (sru *SweepResultUpdate) AddSweepResultDetailIDs(ids ...int) *SweepResultUpdate {
	sru.mutation.AddSweepResultDetailIDs(ids...)
	return sru
}

// AddSweepResultDetails adds the "sweep_result_details" edges to the SweepResultDetails entity.
func (sru *SweepResultUpdate) AddSweepResultDetails(s ...*SweepResultDetails) *SweepResultUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sru.AddSweepResultDetailIDs(ids...)
}

// Mutation returns the SweepResultMutation object of the builder.
func (sru *SweepResultUpdate) Mutation() *SweepResultMutation {
	return sru.mutation
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (sru *SweepResultUpdate) ClearUpdater() *SweepResultUpdate {
	sru.mutation.ClearUpdater()
	return sru
}

// ClearSweep clears the "sweep" edge to the Sweep entity.
func (sru *SweepResultUpdate) ClearSweep() *SweepResultUpdate {
	sru.mutation.ClearSweep()
	return sru
}

// ClearSweepSchedule clears the "sweep_schedule" edge to the SweepSchedule entity.
func (sru *SweepResultUpdate) ClearSweepSchedule() *SweepResultUpdate {
	sru.mutation.ClearSweepSchedule()
	return sru
}

// ClearSweepResultDetails clears all "sweep_result_details" edges to the SweepResultDetails entity.
func (sru *SweepResultUpdate) ClearSweepResultDetails() *SweepResultUpdate {
	sru.mutation.ClearSweepResultDetails()
	return sru
}

// RemoveSweepResultDetailIDs removes the "sweep_result_details" edge to SweepResultDetails entities by IDs.
func (sru *SweepResultUpdate) RemoveSweepResultDetailIDs(ids ...int) *SweepResultUpdate {
	sru.mutation.RemoveSweepResultDetailIDs(ids...)
	return sru
}

// RemoveSweepResultDetails removes "sweep_result_details" edges to SweepResultDetails entities.
func (sru *SweepResultUpdate) RemoveSweepResultDetails(s ...*SweepResultDetails) *SweepResultUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sru.RemoveSweepResultDetailIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (sru *SweepResultUpdate) Save(ctx context.Context) (int, error) {
	if err := sru.defaults(); err != nil {
		return 0, err
	}
	return withHooks(ctx, sru.sqlSave, sru.mutation, sru.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (sru *SweepResultUpdate) SaveX(ctx context.Context) int {
	affected, err := sru.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (sru *SweepResultUpdate) Exec(ctx context.Context) error {
	_, err := sru.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (sru *SweepResultUpdate) ExecX(ctx context.Context) {
	if err := sru.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (sru *SweepResultUpdate) defaults() error {
	if _, ok := sru.mutation.UpdateTime(); !ok {
		if sweepresult.UpdateDefaultUpdateTime == nil {
			return fmt.Errorf("dao: uninitialized sweepresult.UpdateDefaultUpdateTime (forgotten import dao/runtime?)")
		}
		v := sweepresult.UpdateDefaultUpdateTime()
		sru.mutation.SetUpdateTime(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (sru *SweepResultUpdate) check() error {
	if v, ok := sru.mutation.UpdaterID(); ok {
		if err := sweepresult.UpdaterIDValidator(v); err != nil {
			return &ValidationError{Name: "updater_id", err: fmt.Errorf(`dao: validator failed for field "SweepResult.updater_id": %w`, err)}
		}
	}
	if v, ok := sru.mutation.SweepID(); ok {
		if err := sweepresult.SweepIDValidator(v); err != nil {
			return &ValidationError{Name: "sweep_id", err: fmt.Errorf(`dao: validator failed for field "SweepResult.sweep_id": %w`, err)}
		}
	}
	if v, ok := sru.mutation.SweepScheduleID(); ok {
		if err := sweepresult.SweepScheduleIDValidator(v); err != nil {
			return &ValidationError{Name: "sweep_schedule_id", err: fmt.Errorf(`dao: validator failed for field "SweepResult.sweep_schedule_id": %w`, err)}
		}
	}
	if _, ok := sru.mutation.CreatorID(); sru.mutation.CreatorCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.creator"`)
	}
	if _, ok := sru.mutation.UpdaterID(); sru.mutation.UpdaterCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.updater"`)
	}
	if _, ok := sru.mutation.SweepID(); sru.mutation.SweepCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.sweep"`)
	}
	if _, ok := sru.mutation.SweepScheduleID(); sru.mutation.SweepScheduleCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.sweep_schedule"`)
	}
	return nil
}

func (sru *SweepResultUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := sru.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(sweepresult.Table, sweepresult.Columns, sqlgraph.NewFieldSpec(sweepresult.FieldID, field.TypeInt))
	if ps := sru.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := sru.mutation.DeleteTime(); ok {
		_spec.SetField(sweepresult.FieldDeleteTime, field.TypeTime, value)
	}
	if sru.mutation.DeleteTimeCleared() {
		_spec.ClearField(sweepresult.FieldDeleteTime, field.TypeTime)
	}
	if value, ok := sru.mutation.UpdateTime(); ok {
		_spec.SetField(sweepresult.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := sru.mutation.CheckInTime(); ok {
		_spec.SetField(sweepresult.FieldCheckInTime, field.TypeTime, value)
	}
	if sru.mutation.CheckInTimeCleared() {
		_spec.ClearField(sweepresult.FieldCheckInTime, field.TypeTime)
	}
	if value, ok := sru.mutation.CheckInImage(); ok {
		_spec.SetField(sweepresult.FieldCheckInImage, field.TypeJSON, value)
	}
	if sru.mutation.CheckInImageCleared() {
		_spec.ClearField(sweepresult.FieldCheckInImage, field.TypeJSON)
	}
	if value, ok := sru.mutation.SweepJobs(); ok {
		_spec.SetField(sweepresult.FieldSweepJobs, field.TypeJSON, value)
	}
	if value, ok := sru.mutation.AppendedSweepJobs(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, sweepresult.FieldSweepJobs, value)
		})
	}
	if sru.mutation.SweepJobsCleared() {
		_spec.ClearField(sweepresult.FieldSweepJobs, field.TypeJSON)
	}
	if sru.mutation.UpdaterCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.UpdaterTable,
			Columns: []string{sweepresult.UpdaterColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(admin.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sru.mutation.UpdaterIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.UpdaterTable,
			Columns: []string{sweepresult.UpdaterColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(admin.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sru.mutation.SweepCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepTable,
			Columns: []string{sweepresult.SweepColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweep.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sru.mutation.SweepIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepTable,
			Columns: []string{sweepresult.SweepColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweep.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sru.mutation.SweepScheduleCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepScheduleTable,
			Columns: []string{sweepresult.SweepScheduleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepschedule.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sru.mutation.SweepScheduleIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepScheduleTable,
			Columns: []string{sweepresult.SweepScheduleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepschedule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sru.mutation.SweepResultDetailsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sweepresult.SweepResultDetailsTable,
			Columns: []string{sweepresult.SweepResultDetailsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepresultdetails.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sru.mutation.RemovedSweepResultDetailsIDs(); len(nodes) > 0 && !sru.mutation.SweepResultDetailsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sweepresult.SweepResultDetailsTable,
			Columns: []string{sweepresult.SweepResultDetailsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepresultdetails.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sru.mutation.SweepResultDetailsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sweepresult.SweepResultDetailsTable,
			Columns: []string{sweepresult.SweepResultDetailsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepresultdetails.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, sru.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{sweepresult.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	sru.mutation.done = true
	return n, nil
}

// SweepResultUpdateOne is the builder for updating a single SweepResult entity.
type SweepResultUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *SweepResultMutation
}

// SetDeleteTime sets the "delete_time" field.
func (sruo *SweepResultUpdateOne) SetDeleteTime(t time.Time) *SweepResultUpdateOne {
	sruo.mutation.SetDeleteTime(t)
	return sruo
}

// SetNillableDeleteTime sets the "delete_time" field if the given value is not nil.
func (sruo *SweepResultUpdateOne) SetNillableDeleteTime(t *time.Time) *SweepResultUpdateOne {
	if t != nil {
		sruo.SetDeleteTime(*t)
	}
	return sruo
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (sruo *SweepResultUpdateOne) ClearDeleteTime() *SweepResultUpdateOne {
	sruo.mutation.ClearDeleteTime()
	return sruo
}

// SetUpdaterID sets the "updater_id" field.
func (sruo *SweepResultUpdateOne) SetUpdaterID(i int) *SweepResultUpdateOne {
	sruo.mutation.SetUpdaterID(i)
	return sruo
}

// SetUpdateTime sets the "update_time" field.
func (sruo *SweepResultUpdateOne) SetUpdateTime(t time.Time) *SweepResultUpdateOne {
	sruo.mutation.SetUpdateTime(t)
	return sruo
}

// SetSweepID sets the "sweep_id" field.
func (sruo *SweepResultUpdateOne) SetSweepID(i int) *SweepResultUpdateOne {
	sruo.mutation.SetSweepID(i)
	return sruo
}

// SetSweepScheduleID sets the "sweep_schedule_id" field.
func (sruo *SweepResultUpdateOne) SetSweepScheduleID(i int) *SweepResultUpdateOne {
	sruo.mutation.SetSweepScheduleID(i)
	return sruo
}

// SetCheckInTime sets the "check_in_time" field.
func (sruo *SweepResultUpdateOne) SetCheckInTime(t time.Time) *SweepResultUpdateOne {
	sruo.mutation.SetCheckInTime(t)
	return sruo
}

// SetNillableCheckInTime sets the "check_in_time" field if the given value is not nil.
func (sruo *SweepResultUpdateOne) SetNillableCheckInTime(t *time.Time) *SweepResultUpdateOne {
	if t != nil {
		sruo.SetCheckInTime(*t)
	}
	return sruo
}

// ClearCheckInTime clears the value of the "check_in_time" field.
func (sruo *SweepResultUpdateOne) ClearCheckInTime() *SweepResultUpdateOne {
	sruo.mutation.ClearCheckInTime()
	return sruo
}

// SetCheckInImage sets the "check_in_image" field.
func (sruo *SweepResultUpdateOne) SetCheckInImage(ti types.UploadedImage) *SweepResultUpdateOne {
	sruo.mutation.SetCheckInImage(ti)
	return sruo
}

// SetNillableCheckInImage sets the "check_in_image" field if the given value is not nil.
func (sruo *SweepResultUpdateOne) SetNillableCheckInImage(ti *types.UploadedImage) *SweepResultUpdateOne {
	if ti != nil {
		sruo.SetCheckInImage(*ti)
	}
	return sruo
}

// ClearCheckInImage clears the value of the "check_in_image" field.
func (sruo *SweepResultUpdateOne) ClearCheckInImage() *SweepResultUpdateOne {
	sruo.mutation.ClearCheckInImage()
	return sruo
}

// SetSweepJobs sets the "sweep_jobs" field.
func (sruo *SweepResultUpdateOne) SetSweepJobs(tj []*types.SweepJob) *SweepResultUpdateOne {
	sruo.mutation.SetSweepJobs(tj)
	return sruo
}

// AppendSweepJobs appends tj to the "sweep_jobs" field.
func (sruo *SweepResultUpdateOne) AppendSweepJobs(tj []*types.SweepJob) *SweepResultUpdateOne {
	sruo.mutation.AppendSweepJobs(tj)
	return sruo
}

// ClearSweepJobs clears the value of the "sweep_jobs" field.
func (sruo *SweepResultUpdateOne) ClearSweepJobs() *SweepResultUpdateOne {
	sruo.mutation.ClearSweepJobs()
	return sruo
}

// SetUpdater sets the "updater" edge to the Admin entity.
func (sruo *SweepResultUpdateOne) SetUpdater(a *Admin) *SweepResultUpdateOne {
	return sruo.SetUpdaterID(a.ID)
}

// SetSweep sets the "sweep" edge to the Sweep entity.
func (sruo *SweepResultUpdateOne) SetSweep(s *Sweep) *SweepResultUpdateOne {
	return sruo.SetSweepID(s.ID)
}

// SetSweepSchedule sets the "sweep_schedule" edge to the SweepSchedule entity.
func (sruo *SweepResultUpdateOne) SetSweepSchedule(s *SweepSchedule) *SweepResultUpdateOne {
	return sruo.SetSweepScheduleID(s.ID)
}

// AddSweepResultDetailIDs adds the "sweep_result_details" edge to the SweepResultDetails entity by IDs.
func (sruo *SweepResultUpdateOne) AddSweepResultDetailIDs(ids ...int) *SweepResultUpdateOne {
	sruo.mutation.AddSweepResultDetailIDs(ids...)
	return sruo
}

// AddSweepResultDetails adds the "sweep_result_details" edges to the SweepResultDetails entity.
func (sruo *SweepResultUpdateOne) AddSweepResultDetails(s ...*SweepResultDetails) *SweepResultUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sruo.AddSweepResultDetailIDs(ids...)
}

// Mutation returns the SweepResultMutation object of the builder.
func (sruo *SweepResultUpdateOne) Mutation() *SweepResultMutation {
	return sruo.mutation
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (sruo *SweepResultUpdateOne) ClearUpdater() *SweepResultUpdateOne {
	sruo.mutation.ClearUpdater()
	return sruo
}

// ClearSweep clears the "sweep" edge to the Sweep entity.
func (sruo *SweepResultUpdateOne) ClearSweep() *SweepResultUpdateOne {
	sruo.mutation.ClearSweep()
	return sruo
}

// ClearSweepSchedule clears the "sweep_schedule" edge to the SweepSchedule entity.
func (sruo *SweepResultUpdateOne) ClearSweepSchedule() *SweepResultUpdateOne {
	sruo.mutation.ClearSweepSchedule()
	return sruo
}

// ClearSweepResultDetails clears all "sweep_result_details" edges to the SweepResultDetails entity.
func (sruo *SweepResultUpdateOne) ClearSweepResultDetails() *SweepResultUpdateOne {
	sruo.mutation.ClearSweepResultDetails()
	return sruo
}

// RemoveSweepResultDetailIDs removes the "sweep_result_details" edge to SweepResultDetails entities by IDs.
func (sruo *SweepResultUpdateOne) RemoveSweepResultDetailIDs(ids ...int) *SweepResultUpdateOne {
	sruo.mutation.RemoveSweepResultDetailIDs(ids...)
	return sruo
}

// RemoveSweepResultDetails removes "sweep_result_details" edges to SweepResultDetails entities.
func (sruo *SweepResultUpdateOne) RemoveSweepResultDetails(s ...*SweepResultDetails) *SweepResultUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return sruo.RemoveSweepResultDetailIDs(ids...)
}

// Where appends a list predicates to the SweepResultUpdate builder.
func (sruo *SweepResultUpdateOne) Where(ps ...predicate.SweepResult) *SweepResultUpdateOne {
	sruo.mutation.Where(ps...)
	return sruo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (sruo *SweepResultUpdateOne) Select(field string, fields ...string) *SweepResultUpdateOne {
	sruo.fields = append([]string{field}, fields...)
	return sruo
}

// Save executes the query and returns the updated SweepResult entity.
func (sruo *SweepResultUpdateOne) Save(ctx context.Context) (*SweepResult, error) {
	if err := sruo.defaults(); err != nil {
		return nil, err
	}
	return withHooks(ctx, sruo.sqlSave, sruo.mutation, sruo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (sruo *SweepResultUpdateOne) SaveX(ctx context.Context) *SweepResult {
	node, err := sruo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (sruo *SweepResultUpdateOne) Exec(ctx context.Context) error {
	_, err := sruo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (sruo *SweepResultUpdateOne) ExecX(ctx context.Context) {
	if err := sruo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (sruo *SweepResultUpdateOne) defaults() error {
	if _, ok := sruo.mutation.UpdateTime(); !ok {
		if sweepresult.UpdateDefaultUpdateTime == nil {
			return fmt.Errorf("dao: uninitialized sweepresult.UpdateDefaultUpdateTime (forgotten import dao/runtime?)")
		}
		v := sweepresult.UpdateDefaultUpdateTime()
		sruo.mutation.SetUpdateTime(v)
	}
	return nil
}

// check runs all checks and user-defined validators on the builder.
func (sruo *SweepResultUpdateOne) check() error {
	if v, ok := sruo.mutation.UpdaterID(); ok {
		if err := sweepresult.UpdaterIDValidator(v); err != nil {
			return &ValidationError{Name: "updater_id", err: fmt.Errorf(`dao: validator failed for field "SweepResult.updater_id": %w`, err)}
		}
	}
	if v, ok := sruo.mutation.SweepID(); ok {
		if err := sweepresult.SweepIDValidator(v); err != nil {
			return &ValidationError{Name: "sweep_id", err: fmt.Errorf(`dao: validator failed for field "SweepResult.sweep_id": %w`, err)}
		}
	}
	if v, ok := sruo.mutation.SweepScheduleID(); ok {
		if err := sweepresult.SweepScheduleIDValidator(v); err != nil {
			return &ValidationError{Name: "sweep_schedule_id", err: fmt.Errorf(`dao: validator failed for field "SweepResult.sweep_schedule_id": %w`, err)}
		}
	}
	if _, ok := sruo.mutation.CreatorID(); sruo.mutation.CreatorCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.creator"`)
	}
	if _, ok := sruo.mutation.UpdaterID(); sruo.mutation.UpdaterCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.updater"`)
	}
	if _, ok := sruo.mutation.SweepID(); sruo.mutation.SweepCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.sweep"`)
	}
	if _, ok := sruo.mutation.SweepScheduleID(); sruo.mutation.SweepScheduleCleared() && !ok {
		return errors.New(`dao: clearing a required unique edge "SweepResult.sweep_schedule"`)
	}
	return nil
}

func (sruo *SweepResultUpdateOne) sqlSave(ctx context.Context) (_node *SweepResult, err error) {
	if err := sruo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(sweepresult.Table, sweepresult.Columns, sqlgraph.NewFieldSpec(sweepresult.FieldID, field.TypeInt))
	id, ok := sruo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`dao: missing "SweepResult.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := sruo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, sweepresult.FieldID)
		for _, f := range fields {
			if !sweepresult.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("dao: invalid field %q for query", f)}
			}
			if f != sweepresult.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := sruo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := sruo.mutation.DeleteTime(); ok {
		_spec.SetField(sweepresult.FieldDeleteTime, field.TypeTime, value)
	}
	if sruo.mutation.DeleteTimeCleared() {
		_spec.ClearField(sweepresult.FieldDeleteTime, field.TypeTime)
	}
	if value, ok := sruo.mutation.UpdateTime(); ok {
		_spec.SetField(sweepresult.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := sruo.mutation.CheckInTime(); ok {
		_spec.SetField(sweepresult.FieldCheckInTime, field.TypeTime, value)
	}
	if sruo.mutation.CheckInTimeCleared() {
		_spec.ClearField(sweepresult.FieldCheckInTime, field.TypeTime)
	}
	if value, ok := sruo.mutation.CheckInImage(); ok {
		_spec.SetField(sweepresult.FieldCheckInImage, field.TypeJSON, value)
	}
	if sruo.mutation.CheckInImageCleared() {
		_spec.ClearField(sweepresult.FieldCheckInImage, field.TypeJSON)
	}
	if value, ok := sruo.mutation.SweepJobs(); ok {
		_spec.SetField(sweepresult.FieldSweepJobs, field.TypeJSON, value)
	}
	if value, ok := sruo.mutation.AppendedSweepJobs(); ok {
		_spec.AddModifier(func(u *sql.UpdateBuilder) {
			sqljson.Append(u, sweepresult.FieldSweepJobs, value)
		})
	}
	if sruo.mutation.SweepJobsCleared() {
		_spec.ClearField(sweepresult.FieldSweepJobs, field.TypeJSON)
	}
	if sruo.mutation.UpdaterCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.UpdaterTable,
			Columns: []string{sweepresult.UpdaterColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(admin.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sruo.mutation.UpdaterIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.UpdaterTable,
			Columns: []string{sweepresult.UpdaterColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(admin.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sruo.mutation.SweepCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepTable,
			Columns: []string{sweepresult.SweepColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweep.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sruo.mutation.SweepIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepTable,
			Columns: []string{sweepresult.SweepColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweep.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sruo.mutation.SweepScheduleCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepScheduleTable,
			Columns: []string{sweepresult.SweepScheduleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepschedule.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sruo.mutation.SweepScheduleIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   sweepresult.SweepScheduleTable,
			Columns: []string{sweepresult.SweepScheduleColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepschedule.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if sruo.mutation.SweepResultDetailsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sweepresult.SweepResultDetailsTable,
			Columns: []string{sweepresult.SweepResultDetailsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepresultdetails.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sruo.mutation.RemovedSweepResultDetailsIDs(); len(nodes) > 0 && !sruo.mutation.SweepResultDetailsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sweepresult.SweepResultDetailsTable,
			Columns: []string{sweepresult.SweepResultDetailsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepresultdetails.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := sruo.mutation.SweepResultDetailsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   sweepresult.SweepResultDetailsTable,
			Columns: []string{sweepresult.SweepResultDetailsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(sweepresultdetails.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &SweepResult{config: sruo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, sruo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{sweepresult.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	sruo.mutation.done = true
	return _node, nil
}
