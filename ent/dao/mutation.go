// Code generated by ent, DO NOT EDIT.

package dao

import (
	"aisecurity/ent/dao/admin"
	"aisecurity/ent/dao/adminrole"
	"aisecurity/ent/dao/department"
	"aisecurity/ent/dao/employee"
	"aisecurity/ent/dao/ipcreportevent"
	"aisecurity/ent/dao/occupation"
	"aisecurity/ent/dao/predicate"
	"aisecurity/ent/dao/risk"
	"aisecurity/ent/dao/riskcategory"
	"aisecurity/ent/dao/risklocation"
	"aisecurity/ent/dao/video"
	"aisecurity/enums"
	"aisecurity/properties/maintain_status"
	"aisecurity/structs/types"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin          = "Admin"
	TypeAdminRole      = "AdminRole"
	TypeDepartment     = "Department"
	TypeEmployee       = "Employee"
	TypeIPCReportEvent = "IPCReportEvent"
	TypeOccupation     = "Occupation"
	TypeRisk           = "Risk"
	TypeRiskCategory   = "RiskCategory"
	TypeRiskLocation   = "RiskLocation"
	TypeVideo          = "Video"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	created_at                      *time.Time
	deleted_at                      *time.Time
	updated_at                      *time.Time
	username                        *string
	password                        *string
	nickname                        *string
	real_name                       *string
	avatar                          *string
	clearedFields                   map[string]struct{}
	creator                         *int
	clearedcreator                  bool
	updater                         *int
	clearedupdater                  bool
	admin_roles                     map[int]struct{}
	removedadmin_roles              map[int]struct{}
	clearedadmin_roles              bool
	admin_creator                   map[int]struct{}
	removedadmin_creator            map[int]struct{}
	clearedadmin_creator            bool
	admin_updater                   map[int]struct{}
	removedadmin_updater            map[int]struct{}
	clearedadmin_updater            bool
	admin_role_creator              map[int]struct{}
	removedadmin_role_creator       map[int]struct{}
	clearedadmin_role_creator       bool
	admin_role_updater              map[int]struct{}
	removedadmin_role_updater       map[int]struct{}
	clearedadmin_role_updater       bool
	risk_creator                    map[int]struct{}
	removedrisk_creator             map[int]struct{}
	clearedrisk_creator             bool
	risk_updater                    map[int]struct{}
	removedrisk_updater             map[int]struct{}
	clearedrisk_updater             bool
	risk_location_creator           map[int]struct{}
	removedrisk_location_creator    map[int]struct{}
	clearedrisk_location_creator    bool
	risk_location_updater           map[int]struct{}
	removedrisk_location_updater    map[int]struct{}
	clearedrisk_location_updater    bool
	risk_category_creator           map[int]struct{}
	removedrisk_category_creator    map[int]struct{}
	clearedrisk_category_creator    bool
	risk_category_updater           map[int]struct{}
	removedrisk_category_updater    map[int]struct{}
	clearedrisk_category_updater    bool
	department_creator              map[int]struct{}
	removeddepartment_creator       map[int]struct{}
	cleareddepartment_creator       bool
	department_updater              map[int]struct{}
	removeddepartment_updater       map[int]struct{}
	cleareddepartment_updater       bool
	employee_creator                map[int]struct{}
	removedemployee_creator         map[int]struct{}
	clearedemployee_creator         bool
	employee_updater                map[int]struct{}
	removedemployee_updater         map[int]struct{}
	clearedemployee_updater         bool
	employee                        map[int]struct{}
	removedemployee                 map[int]struct{}
	clearedemployee                 bool
	occupation_creator              map[int]struct{}
	removedoccupation_creator       map[int]struct{}
	clearedoccupation_creator       bool
	occupation_updater              map[int]struct{}
	removedoccupation_updater       map[int]struct{}
	clearedoccupation_updater       bool
	ipc_report_event_creator        map[int]struct{}
	removedipc_report_event_creator map[int]struct{}
	clearedipc_report_event_creator bool
	ipc_report_event_updater        map[int]struct{}
	removedipc_report_event_updater map[int]struct{}
	clearedipc_report_event_updater bool
	video_creator                   map[int]struct{}
	removedvideo_creator            map[int]struct{}
	clearedvideo_creator            bool
	video_updater                   map[int]struct{}
	removedvideo_updater            map[int]struct{}
	clearedvideo_updater            bool
	done                            bool
	oldValue                        func(context.Context) (*Admin, error)
	predicates                      []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AdminMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AdminMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AdminMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[admin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, admin.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AdminMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AdminMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AdminMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *AdminMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AdminMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AdminMutation) ResetNickname() {
	m.nickname = nil
}

// SetRealName sets the "real_name" field.
func (m *AdminMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *AdminMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "real_name" field.
func (m *AdminMutation) ResetRealName() {
	m.real_name = nil
}

// SetAvatar sets the "avatar" field.
func (m *AdminMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AdminMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *AdminMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[admin.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *AdminMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[admin.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AdminMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, admin.FieldAvatar)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *AdminMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AdminMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[admin.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AdminMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *AdminMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AdminMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *AdminMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *AdminMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[admin.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *AdminMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *AdminMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *AdminMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddAdminRoleIDs adds the "admin_roles" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleIDs(ids ...int) {
	if m.admin_roles == nil {
		m.admin_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_roles[ids[i]] = struct{}{}
	}
}

// ClearAdminRoles clears the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoles() {
	m.clearedadmin_roles = true
}

// AdminRolesCleared reports if the "admin_roles" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRolesCleared() bool {
	return m.clearedadmin_roles
}

// RemoveAdminRoleIDs removes the "admin_roles" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleIDs(ids ...int) {
	if m.removedadmin_roles == nil {
		m.removedadmin_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_roles, ids[i])
		m.removedadmin_roles[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoles returns the removed IDs of the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRolesIDs() (ids []int) {
	for id := range m.removedadmin_roles {
		ids = append(ids, id)
	}
	return
}

// AdminRolesIDs returns the "admin_roles" edge IDs in the mutation.
func (m *AdminMutation) AdminRolesIDs() (ids []int) {
	for id := range m.admin_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoles resets all changes to the "admin_roles" edge.
func (m *AdminMutation) ResetAdminRoles() {
	m.admin_roles = nil
	m.clearedadmin_roles = false
	m.removedadmin_roles = nil
}

// AddAdminCreatorIDs adds the "admin_creator" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminCreatorIDs(ids ...int) {
	if m.admin_creator == nil {
		m.admin_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_creator[ids[i]] = struct{}{}
	}
}

// ClearAdminCreator clears the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) ClearAdminCreator() {
	m.clearedadmin_creator = true
}

// AdminCreatorCleared reports if the "admin_creator" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminCreatorCleared() bool {
	return m.clearedadmin_creator
}

// RemoveAdminCreatorIDs removes the "admin_creator" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminCreatorIDs(ids ...int) {
	if m.removedadmin_creator == nil {
		m.removedadmin_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_creator, ids[i])
		m.removedadmin_creator[ids[i]] = struct{}{}
	}
}

// RemovedAdminCreator returns the removed IDs of the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminCreatorIDs() (ids []int) {
	for id := range m.removedadmin_creator {
		ids = append(ids, id)
	}
	return
}

// AdminCreatorIDs returns the "admin_creator" edge IDs in the mutation.
func (m *AdminMutation) AdminCreatorIDs() (ids []int) {
	for id := range m.admin_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminCreator resets all changes to the "admin_creator" edge.
func (m *AdminMutation) ResetAdminCreator() {
	m.admin_creator = nil
	m.clearedadmin_creator = false
	m.removedadmin_creator = nil
}

// AddAdminUpdaterIDs adds the "admin_updater" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminUpdaterIDs(ids ...int) {
	if m.admin_updater == nil {
		m.admin_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_updater[ids[i]] = struct{}{}
	}
}

// ClearAdminUpdater clears the "admin_updater" edge to the Admin entity.
func (m *AdminMutation) ClearAdminUpdater() {
	m.clearedadmin_updater = true
}

// AdminUpdaterCleared reports if the "admin_updater" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminUpdaterCleared() bool {
	return m.clearedadmin_updater
}

// RemoveAdminUpdaterIDs removes the "admin_updater" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminUpdaterIDs(ids ...int) {
	if m.removedadmin_updater == nil {
		m.removedadmin_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_updater, ids[i])
		m.removedadmin_updater[ids[i]] = struct{}{}
	}
}

// RemovedAdminUpdater returns the removed IDs of the "admin_updater" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminUpdaterIDs() (ids []int) {
	for id := range m.removedadmin_updater {
		ids = append(ids, id)
	}
	return
}

// AdminUpdaterIDs returns the "admin_updater" edge IDs in the mutation.
func (m *AdminMutation) AdminUpdaterIDs() (ids []int) {
	for id := range m.admin_updater {
		ids = append(ids, id)
	}
	return
}

// ResetAdminUpdater resets all changes to the "admin_updater" edge.
func (m *AdminMutation) ResetAdminUpdater() {
	m.admin_updater = nil
	m.clearedadmin_updater = false
	m.removedadmin_updater = nil
}

// AddAdminRoleCreatorIDs adds the "admin_role_creator" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleCreatorIDs(ids ...int) {
	if m.admin_role_creator == nil {
		m.admin_role_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_role_creator[ids[i]] = struct{}{}
	}
}

// ClearAdminRoleCreator clears the "admin_role_creator" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoleCreator() {
	m.clearedadmin_role_creator = true
}

// AdminRoleCreatorCleared reports if the "admin_role_creator" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRoleCreatorCleared() bool {
	return m.clearedadmin_role_creator
}

// RemoveAdminRoleCreatorIDs removes the "admin_role_creator" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleCreatorIDs(ids ...int) {
	if m.removedadmin_role_creator == nil {
		m.removedadmin_role_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_role_creator, ids[i])
		m.removedadmin_role_creator[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoleCreator returns the removed IDs of the "admin_role_creator" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRoleCreatorIDs() (ids []int) {
	for id := range m.removedadmin_role_creator {
		ids = append(ids, id)
	}
	return
}

// AdminRoleCreatorIDs returns the "admin_role_creator" edge IDs in the mutation.
func (m *AdminMutation) AdminRoleCreatorIDs() (ids []int) {
	for id := range m.admin_role_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoleCreator resets all changes to the "admin_role_creator" edge.
func (m *AdminMutation) ResetAdminRoleCreator() {
	m.admin_role_creator = nil
	m.clearedadmin_role_creator = false
	m.removedadmin_role_creator = nil
}

// AddAdminRoleUpdaterIDs adds the "admin_role_updater" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleUpdaterIDs(ids ...int) {
	if m.admin_role_updater == nil {
		m.admin_role_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_role_updater[ids[i]] = struct{}{}
	}
}

// ClearAdminRoleUpdater clears the "admin_role_updater" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoleUpdater() {
	m.clearedadmin_role_updater = true
}

// AdminRoleUpdaterCleared reports if the "admin_role_updater" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRoleUpdaterCleared() bool {
	return m.clearedadmin_role_updater
}

// RemoveAdminRoleUpdaterIDs removes the "admin_role_updater" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleUpdaterIDs(ids ...int) {
	if m.removedadmin_role_updater == nil {
		m.removedadmin_role_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_role_updater, ids[i])
		m.removedadmin_role_updater[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoleUpdater returns the removed IDs of the "admin_role_updater" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRoleUpdaterIDs() (ids []int) {
	for id := range m.removedadmin_role_updater {
		ids = append(ids, id)
	}
	return
}

// AdminRoleUpdaterIDs returns the "admin_role_updater" edge IDs in the mutation.
func (m *AdminMutation) AdminRoleUpdaterIDs() (ids []int) {
	for id := range m.admin_role_updater {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoleUpdater resets all changes to the "admin_role_updater" edge.
func (m *AdminMutation) ResetAdminRoleUpdater() {
	m.admin_role_updater = nil
	m.clearedadmin_role_updater = false
	m.removedadmin_role_updater = nil
}

// AddRiskCreatorIDs adds the "risk_creator" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskCreatorIDs(ids ...int) {
	if m.risk_creator == nil {
		m.risk_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCreator clears the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) ClearRiskCreator() {
	m.clearedrisk_creator = true
}

// RiskCreatorCleared reports if the "risk_creator" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskCreatorCleared() bool {
	return m.clearedrisk_creator
}

// RemoveRiskCreatorIDs removes the "risk_creator" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskCreatorIDs(ids ...int) {
	if m.removedrisk_creator == nil {
		m.removedrisk_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_creator, ids[i])
		m.removedrisk_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCreator returns the removed IDs of the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskCreatorIDs() (ids []int) {
	for id := range m.removedrisk_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCreatorIDs returns the "risk_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCreatorIDs() (ids []int) {
	for id := range m.risk_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCreator resets all changes to the "risk_creator" edge.
func (m *AdminMutation) ResetRiskCreator() {
	m.risk_creator = nil
	m.clearedrisk_creator = false
	m.removedrisk_creator = nil
}

// AddRiskUpdaterIDs adds the "risk_updater" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskUpdaterIDs(ids ...int) {
	if m.risk_updater == nil {
		m.risk_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskUpdater clears the "risk_updater" edge to the Risk entity.
func (m *AdminMutation) ClearRiskUpdater() {
	m.clearedrisk_updater = true
}

// RiskUpdaterCleared reports if the "risk_updater" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskUpdaterCleared() bool {
	return m.clearedrisk_updater
}

// RemoveRiskUpdaterIDs removes the "risk_updater" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskUpdaterIDs(ids ...int) {
	if m.removedrisk_updater == nil {
		m.removedrisk_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_updater, ids[i])
		m.removedrisk_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskUpdater returns the removed IDs of the "risk_updater" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_updater {
		ids = append(ids, id)
	}
	return
}

// RiskUpdaterIDs returns the "risk_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskUpdaterIDs() (ids []int) {
	for id := range m.risk_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskUpdater resets all changes to the "risk_updater" edge.
func (m *AdminMutation) ResetRiskUpdater() {
	m.risk_updater = nil
	m.clearedrisk_updater = false
	m.removedrisk_updater = nil
}

// AddRiskLocationCreatorIDs adds the "risk_location_creator" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationCreatorIDs(ids ...int) {
	if m.risk_location_creator == nil {
		m.risk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationCreator clears the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationCreator() {
	m.clearedrisk_location_creator = true
}

// RiskLocationCreatorCleared reports if the "risk_location_creator" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationCreatorCleared() bool {
	return m.clearedrisk_location_creator
}

// RemoveRiskLocationCreatorIDs removes the "risk_location_creator" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationCreatorIDs(ids ...int) {
	if m.removedrisk_location_creator == nil {
		m.removedrisk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_creator, ids[i])
		m.removedrisk_location_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationCreator returns the removed IDs of the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationCreatorIDs() (ids []int) {
	for id := range m.removedrisk_location_creator {
		ids = append(ids, id)
	}
	return
}

// RiskLocationCreatorIDs returns the "risk_location_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationCreatorIDs() (ids []int) {
	for id := range m.risk_location_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationCreator resets all changes to the "risk_location_creator" edge.
func (m *AdminMutation) ResetRiskLocationCreator() {
	m.risk_location_creator = nil
	m.clearedrisk_location_creator = false
	m.removedrisk_location_creator = nil
}

// AddRiskLocationUpdaterIDs adds the "risk_location_updater" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationUpdaterIDs(ids ...int) {
	if m.risk_location_updater == nil {
		m.risk_location_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationUpdater clears the "risk_location_updater" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationUpdater() {
	m.clearedrisk_location_updater = true
}

// RiskLocationUpdaterCleared reports if the "risk_location_updater" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationUpdaterCleared() bool {
	return m.clearedrisk_location_updater
}

// RemoveRiskLocationUpdaterIDs removes the "risk_location_updater" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationUpdaterIDs(ids ...int) {
	if m.removedrisk_location_updater == nil {
		m.removedrisk_location_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_updater, ids[i])
		m.removedrisk_location_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationUpdater returns the removed IDs of the "risk_location_updater" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_location_updater {
		ids = append(ids, id)
	}
	return
}

// RiskLocationUpdaterIDs returns the "risk_location_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationUpdaterIDs() (ids []int) {
	for id := range m.risk_location_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationUpdater resets all changes to the "risk_location_updater" edge.
func (m *AdminMutation) ResetRiskLocationUpdater() {
	m.risk_location_updater = nil
	m.clearedrisk_location_updater = false
	m.removedrisk_location_updater = nil
}

// AddRiskCategoryCreatorIDs adds the "risk_category_creator" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryCreatorIDs(ids ...int) {
	if m.risk_category_creator == nil {
		m.risk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryCreator clears the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryCreator() {
	m.clearedrisk_category_creator = true
}

// RiskCategoryCreatorCleared reports if the "risk_category_creator" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryCreatorCleared() bool {
	return m.clearedrisk_category_creator
}

// RemoveRiskCategoryCreatorIDs removes the "risk_category_creator" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryCreatorIDs(ids ...int) {
	if m.removedrisk_category_creator == nil {
		m.removedrisk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_creator, ids[i])
		m.removedrisk_category_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryCreator returns the removed IDs of the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryCreatorIDs() (ids []int) {
	for id := range m.removedrisk_category_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryCreatorIDs returns the "risk_category_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryCreatorIDs() (ids []int) {
	for id := range m.risk_category_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryCreator resets all changes to the "risk_category_creator" edge.
func (m *AdminMutation) ResetRiskCategoryCreator() {
	m.risk_category_creator = nil
	m.clearedrisk_category_creator = false
	m.removedrisk_category_creator = nil
}

// AddRiskCategoryUpdaterIDs adds the "risk_category_updater" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryUpdaterIDs(ids ...int) {
	if m.risk_category_updater == nil {
		m.risk_category_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryUpdater clears the "risk_category_updater" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryUpdater() {
	m.clearedrisk_category_updater = true
}

// RiskCategoryUpdaterCleared reports if the "risk_category_updater" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryUpdaterCleared() bool {
	return m.clearedrisk_category_updater
}

// RemoveRiskCategoryUpdaterIDs removes the "risk_category_updater" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryUpdaterIDs(ids ...int) {
	if m.removedrisk_category_updater == nil {
		m.removedrisk_category_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_updater, ids[i])
		m.removedrisk_category_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryUpdater returns the removed IDs of the "risk_category_updater" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_category_updater {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryUpdaterIDs returns the "risk_category_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryUpdaterIDs() (ids []int) {
	for id := range m.risk_category_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryUpdater resets all changes to the "risk_category_updater" edge.
func (m *AdminMutation) ResetRiskCategoryUpdater() {
	m.risk_category_updater = nil
	m.clearedrisk_category_updater = false
	m.removedrisk_category_updater = nil
}

// AddDepartmentCreatorIDs adds the "department_creator" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentCreatorIDs(ids ...int) {
	if m.department_creator == nil {
		m.department_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.department_creator[ids[i]] = struct{}{}
	}
}

// ClearDepartmentCreator clears the "department_creator" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentCreator() {
	m.cleareddepartment_creator = true
}

// DepartmentCreatorCleared reports if the "department_creator" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentCreatorCleared() bool {
	return m.cleareddepartment_creator
}

// RemoveDepartmentCreatorIDs removes the "department_creator" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentCreatorIDs(ids ...int) {
	if m.removeddepartment_creator == nil {
		m.removeddepartment_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_creator, ids[i])
		m.removeddepartment_creator[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentCreator returns the removed IDs of the "department_creator" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentCreatorIDs() (ids []int) {
	for id := range m.removeddepartment_creator {
		ids = append(ids, id)
	}
	return
}

// DepartmentCreatorIDs returns the "department_creator" edge IDs in the mutation.
func (m *AdminMutation) DepartmentCreatorIDs() (ids []int) {
	for id := range m.department_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentCreator resets all changes to the "department_creator" edge.
func (m *AdminMutation) ResetDepartmentCreator() {
	m.department_creator = nil
	m.cleareddepartment_creator = false
	m.removeddepartment_creator = nil
}

// AddDepartmentUpdaterIDs adds the "department_updater" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentUpdaterIDs(ids ...int) {
	if m.department_updater == nil {
		m.department_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.department_updater[ids[i]] = struct{}{}
	}
}

// ClearDepartmentUpdater clears the "department_updater" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentUpdater() {
	m.cleareddepartment_updater = true
}

// DepartmentUpdaterCleared reports if the "department_updater" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentUpdaterCleared() bool {
	return m.cleareddepartment_updater
}

// RemoveDepartmentUpdaterIDs removes the "department_updater" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentUpdaterIDs(ids ...int) {
	if m.removeddepartment_updater == nil {
		m.removeddepartment_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_updater, ids[i])
		m.removeddepartment_updater[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentUpdater returns the removed IDs of the "department_updater" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentUpdaterIDs() (ids []int) {
	for id := range m.removeddepartment_updater {
		ids = append(ids, id)
	}
	return
}

// DepartmentUpdaterIDs returns the "department_updater" edge IDs in the mutation.
func (m *AdminMutation) DepartmentUpdaterIDs() (ids []int) {
	for id := range m.department_updater {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentUpdater resets all changes to the "department_updater" edge.
func (m *AdminMutation) ResetDepartmentUpdater() {
	m.department_updater = nil
	m.cleareddepartment_updater = false
	m.removeddepartment_updater = nil
}

// AddEmployeeCreatorIDs adds the "employee_creator" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeCreatorIDs(ids ...int) {
	if m.employee_creator == nil {
		m.employee_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_creator[ids[i]] = struct{}{}
	}
}

// ClearEmployeeCreator clears the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeCreator() {
	m.clearedemployee_creator = true
}

// EmployeeCreatorCleared reports if the "employee_creator" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeCreatorCleared() bool {
	return m.clearedemployee_creator
}

// RemoveEmployeeCreatorIDs removes the "employee_creator" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeCreatorIDs(ids ...int) {
	if m.removedemployee_creator == nil {
		m.removedemployee_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_creator, ids[i])
		m.removedemployee_creator[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeCreator returns the removed IDs of the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeCreatorIDs() (ids []int) {
	for id := range m.removedemployee_creator {
		ids = append(ids, id)
	}
	return
}

// EmployeeCreatorIDs returns the "employee_creator" edge IDs in the mutation.
func (m *AdminMutation) EmployeeCreatorIDs() (ids []int) {
	for id := range m.employee_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeCreator resets all changes to the "employee_creator" edge.
func (m *AdminMutation) ResetEmployeeCreator() {
	m.employee_creator = nil
	m.clearedemployee_creator = false
	m.removedemployee_creator = nil
}

// AddEmployeeUpdaterIDs adds the "employee_updater" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeUpdaterIDs(ids ...int) {
	if m.employee_updater == nil {
		m.employee_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_updater[ids[i]] = struct{}{}
	}
}

// ClearEmployeeUpdater clears the "employee_updater" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeUpdater() {
	m.clearedemployee_updater = true
}

// EmployeeUpdaterCleared reports if the "employee_updater" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeUpdaterCleared() bool {
	return m.clearedemployee_updater
}

// RemoveEmployeeUpdaterIDs removes the "employee_updater" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeUpdaterIDs(ids ...int) {
	if m.removedemployee_updater == nil {
		m.removedemployee_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_updater, ids[i])
		m.removedemployee_updater[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeUpdater returns the removed IDs of the "employee_updater" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeUpdaterIDs() (ids []int) {
	for id := range m.removedemployee_updater {
		ids = append(ids, id)
	}
	return
}

// EmployeeUpdaterIDs returns the "employee_updater" edge IDs in the mutation.
func (m *AdminMutation) EmployeeUpdaterIDs() (ids []int) {
	for id := range m.employee_updater {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeUpdater resets all changes to the "employee_updater" edge.
func (m *AdminMutation) ResetEmployeeUpdater() {
	m.employee_updater = nil
	m.clearedemployee_updater = false
	m.removedemployee_updater = nil
}

// AddEmployeeIDs adds the "employee" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AdminMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// RemoveEmployeeIDs removes the "employee" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee, ids[i])
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed IDs of the "employee" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
func (m *AdminMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AdminMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
	m.removedemployee = nil
}

// AddOccupationCreatorIDs adds the "occupation_creator" edge to the Occupation entity by ids.
func (m *AdminMutation) AddOccupationCreatorIDs(ids ...int) {
	if m.occupation_creator == nil {
		m.occupation_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.occupation_creator[ids[i]] = struct{}{}
	}
}

// ClearOccupationCreator clears the "occupation_creator" edge to the Occupation entity.
func (m *AdminMutation) ClearOccupationCreator() {
	m.clearedoccupation_creator = true
}

// OccupationCreatorCleared reports if the "occupation_creator" edge to the Occupation entity was cleared.
func (m *AdminMutation) OccupationCreatorCleared() bool {
	return m.clearedoccupation_creator
}

// RemoveOccupationCreatorIDs removes the "occupation_creator" edge to the Occupation entity by IDs.
func (m *AdminMutation) RemoveOccupationCreatorIDs(ids ...int) {
	if m.removedoccupation_creator == nil {
		m.removedoccupation_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupation_creator, ids[i])
		m.removedoccupation_creator[ids[i]] = struct{}{}
	}
}

// RemovedOccupationCreator returns the removed IDs of the "occupation_creator" edge to the Occupation entity.
func (m *AdminMutation) RemovedOccupationCreatorIDs() (ids []int) {
	for id := range m.removedoccupation_creator {
		ids = append(ids, id)
	}
	return
}

// OccupationCreatorIDs returns the "occupation_creator" edge IDs in the mutation.
func (m *AdminMutation) OccupationCreatorIDs() (ids []int) {
	for id := range m.occupation_creator {
		ids = append(ids, id)
	}
	return
}

// ResetOccupationCreator resets all changes to the "occupation_creator" edge.
func (m *AdminMutation) ResetOccupationCreator() {
	m.occupation_creator = nil
	m.clearedoccupation_creator = false
	m.removedoccupation_creator = nil
}

// AddOccupationUpdaterIDs adds the "occupation_updater" edge to the Occupation entity by ids.
func (m *AdminMutation) AddOccupationUpdaterIDs(ids ...int) {
	if m.occupation_updater == nil {
		m.occupation_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.occupation_updater[ids[i]] = struct{}{}
	}
}

// ClearOccupationUpdater clears the "occupation_updater" edge to the Occupation entity.
func (m *AdminMutation) ClearOccupationUpdater() {
	m.clearedoccupation_updater = true
}

// OccupationUpdaterCleared reports if the "occupation_updater" edge to the Occupation entity was cleared.
func (m *AdminMutation) OccupationUpdaterCleared() bool {
	return m.clearedoccupation_updater
}

// RemoveOccupationUpdaterIDs removes the "occupation_updater" edge to the Occupation entity by IDs.
func (m *AdminMutation) RemoveOccupationUpdaterIDs(ids ...int) {
	if m.removedoccupation_updater == nil {
		m.removedoccupation_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupation_updater, ids[i])
		m.removedoccupation_updater[ids[i]] = struct{}{}
	}
}

// RemovedOccupationUpdater returns the removed IDs of the "occupation_updater" edge to the Occupation entity.
func (m *AdminMutation) RemovedOccupationUpdaterIDs() (ids []int) {
	for id := range m.removedoccupation_updater {
		ids = append(ids, id)
	}
	return
}

// OccupationUpdaterIDs returns the "occupation_updater" edge IDs in the mutation.
func (m *AdminMutation) OccupationUpdaterIDs() (ids []int) {
	for id := range m.occupation_updater {
		ids = append(ids, id)
	}
	return
}

// ResetOccupationUpdater resets all changes to the "occupation_updater" edge.
func (m *AdminMutation) ResetOccupationUpdater() {
	m.occupation_updater = nil
	m.clearedoccupation_updater = false
	m.removedoccupation_updater = nil
}

// AddIpcReportEventCreatorIDs adds the "ipc_report_event_creator" edge to the IPCReportEvent entity by ids.
func (m *AdminMutation) AddIpcReportEventCreatorIDs(ids ...int) {
	if m.ipc_report_event_creator == nil {
		m.ipc_report_event_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_report_event_creator[ids[i]] = struct{}{}
	}
}

// ClearIpcReportEventCreator clears the "ipc_report_event_creator" edge to the IPCReportEvent entity.
func (m *AdminMutation) ClearIpcReportEventCreator() {
	m.clearedipc_report_event_creator = true
}

// IpcReportEventCreatorCleared reports if the "ipc_report_event_creator" edge to the IPCReportEvent entity was cleared.
func (m *AdminMutation) IpcReportEventCreatorCleared() bool {
	return m.clearedipc_report_event_creator
}

// RemoveIpcReportEventCreatorIDs removes the "ipc_report_event_creator" edge to the IPCReportEvent entity by IDs.
func (m *AdminMutation) RemoveIpcReportEventCreatorIDs(ids ...int) {
	if m.removedipc_report_event_creator == nil {
		m.removedipc_report_event_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_report_event_creator, ids[i])
		m.removedipc_report_event_creator[ids[i]] = struct{}{}
	}
}

// RemovedIpcReportEventCreator returns the removed IDs of the "ipc_report_event_creator" edge to the IPCReportEvent entity.
func (m *AdminMutation) RemovedIpcReportEventCreatorIDs() (ids []int) {
	for id := range m.removedipc_report_event_creator {
		ids = append(ids, id)
	}
	return
}

// IpcReportEventCreatorIDs returns the "ipc_report_event_creator" edge IDs in the mutation.
func (m *AdminMutation) IpcReportEventCreatorIDs() (ids []int) {
	for id := range m.ipc_report_event_creator {
		ids = append(ids, id)
	}
	return
}

// ResetIpcReportEventCreator resets all changes to the "ipc_report_event_creator" edge.
func (m *AdminMutation) ResetIpcReportEventCreator() {
	m.ipc_report_event_creator = nil
	m.clearedipc_report_event_creator = false
	m.removedipc_report_event_creator = nil
}

// AddIpcReportEventUpdaterIDs adds the "ipc_report_event_updater" edge to the IPCReportEvent entity by ids.
func (m *AdminMutation) AddIpcReportEventUpdaterIDs(ids ...int) {
	if m.ipc_report_event_updater == nil {
		m.ipc_report_event_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_report_event_updater[ids[i]] = struct{}{}
	}
}

// ClearIpcReportEventUpdater clears the "ipc_report_event_updater" edge to the IPCReportEvent entity.
func (m *AdminMutation) ClearIpcReportEventUpdater() {
	m.clearedipc_report_event_updater = true
}

// IpcReportEventUpdaterCleared reports if the "ipc_report_event_updater" edge to the IPCReportEvent entity was cleared.
func (m *AdminMutation) IpcReportEventUpdaterCleared() bool {
	return m.clearedipc_report_event_updater
}

// RemoveIpcReportEventUpdaterIDs removes the "ipc_report_event_updater" edge to the IPCReportEvent entity by IDs.
func (m *AdminMutation) RemoveIpcReportEventUpdaterIDs(ids ...int) {
	if m.removedipc_report_event_updater == nil {
		m.removedipc_report_event_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_report_event_updater, ids[i])
		m.removedipc_report_event_updater[ids[i]] = struct{}{}
	}
}

// RemovedIpcReportEventUpdater returns the removed IDs of the "ipc_report_event_updater" edge to the IPCReportEvent entity.
func (m *AdminMutation) RemovedIpcReportEventUpdaterIDs() (ids []int) {
	for id := range m.removedipc_report_event_updater {
		ids = append(ids, id)
	}
	return
}

// IpcReportEventUpdaterIDs returns the "ipc_report_event_updater" edge IDs in the mutation.
func (m *AdminMutation) IpcReportEventUpdaterIDs() (ids []int) {
	for id := range m.ipc_report_event_updater {
		ids = append(ids, id)
	}
	return
}

// ResetIpcReportEventUpdater resets all changes to the "ipc_report_event_updater" edge.
func (m *AdminMutation) ResetIpcReportEventUpdater() {
	m.ipc_report_event_updater = nil
	m.clearedipc_report_event_updater = false
	m.removedipc_report_event_updater = nil
}

// AddVideoCreatorIDs adds the "video_creator" edge to the Video entity by ids.
func (m *AdminMutation) AddVideoCreatorIDs(ids ...int) {
	if m.video_creator == nil {
		m.video_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.video_creator[ids[i]] = struct{}{}
	}
}

// ClearVideoCreator clears the "video_creator" edge to the Video entity.
func (m *AdminMutation) ClearVideoCreator() {
	m.clearedvideo_creator = true
}

// VideoCreatorCleared reports if the "video_creator" edge to the Video entity was cleared.
func (m *AdminMutation) VideoCreatorCleared() bool {
	return m.clearedvideo_creator
}

// RemoveVideoCreatorIDs removes the "video_creator" edge to the Video entity by IDs.
func (m *AdminMutation) RemoveVideoCreatorIDs(ids ...int) {
	if m.removedvideo_creator == nil {
		m.removedvideo_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.video_creator, ids[i])
		m.removedvideo_creator[ids[i]] = struct{}{}
	}
}

// RemovedVideoCreator returns the removed IDs of the "video_creator" edge to the Video entity.
func (m *AdminMutation) RemovedVideoCreatorIDs() (ids []int) {
	for id := range m.removedvideo_creator {
		ids = append(ids, id)
	}
	return
}

// VideoCreatorIDs returns the "video_creator" edge IDs in the mutation.
func (m *AdminMutation) VideoCreatorIDs() (ids []int) {
	for id := range m.video_creator {
		ids = append(ids, id)
	}
	return
}

// ResetVideoCreator resets all changes to the "video_creator" edge.
func (m *AdminMutation) ResetVideoCreator() {
	m.video_creator = nil
	m.clearedvideo_creator = false
	m.removedvideo_creator = nil
}

// AddVideoUpdaterIDs adds the "video_updater" edge to the Video entity by ids.
func (m *AdminMutation) AddVideoUpdaterIDs(ids ...int) {
	if m.video_updater == nil {
		m.video_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.video_updater[ids[i]] = struct{}{}
	}
}

// ClearVideoUpdater clears the "video_updater" edge to the Video entity.
func (m *AdminMutation) ClearVideoUpdater() {
	m.clearedvideo_updater = true
}

// VideoUpdaterCleared reports if the "video_updater" edge to the Video entity was cleared.
func (m *AdminMutation) VideoUpdaterCleared() bool {
	return m.clearedvideo_updater
}

// RemoveVideoUpdaterIDs removes the "video_updater" edge to the Video entity by IDs.
func (m *AdminMutation) RemoveVideoUpdaterIDs(ids ...int) {
	if m.removedvideo_updater == nil {
		m.removedvideo_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.video_updater, ids[i])
		m.removedvideo_updater[ids[i]] = struct{}{}
	}
}

// RemovedVideoUpdater returns the removed IDs of the "video_updater" edge to the Video entity.
func (m *AdminMutation) RemovedVideoUpdaterIDs() (ids []int) {
	for id := range m.removedvideo_updater {
		ids = append(ids, id)
	}
	return
}

// VideoUpdaterIDs returns the "video_updater" edge IDs in the mutation.
func (m *AdminMutation) VideoUpdaterIDs() (ids []int) {
	for id := range m.video_updater {
		ids = append(ids, id)
	}
	return
}

// ResetVideoUpdater resets all changes to the "video_updater" edge.
func (m *AdminMutation) ResetVideoUpdater() {
	m.video_updater = nil
	m.clearedvideo_updater = false
	m.removedvideo_updater = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, admin.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, admin.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, admin.FieldNickname)
	}
	if m.real_name != nil {
		fields = append(fields, admin.FieldRealName)
	}
	if m.avatar != nil {
		fields = append(fields, admin.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldCreatedBy:
		return m.CreatedBy()
	case admin.FieldDeletedAt:
		return m.DeletedAt()
	case admin.FieldUpdatedBy:
		return m.UpdatedBy()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldNickname:
		return m.Nickname()
	case admin.FieldRealName:
		return m.RealName()
	case admin.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case admin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case admin.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldNickname:
		return m.OldNickname(ctx)
	case admin.FieldRealName:
		return m.OldRealName(ctx)
	case admin.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case admin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case admin.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case admin.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case admin.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldDeletedAt) {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.FieldCleared(admin.FieldAvatar) {
		fields = append(fields, admin.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case admin.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case admin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case admin.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldNickname:
		m.ResetNickname()
		return nil
	case admin.FieldRealName:
		m.ResetRealName()
		return nil
	case admin.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 24)
	if m.creator != nil {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, admin.EdgeUpdater)
	}
	if m.admin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.admin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.admin_updater != nil {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.admin_role_creator != nil {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.admin_role_updater != nil {
		edges = append(edges, admin.EdgeAdminRoleUpdater)
	}
	if m.risk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.risk_updater != nil {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.risk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.risk_location_updater != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.risk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.risk_category_updater != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.department_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.department_updater != nil {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.employee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.employee_updater != nil {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.employee != nil {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.occupation_creator != nil {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.occupation_updater != nil {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.ipc_report_event_creator != nil {
		edges = append(edges, admin.EdgeIpcReportEventCreator)
	}
	if m.ipc_report_event_updater != nil {
		edges = append(edges, admin.EdgeIpcReportEventUpdater)
	}
	if m.video_creator != nil {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.video_updater != nil {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.admin_roles))
		for id := range m.admin_roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.admin_creator))
		for id := range m.admin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdater:
		ids := make([]ent.Value, 0, len(m.admin_updater))
		for id := range m.admin_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleCreator:
		ids := make([]ent.Value, 0, len(m.admin_role_creator))
		for id := range m.admin_role_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleUpdater:
		ids := make([]ent.Value, 0, len(m.admin_role_updater))
		for id := range m.admin_role_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.risk_creator))
		for id := range m.risk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdater:
		ids := make([]ent.Value, 0, len(m.risk_updater))
		for id := range m.risk_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.risk_location_creator))
		for id := range m.risk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdater:
		ids := make([]ent.Value, 0, len(m.risk_location_updater))
		for id := range m.risk_location_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.risk_category_creator))
		for id := range m.risk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdater:
		ids := make([]ent.Value, 0, len(m.risk_category_updater))
		for id := range m.risk_category_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.department_creator))
		for id := range m.department_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdater:
		ids := make([]ent.Value, 0, len(m.department_updater))
		for id := range m.department_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.employee_creator))
		for id := range m.employee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdater:
		ids := make([]ent.Value, 0, len(m.employee_updater))
		for id := range m.employee_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationCreator:
		ids := make([]ent.Value, 0, len(m.occupation_creator))
		for id := range m.occupation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationUpdater:
		ids := make([]ent.Value, 0, len(m.occupation_updater))
		for id := range m.occupation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcReportEventCreator:
		ids := make([]ent.Value, 0, len(m.ipc_report_event_creator))
		for id := range m.ipc_report_event_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcReportEventUpdater:
		ids := make([]ent.Value, 0, len(m.ipc_report_event_updater))
		for id := range m.ipc_report_event_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoCreator:
		ids := make([]ent.Value, 0, len(m.video_creator))
		for id := range m.video_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoUpdater:
		ids := make([]ent.Value, 0, len(m.video_updater))
		for id := range m.video_updater {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 24)
	if m.removedadmin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.removedadmin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.removedadmin_updater != nil {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.removedadmin_role_creator != nil {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.removedadmin_role_updater != nil {
		edges = append(edges, admin.EdgeAdminRoleUpdater)
	}
	if m.removedrisk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.removedrisk_updater != nil {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.removedrisk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.removedrisk_location_updater != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.removedrisk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.removedrisk_category_updater != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.removeddepartment_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.removeddepartment_updater != nil {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.removedemployee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.removedemployee_updater != nil {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.removedemployee != nil {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.removedoccupation_creator != nil {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.removedoccupation_updater != nil {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.removedipc_report_event_creator != nil {
		edges = append(edges, admin.EdgeIpcReportEventCreator)
	}
	if m.removedipc_report_event_updater != nil {
		edges = append(edges, admin.EdgeIpcReportEventUpdater)
	}
	if m.removedvideo_creator != nil {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.removedvideo_updater != nil {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.removedadmin_roles))
		for id := range m.removedadmin_roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.removedadmin_creator))
		for id := range m.removedadmin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdater:
		ids := make([]ent.Value, 0, len(m.removedadmin_updater))
		for id := range m.removedadmin_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleCreator:
		ids := make([]ent.Value, 0, len(m.removedadmin_role_creator))
		for id := range m.removedadmin_role_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleUpdater:
		ids := make([]ent.Value, 0, len(m.removedadmin_role_updater))
		for id := range m.removedadmin_role_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_creator))
		for id := range m.removedrisk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_updater))
		for id := range m.removedrisk_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_creator))
		for id := range m.removedrisk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_updater))
		for id := range m.removedrisk_location_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_creator))
		for id := range m.removedrisk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_updater))
		for id := range m.removedrisk_category_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.removeddepartment_creator))
		for id := range m.removeddepartment_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdater:
		ids := make([]ent.Value, 0, len(m.removeddepartment_updater))
		for id := range m.removeddepartment_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.removedemployee_creator))
		for id := range m.removedemployee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdater:
		ids := make([]ent.Value, 0, len(m.removedemployee_updater))
		for id := range m.removedemployee_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationCreator:
		ids := make([]ent.Value, 0, len(m.removedoccupation_creator))
		for id := range m.removedoccupation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationUpdater:
		ids := make([]ent.Value, 0, len(m.removedoccupation_updater))
		for id := range m.removedoccupation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcReportEventCreator:
		ids := make([]ent.Value, 0, len(m.removedipc_report_event_creator))
		for id := range m.removedipc_report_event_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcReportEventUpdater:
		ids := make([]ent.Value, 0, len(m.removedipc_report_event_updater))
		for id := range m.removedipc_report_event_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoCreator:
		ids := make([]ent.Value, 0, len(m.removedvideo_creator))
		for id := range m.removedvideo_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoUpdater:
		ids := make([]ent.Value, 0, len(m.removedvideo_updater))
		for id := range m.removedvideo_updater {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 24)
	if m.clearedcreator {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, admin.EdgeUpdater)
	}
	if m.clearedadmin_roles {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.clearedadmin_creator {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.clearedadmin_updater {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.clearedadmin_role_creator {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.clearedadmin_role_updater {
		edges = append(edges, admin.EdgeAdminRoleUpdater)
	}
	if m.clearedrisk_creator {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.clearedrisk_updater {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.clearedrisk_location_creator {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.clearedrisk_location_updater {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.clearedrisk_category_creator {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.clearedrisk_category_updater {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.cleareddepartment_creator {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.cleareddepartment_updater {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.clearedemployee_creator {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.clearedemployee_updater {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.clearedemployee {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.clearedoccupation_creator {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.clearedoccupation_updater {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.clearedipc_report_event_creator {
		edges = append(edges, admin.EdgeIpcReportEventCreator)
	}
	if m.clearedipc_report_event_updater {
		edges = append(edges, admin.EdgeIpcReportEventUpdater)
	}
	if m.clearedvideo_creator {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.clearedvideo_updater {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeCreator:
		return m.clearedcreator
	case admin.EdgeUpdater:
		return m.clearedupdater
	case admin.EdgeAdminRoles:
		return m.clearedadmin_roles
	case admin.EdgeAdminCreator:
		return m.clearedadmin_creator
	case admin.EdgeAdminUpdater:
		return m.clearedadmin_updater
	case admin.EdgeAdminRoleCreator:
		return m.clearedadmin_role_creator
	case admin.EdgeAdminRoleUpdater:
		return m.clearedadmin_role_updater
	case admin.EdgeRiskCreator:
		return m.clearedrisk_creator
	case admin.EdgeRiskUpdater:
		return m.clearedrisk_updater
	case admin.EdgeRiskLocationCreator:
		return m.clearedrisk_location_creator
	case admin.EdgeRiskLocationUpdater:
		return m.clearedrisk_location_updater
	case admin.EdgeRiskCategoryCreator:
		return m.clearedrisk_category_creator
	case admin.EdgeRiskCategoryUpdater:
		return m.clearedrisk_category_updater
	case admin.EdgeDepartmentCreator:
		return m.cleareddepartment_creator
	case admin.EdgeDepartmentUpdater:
		return m.cleareddepartment_updater
	case admin.EdgeEmployeeCreator:
		return m.clearedemployee_creator
	case admin.EdgeEmployeeUpdater:
		return m.clearedemployee_updater
	case admin.EdgeEmployee:
		return m.clearedemployee
	case admin.EdgeOccupationCreator:
		return m.clearedoccupation_creator
	case admin.EdgeOccupationUpdater:
		return m.clearedoccupation_updater
	case admin.EdgeIpcReportEventCreator:
		return m.clearedipc_report_event_creator
	case admin.EdgeIpcReportEventUpdater:
		return m.clearedipc_report_event_updater
	case admin.EdgeVideoCreator:
		return m.clearedvideo_creator
	case admin.EdgeVideoUpdater:
		return m.clearedvideo_updater
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ClearCreator()
		return nil
	case admin.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ResetCreator()
		return nil
	case admin.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case admin.EdgeAdminRoles:
		m.ResetAdminRoles()
		return nil
	case admin.EdgeAdminCreator:
		m.ResetAdminCreator()
		return nil
	case admin.EdgeAdminUpdater:
		m.ResetAdminUpdater()
		return nil
	case admin.EdgeAdminRoleCreator:
		m.ResetAdminRoleCreator()
		return nil
	case admin.EdgeAdminRoleUpdater:
		m.ResetAdminRoleUpdater()
		return nil
	case admin.EdgeRiskCreator:
		m.ResetRiskCreator()
		return nil
	case admin.EdgeRiskUpdater:
		m.ResetRiskUpdater()
		return nil
	case admin.EdgeRiskLocationCreator:
		m.ResetRiskLocationCreator()
		return nil
	case admin.EdgeRiskLocationUpdater:
		m.ResetRiskLocationUpdater()
		return nil
	case admin.EdgeRiskCategoryCreator:
		m.ResetRiskCategoryCreator()
		return nil
	case admin.EdgeRiskCategoryUpdater:
		m.ResetRiskCategoryUpdater()
		return nil
	case admin.EdgeDepartmentCreator:
		m.ResetDepartmentCreator()
		return nil
	case admin.EdgeDepartmentUpdater:
		m.ResetDepartmentUpdater()
		return nil
	case admin.EdgeEmployeeCreator:
		m.ResetEmployeeCreator()
		return nil
	case admin.EdgeEmployeeUpdater:
		m.ResetEmployeeUpdater()
		return nil
	case admin.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case admin.EdgeOccupationCreator:
		m.ResetOccupationCreator()
		return nil
	case admin.EdgeOccupationUpdater:
		m.ResetOccupationUpdater()
		return nil
	case admin.EdgeIpcReportEventCreator:
		m.ResetIpcReportEventCreator()
		return nil
	case admin.EdgeIpcReportEventUpdater:
		m.ResetIpcReportEventUpdater()
		return nil
	case admin.EdgeVideoCreator:
		m.ResetVideoCreator()
		return nil
	case admin.EdgeVideoUpdater:
		m.ResetVideoUpdater()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AdminRoleMutation represents an operation that mutates the AdminRole nodes in the graph.
type AdminRoleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	name           *string
	deleted_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	admins         map[int]struct{}
	removedadmins  map[int]struct{}
	clearedadmins  bool
	done           bool
	oldValue       func(context.Context) (*AdminRole, error)
	predicates     []predicate.AdminRole
}

var _ ent.Mutation = (*AdminRoleMutation)(nil)

// adminroleOption allows management of the mutation configuration using functional options.
type adminroleOption func(*AdminRoleMutation)

// newAdminRoleMutation creates new mutation for the AdminRole entity.
func newAdminRoleMutation(c config, op Op, opts ...adminroleOption) *AdminRoleMutation {
	m := &AdminRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminRoleID sets the ID field of the mutation.
func withAdminRoleID(id int) adminroleOption {
	return func(m *AdminRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminRole
		)
		m.oldValue = func(ctx context.Context) (*AdminRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminRole sets the old AdminRole of the mutation.
func withAdminRole(node *AdminRole) adminroleOption {
	return func(m *AdminRoleMutation) {
		m.oldValue = func(context.Context) (*AdminRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AdminRoleMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AdminRoleMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AdminRoleMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[adminrole.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AdminRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AdminRoleMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, adminrole.FieldCreatedBy)
}

// SetName sets the "name" field.
func (m *AdminRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdminRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdminRoleMutation) ResetName() {
	m.name = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[adminrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, adminrole.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AdminRoleMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AdminRoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AdminRoleMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[adminrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AdminRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AdminRoleMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, adminrole.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *AdminRoleMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AdminRoleMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[adminrole.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *AdminRoleMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AdminRoleMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *AdminRoleMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *AdminRoleMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[adminrole.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *AdminRoleMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *AdminRoleMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddAdminIDs adds the "admins" edge to the Admin entity by ids.
func (m *AdminRoleMutation) AddAdminIDs(ids ...int) {
	if m.admins == nil {
		m.admins = make(map[int]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// ClearAdmins clears the "admins" edge to the Admin entity.
func (m *AdminRoleMutation) ClearAdmins() {
	m.clearedadmins = true
}

// AdminsCleared reports if the "admins" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) AdminsCleared() bool {
	return m.clearedadmins
}

// RemoveAdminIDs removes the "admins" edge to the Admin entity by IDs.
func (m *AdminRoleMutation) RemoveAdminIDs(ids ...int) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admins, ids[i])
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed IDs of the "admins" edge to the Admin entity.
func (m *AdminRoleMutation) RemovedAdminsIDs() (ids []int) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the "admins" edge IDs in the mutation.
func (m *AdminRoleMutation) AdminsIDs() (ids []int) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins resets all changes to the "admins" edge.
func (m *AdminRoleMutation) ResetAdmins() {
	m.admins = nil
	m.clearedadmins = false
	m.removedadmins = nil
}

// Where appends a list predicates to the AdminRoleMutation builder.
func (m *AdminRoleMutation) Where(ps ...predicate.AdminRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminRole).
func (m *AdminRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminRoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, adminrole.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, adminrole.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, adminrole.FieldName)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminrole.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, adminrole.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, adminrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminrole.FieldCreatedAt:
		return m.CreatedAt()
	case adminrole.FieldCreatedBy:
		return m.CreatedBy()
	case adminrole.FieldName:
		return m.Name()
	case adminrole.FieldDeletedAt:
		return m.DeletedAt()
	case adminrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case adminrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case adminrole.FieldName:
		return m.OldName(ctx)
	case adminrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case adminrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminrole.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case adminrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case adminrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminrole.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case adminrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminrole.FieldCreatedBy) {
		fields = append(fields, adminrole.FieldCreatedBy)
	}
	if m.FieldCleared(adminrole.FieldDeletedAt) {
		fields = append(fields, adminrole.FieldDeletedAt)
	}
	if m.FieldCleared(adminrole.FieldUpdatedBy) {
		fields = append(fields, adminrole.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminRoleMutation) ClearField(name string) error {
	switch name {
	case adminrole.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case adminrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case adminrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown AdminRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminRoleMutation) ResetField(name string) error {
	switch name {
	case adminrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case adminrole.FieldName:
		m.ResetName()
		return nil
	case adminrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case adminrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, adminrole.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, adminrole.EdgeUpdater)
	}
	if m.admins != nil {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedadmins != nil {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, adminrole.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, adminrole.EdgeUpdater)
	}
	if m.clearedadmins {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case adminrole.EdgeCreator:
		return m.clearedcreator
	case adminrole.EdgeUpdater:
		return m.clearedupdater
	case adminrole.EdgeAdmins:
		return m.clearedadmins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminRoleMutation) ClearEdge(name string) error {
	switch name {
	case adminrole.EdgeCreator:
		m.ClearCreator()
		return nil
	case adminrole.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown AdminRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminRoleMutation) ResetEdge(name string) error {
	switch name {
	case adminrole.EdgeCreator:
		m.ResetCreator()
		return nil
	case adminrole.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case adminrole.EdgeAdmins:
		m.ResetAdmins()
		return nil
	}
	return fmt.Errorf("unknown AdminRole edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	deleted_at       *time.Time
	updated_at       *time.Time
	name             *string
	clearedFields    map[string]struct{}
	creator          *int
	clearedcreator   bool
	updater          *int
	clearedupdater   bool
	parent           *int
	clearedparent    bool
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	clearedemployees bool
	children         map[int]struct{}
	removedchildren  map[int]struct{}
	clearedchildren  bool
	done             bool
	oldValue         func(context.Context) (*Department, error)
	predicates       []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DepartmentMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DepartmentMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DepartmentMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DepartmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DepartmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DepartmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[department.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DepartmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DepartmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, department.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DepartmentMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DepartmentMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DepartmentMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, department.FieldParentID)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *DepartmentMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DepartmentMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[department.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DepartmentMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *DepartmentMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DepartmentMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *DepartmentMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *DepartmentMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[department.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *DepartmentMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *DepartmentMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *DepartmentMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *DepartmentMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *DepartmentMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *DepartmentMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *DepartmentMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *DepartmentMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *DepartmentMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *DepartmentMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, department.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, department.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.parent != nil {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldCreatedBy:
		return m.CreatedBy()
	case department.FieldDeletedAt:
		return m.DeletedAt()
	case department.FieldUpdatedBy:
		return m.UpdatedBy()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	case department.FieldName:
		return m.Name()
	case department.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case department.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case department.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case department.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case department.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDeletedAt) {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case department.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case department.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, department.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, department.EdgeUpdater)
	}
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.employees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedemployees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, department.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, department.EdgeUpdater)
	}
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedemployees {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeCreator:
		return m.clearedcreator
	case department.EdgeUpdater:
		return m.clearedupdater
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeEmployees:
		return m.clearedemployees
	case department.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ClearCreator()
		return nil
	case department.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case department.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ResetCreator()
		return nil
	case department.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	deleted_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	creator                *int
	clearedcreator         bool
	updater                *int
	clearedupdater         bool
	admin                  *int
	clearedadmin           bool
	department             *int
	cleareddepartment      bool
	occupations            map[int]struct{}
	removedoccupations     map[int]struct{}
	clearedoccupations     bool
	risk_reporter          map[int]struct{}
	removedrisk_reporter   map[int]struct{}
	clearedrisk_reporter   bool
	risk_maintainer        map[int]struct{}
	removedrisk_maintainer map[int]struct{}
	clearedrisk_maintainer bool
	done                   bool
	oldValue               func(context.Context) (*Employee, error)
	predicates             []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EmployeeMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EmployeeMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EmployeeMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EmployeeMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EmployeeMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EmployeeMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdminID sets the "admin_id" field.
func (m *EmployeeMutation) SetAdminID(i int) {
	m.admin = &i
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *EmployeeMutation) AdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *EmployeeMutation) ResetAdminID() {
	m.admin = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *EmployeeMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *EmployeeMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *EmployeeMutation) ResetDepartmentID() {
	m.department = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *EmployeeMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EmployeeMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[employee.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EmployeeMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *EmployeeMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EmployeeMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *EmployeeMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *EmployeeMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[employee.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *EmployeeMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *EmployeeMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *EmployeeMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *EmployeeMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[employee.FieldAdminID] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *EmployeeMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *EmployeeMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[employee.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddOccupationIDs adds the "occupations" edge to the Occupation entity by ids.
func (m *EmployeeMutation) AddOccupationIDs(ids ...int) {
	if m.occupations == nil {
		m.occupations = make(map[int]struct{})
	}
	for i := range ids {
		m.occupations[ids[i]] = struct{}{}
	}
}

// ClearOccupations clears the "occupations" edge to the Occupation entity.
func (m *EmployeeMutation) ClearOccupations() {
	m.clearedoccupations = true
}

// OccupationsCleared reports if the "occupations" edge to the Occupation entity was cleared.
func (m *EmployeeMutation) OccupationsCleared() bool {
	return m.clearedoccupations
}

// RemoveOccupationIDs removes the "occupations" edge to the Occupation entity by IDs.
func (m *EmployeeMutation) RemoveOccupationIDs(ids ...int) {
	if m.removedoccupations == nil {
		m.removedoccupations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupations, ids[i])
		m.removedoccupations[ids[i]] = struct{}{}
	}
}

// RemovedOccupations returns the removed IDs of the "occupations" edge to the Occupation entity.
func (m *EmployeeMutation) RemovedOccupationsIDs() (ids []int) {
	for id := range m.removedoccupations {
		ids = append(ids, id)
	}
	return
}

// OccupationsIDs returns the "occupations" edge IDs in the mutation.
func (m *EmployeeMutation) OccupationsIDs() (ids []int) {
	for id := range m.occupations {
		ids = append(ids, id)
	}
	return
}

// ResetOccupations resets all changes to the "occupations" edge.
func (m *EmployeeMutation) ResetOccupations() {
	m.occupations = nil
	m.clearedoccupations = false
	m.removedoccupations = nil
}

// AddRiskReporterIDs adds the "risk_reporter" edge to the Risk entity by ids.
func (m *EmployeeMutation) AddRiskReporterIDs(ids ...int) {
	if m.risk_reporter == nil {
		m.risk_reporter = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_reporter[ids[i]] = struct{}{}
	}
}

// ClearRiskReporter clears the "risk_reporter" edge to the Risk entity.
func (m *EmployeeMutation) ClearRiskReporter() {
	m.clearedrisk_reporter = true
}

// RiskReporterCleared reports if the "risk_reporter" edge to the Risk entity was cleared.
func (m *EmployeeMutation) RiskReporterCleared() bool {
	return m.clearedrisk_reporter
}

// RemoveRiskReporterIDs removes the "risk_reporter" edge to the Risk entity by IDs.
func (m *EmployeeMutation) RemoveRiskReporterIDs(ids ...int) {
	if m.removedrisk_reporter == nil {
		m.removedrisk_reporter = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_reporter, ids[i])
		m.removedrisk_reporter[ids[i]] = struct{}{}
	}
}

// RemovedRiskReporter returns the removed IDs of the "risk_reporter" edge to the Risk entity.
func (m *EmployeeMutation) RemovedRiskReporterIDs() (ids []int) {
	for id := range m.removedrisk_reporter {
		ids = append(ids, id)
	}
	return
}

// RiskReporterIDs returns the "risk_reporter" edge IDs in the mutation.
func (m *EmployeeMutation) RiskReporterIDs() (ids []int) {
	for id := range m.risk_reporter {
		ids = append(ids, id)
	}
	return
}

// ResetRiskReporter resets all changes to the "risk_reporter" edge.
func (m *EmployeeMutation) ResetRiskReporter() {
	m.risk_reporter = nil
	m.clearedrisk_reporter = false
	m.removedrisk_reporter = nil
}

// AddRiskMaintainerIDs adds the "risk_maintainer" edge to the Risk entity by ids.
func (m *EmployeeMutation) AddRiskMaintainerIDs(ids ...int) {
	if m.risk_maintainer == nil {
		m.risk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_maintainer[ids[i]] = struct{}{}
	}
}

// ClearRiskMaintainer clears the "risk_maintainer" edge to the Risk entity.
func (m *EmployeeMutation) ClearRiskMaintainer() {
	m.clearedrisk_maintainer = true
}

// RiskMaintainerCleared reports if the "risk_maintainer" edge to the Risk entity was cleared.
func (m *EmployeeMutation) RiskMaintainerCleared() bool {
	return m.clearedrisk_maintainer
}

// RemoveRiskMaintainerIDs removes the "risk_maintainer" edge to the Risk entity by IDs.
func (m *EmployeeMutation) RemoveRiskMaintainerIDs(ids ...int) {
	if m.removedrisk_maintainer == nil {
		m.removedrisk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_maintainer, ids[i])
		m.removedrisk_maintainer[ids[i]] = struct{}{}
	}
}

// RemovedRiskMaintainer returns the removed IDs of the "risk_maintainer" edge to the Risk entity.
func (m *EmployeeMutation) RemovedRiskMaintainerIDs() (ids []int) {
	for id := range m.removedrisk_maintainer {
		ids = append(ids, id)
	}
	return
}

// RiskMaintainerIDs returns the "risk_maintainer" edge IDs in the mutation.
func (m *EmployeeMutation) RiskMaintainerIDs() (ids []int) {
	for id := range m.risk_maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetRiskMaintainer resets all changes to the "risk_maintainer" edge.
func (m *EmployeeMutation) ResetRiskMaintainer() {
	m.risk_maintainer = nil
	m.clearedrisk_maintainer = false
	m.removedrisk_maintainer = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, employee.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, employee.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.admin != nil {
		fields = append(fields, employee.FieldAdminID)
	}
	if m.department != nil {
		fields = append(fields, employee.FieldDepartmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldCreatedBy:
		return m.CreatedBy()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldUpdatedBy:
		return m.UpdatedBy()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldAdminID:
		return m.AdminID()
	case employee.FieldDepartmentID:
		return m.DepartmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldAdminID:
		return m.OldAdminID(ctx)
	case employee.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case employee.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldAdminID:
		m.ResetAdminID()
		return nil
	case employee.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.creator != nil {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, employee.EdgeUpdater)
	}
	if m.admin != nil {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.occupations != nil {
		edges = append(edges, employee.EdgeOccupations)
	}
	if m.risk_reporter != nil {
		edges = append(edges, employee.EdgeRiskReporter)
	}
	if m.risk_maintainer != nil {
		edges = append(edges, employee.EdgeRiskMaintainer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeOccupations:
		ids := make([]ent.Value, 0, len(m.occupations))
		for id := range m.occupations {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskReporter:
		ids := make([]ent.Value, 0, len(m.risk_reporter))
		for id := range m.risk_reporter {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.risk_maintainer))
		for id := range m.risk_maintainer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedoccupations != nil {
		edges = append(edges, employee.EdgeOccupations)
	}
	if m.removedrisk_reporter != nil {
		edges = append(edges, employee.EdgeRiskReporter)
	}
	if m.removedrisk_maintainer != nil {
		edges = append(edges, employee.EdgeRiskMaintainer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeOccupations:
		ids := make([]ent.Value, 0, len(m.removedoccupations))
		for id := range m.removedoccupations {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskReporter:
		ids := make([]ent.Value, 0, len(m.removedrisk_reporter))
		for id := range m.removedrisk_reporter {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.removedrisk_maintainer))
		for id := range m.removedrisk_maintainer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcreator {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, employee.EdgeUpdater)
	}
	if m.clearedadmin {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.clearedoccupations {
		edges = append(edges, employee.EdgeOccupations)
	}
	if m.clearedrisk_reporter {
		edges = append(edges, employee.EdgeRiskReporter)
	}
	if m.clearedrisk_maintainer {
		edges = append(edges, employee.EdgeRiskMaintainer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCreator:
		return m.clearedcreator
	case employee.EdgeUpdater:
		return m.clearedupdater
	case employee.EdgeAdmin:
		return m.clearedadmin
	case employee.EdgeDepartment:
		return m.cleareddepartment
	case employee.EdgeOccupations:
		return m.clearedoccupations
	case employee.EdgeRiskReporter:
		return m.clearedrisk_reporter
	case employee.EdgeRiskMaintainer:
		return m.clearedrisk_maintainer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ClearCreator()
		return nil
	case employee.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case employee.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ResetCreator()
		return nil
	case employee.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case employee.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case employee.EdgeOccupations:
		m.ResetOccupations()
		return nil
	case employee.EdgeRiskReporter:
		m.ResetRiskReporter()
		return nil
	case employee.EdgeRiskMaintainer:
		m.ResetRiskMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// IPCReportEventMutation represents an operation that mutates the IPCReportEvent nodes in the graph.
type IPCReportEventMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	deleted_at           *time.Time
	updated_at           *time.Time
	device_brand         *enums.IPCReportEventDeviceBrand
	adddevice_brand      *enums.IPCReportEventDeviceBrand
	device_model         *enums.IPCReportEventDeviceModel
	adddevice_model      *enums.IPCReportEventDeviceModel
	device_id            *string
	event_id             *string
	event_time           *time.Time
	event_type           *enums.IPCReportEventType
	addevent_type        *enums.IPCReportEventType
	event_status         *enums.IPCReportEventStatus
	addevent_status      *enums.IPCReportEventStatus
	images               *[]*types.UploadedImage
	appendimages         []*types.UploadedImage
	labeled_images       *[]*types.UploadedImage
	appendlabeled_images []*types.UploadedImage
	description          *string
	raw_data             *string
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	updater              *int
	clearedupdater       bool
	video                *int
	clearedvideo         bool
	done                 bool
	oldValue             func(context.Context) (*IPCReportEvent, error)
	predicates           []predicate.IPCReportEvent
}

var _ ent.Mutation = (*IPCReportEventMutation)(nil)

// ipcreporteventOption allows management of the mutation configuration using functional options.
type ipcreporteventOption func(*IPCReportEventMutation)

// newIPCReportEventMutation creates new mutation for the IPCReportEvent entity.
func newIPCReportEventMutation(c config, op Op, opts ...ipcreporteventOption) *IPCReportEventMutation {
	m := &IPCReportEventMutation{
		config:        c,
		op:            op,
		typ:           TypeIPCReportEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIPCReportEventID sets the ID field of the mutation.
func withIPCReportEventID(id int) ipcreporteventOption {
	return func(m *IPCReportEventMutation) {
		var (
			err   error
			once  sync.Once
			value *IPCReportEvent
		)
		m.oldValue = func(ctx context.Context) (*IPCReportEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IPCReportEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIPCReportEvent sets the old IPCReportEvent of the mutation.
func withIPCReportEvent(node *IPCReportEvent) ipcreporteventOption {
	return func(m *IPCReportEventMutation) {
		m.oldValue = func(context.Context) (*IPCReportEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPCReportEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPCReportEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IPCReportEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IPCReportEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IPCReportEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IPCReportEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IPCReportEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IPCReportEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *IPCReportEventMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IPCReportEventMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IPCReportEventMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IPCReportEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IPCReportEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IPCReportEventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ipcreportevent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IPCReportEventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ipcreportevent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IPCReportEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ipcreportevent.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *IPCReportEventMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *IPCReportEventMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *IPCReportEventMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IPCReportEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IPCReportEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IPCReportEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeviceBrand sets the "device_brand" field.
func (m *IPCReportEventMutation) SetDeviceBrand(eredb enums.IPCReportEventDeviceBrand) {
	m.device_brand = &eredb
	m.adddevice_brand = nil
}

// DeviceBrand returns the value of the "device_brand" field in the mutation.
func (m *IPCReportEventMutation) DeviceBrand() (r enums.IPCReportEventDeviceBrand, exists bool) {
	v := m.device_brand
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceBrand returns the old "device_brand" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldDeviceBrand(ctx context.Context) (v enums.IPCReportEventDeviceBrand, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceBrand: %w", err)
	}
	return oldValue.DeviceBrand, nil
}

// AddDeviceBrand adds eredb to the "device_brand" field.
func (m *IPCReportEventMutation) AddDeviceBrand(eredb enums.IPCReportEventDeviceBrand) {
	if m.adddevice_brand != nil {
		*m.adddevice_brand += eredb
	} else {
		m.adddevice_brand = &eredb
	}
}

// AddedDeviceBrand returns the value that was added to the "device_brand" field in this mutation.
func (m *IPCReportEventMutation) AddedDeviceBrand() (r enums.IPCReportEventDeviceBrand, exists bool) {
	v := m.adddevice_brand
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceBrand resets all changes to the "device_brand" field.
func (m *IPCReportEventMutation) ResetDeviceBrand() {
	m.device_brand = nil
	m.adddevice_brand = nil
}

// SetDeviceModel sets the "device_model" field.
func (m *IPCReportEventMutation) SetDeviceModel(eredm enums.IPCReportEventDeviceModel) {
	m.device_model = &eredm
	m.adddevice_model = nil
}

// DeviceModel returns the value of the "device_model" field in the mutation.
func (m *IPCReportEventMutation) DeviceModel() (r enums.IPCReportEventDeviceModel, exists bool) {
	v := m.device_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceModel returns the old "device_model" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldDeviceModel(ctx context.Context) (v enums.IPCReportEventDeviceModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceModel: %w", err)
	}
	return oldValue.DeviceModel, nil
}

// AddDeviceModel adds eredm to the "device_model" field.
func (m *IPCReportEventMutation) AddDeviceModel(eredm enums.IPCReportEventDeviceModel) {
	if m.adddevice_model != nil {
		*m.adddevice_model += eredm
	} else {
		m.adddevice_model = &eredm
	}
}

// AddedDeviceModel returns the value that was added to the "device_model" field in this mutation.
func (m *IPCReportEventMutation) AddedDeviceModel() (r enums.IPCReportEventDeviceModel, exists bool) {
	v := m.adddevice_model
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceModel resets all changes to the "device_model" field.
func (m *IPCReportEventMutation) ResetDeviceModel() {
	m.device_model = nil
	m.adddevice_model = nil
}

// SetDeviceID sets the "device_id" field.
func (m *IPCReportEventMutation) SetDeviceID(s string) {
	m.device_id = &s
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *IPCReportEventMutation) DeviceID() (r string, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldDeviceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *IPCReportEventMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetEventID sets the "event_id" field.
func (m *IPCReportEventMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *IPCReportEventMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *IPCReportEventMutation) ResetEventID() {
	m.event_id = nil
}

// SetEventTime sets the "event_time" field.
func (m *IPCReportEventMutation) SetEventTime(t time.Time) {
	m.event_time = &t
}

// EventTime returns the value of the "event_time" field in the mutation.
func (m *IPCReportEventMutation) EventTime() (r time.Time, exists bool) {
	v := m.event_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTime returns the old "event_time" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldEventTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTime: %w", err)
	}
	return oldValue.EventTime, nil
}

// ResetEventTime resets all changes to the "event_time" field.
func (m *IPCReportEventMutation) ResetEventTime() {
	m.event_time = nil
}

// SetEventType sets the "event_type" field.
func (m *IPCReportEventMutation) SetEventType(eret enums.IPCReportEventType) {
	m.event_type = &eret
	m.addevent_type = nil
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *IPCReportEventMutation) EventType() (r enums.IPCReportEventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldEventType(ctx context.Context) (v enums.IPCReportEventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// AddEventType adds eret to the "event_type" field.
func (m *IPCReportEventMutation) AddEventType(eret enums.IPCReportEventType) {
	if m.addevent_type != nil {
		*m.addevent_type += eret
	} else {
		m.addevent_type = &eret
	}
}

// AddedEventType returns the value that was added to the "event_type" field in this mutation.
func (m *IPCReportEventMutation) AddedEventType() (r enums.IPCReportEventType, exists bool) {
	v := m.addevent_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventType resets all changes to the "event_type" field.
func (m *IPCReportEventMutation) ResetEventType() {
	m.event_type = nil
	m.addevent_type = nil
}

// SetEventStatus sets the "event_status" field.
func (m *IPCReportEventMutation) SetEventStatus(eres enums.IPCReportEventStatus) {
	m.event_status = &eres
	m.addevent_status = nil
}

// EventStatus returns the value of the "event_status" field in the mutation.
func (m *IPCReportEventMutation) EventStatus() (r enums.IPCReportEventStatus, exists bool) {
	v := m.event_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEventStatus returns the old "event_status" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldEventStatus(ctx context.Context) (v enums.IPCReportEventStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventStatus: %w", err)
	}
	return oldValue.EventStatus, nil
}

// AddEventStatus adds eres to the "event_status" field.
func (m *IPCReportEventMutation) AddEventStatus(eres enums.IPCReportEventStatus) {
	if m.addevent_status != nil {
		*m.addevent_status += eres
	} else {
		m.addevent_status = &eres
	}
}

// AddedEventStatus returns the value that was added to the "event_status" field in this mutation.
func (m *IPCReportEventMutation) AddedEventStatus() (r enums.IPCReportEventStatus, exists bool) {
	v := m.addevent_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventStatus resets all changes to the "event_status" field.
func (m *IPCReportEventMutation) ResetEventStatus() {
	m.event_status = nil
	m.addevent_status = nil
}

// SetImages sets the "images" field.
func (m *IPCReportEventMutation) SetImages(ti []*types.UploadedImage) {
	m.images = &ti
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *IPCReportEventMutation) Images() (r []*types.UploadedImage, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldImages(ctx context.Context) (v []*types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds ti to the "images" field.
func (m *IPCReportEventMutation) AppendImages(ti []*types.UploadedImage) {
	m.appendimages = append(m.appendimages, ti...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *IPCReportEventMutation) AppendedImages() ([]*types.UploadedImage, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *IPCReportEventMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[ipcreportevent.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *IPCReportEventMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[ipcreportevent.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *IPCReportEventMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, ipcreportevent.FieldImages)
}

// SetLabeledImages sets the "labeled_images" field.
func (m *IPCReportEventMutation) SetLabeledImages(ti []*types.UploadedImage) {
	m.labeled_images = &ti
	m.appendlabeled_images = nil
}

// LabeledImages returns the value of the "labeled_images" field in the mutation.
func (m *IPCReportEventMutation) LabeledImages() (r []*types.UploadedImage, exists bool) {
	v := m.labeled_images
	if v == nil {
		return
	}
	return *v, true
}

// OldLabeledImages returns the old "labeled_images" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldLabeledImages(ctx context.Context) (v []*types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabeledImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabeledImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabeledImages: %w", err)
	}
	return oldValue.LabeledImages, nil
}

// AppendLabeledImages adds ti to the "labeled_images" field.
func (m *IPCReportEventMutation) AppendLabeledImages(ti []*types.UploadedImage) {
	m.appendlabeled_images = append(m.appendlabeled_images, ti...)
}

// AppendedLabeledImages returns the list of values that were appended to the "labeled_images" field in this mutation.
func (m *IPCReportEventMutation) AppendedLabeledImages() ([]*types.UploadedImage, bool) {
	if len(m.appendlabeled_images) == 0 {
		return nil, false
	}
	return m.appendlabeled_images, true
}

// ClearLabeledImages clears the value of the "labeled_images" field.
func (m *IPCReportEventMutation) ClearLabeledImages() {
	m.labeled_images = nil
	m.appendlabeled_images = nil
	m.clearedFields[ipcreportevent.FieldLabeledImages] = struct{}{}
}

// LabeledImagesCleared returns if the "labeled_images" field was cleared in this mutation.
func (m *IPCReportEventMutation) LabeledImagesCleared() bool {
	_, ok := m.clearedFields[ipcreportevent.FieldLabeledImages]
	return ok
}

// ResetLabeledImages resets all changes to the "labeled_images" field.
func (m *IPCReportEventMutation) ResetLabeledImages() {
	m.labeled_images = nil
	m.appendlabeled_images = nil
	delete(m.clearedFields, ipcreportevent.FieldLabeledImages)
}

// SetVideoID sets the "video_id" field.
func (m *IPCReportEventMutation) SetVideoID(i int) {
	m.video = &i
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *IPCReportEventMutation) VideoID() (r int, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ClearVideoID clears the value of the "video_id" field.
func (m *IPCReportEventMutation) ClearVideoID() {
	m.video = nil
	m.clearedFields[ipcreportevent.FieldVideoID] = struct{}{}
}

// VideoIDCleared returns if the "video_id" field was cleared in this mutation.
func (m *IPCReportEventMutation) VideoIDCleared() bool {
	_, ok := m.clearedFields[ipcreportevent.FieldVideoID]
	return ok
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *IPCReportEventMutation) ResetVideoID() {
	m.video = nil
	delete(m.clearedFields, ipcreportevent.FieldVideoID)
}

// SetDescription sets the "description" field.
func (m *IPCReportEventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IPCReportEventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IPCReportEventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ipcreportevent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IPCReportEventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ipcreportevent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IPCReportEventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ipcreportevent.FieldDescription)
}

// SetRawData sets the "raw_data" field.
func (m *IPCReportEventMutation) SetRawData(s string) {
	m.raw_data = &s
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *IPCReportEventMutation) RawData() (r string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the IPCReportEvent entity.
// If the IPCReportEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCReportEventMutation) OldRawData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ClearRawData clears the value of the "raw_data" field.
func (m *IPCReportEventMutation) ClearRawData() {
	m.raw_data = nil
	m.clearedFields[ipcreportevent.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *IPCReportEventMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[ipcreportevent.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *IPCReportEventMutation) ResetRawData() {
	m.raw_data = nil
	delete(m.clearedFields, ipcreportevent.FieldRawData)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *IPCReportEventMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *IPCReportEventMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[ipcreportevent.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *IPCReportEventMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *IPCReportEventMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *IPCReportEventMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *IPCReportEventMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *IPCReportEventMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *IPCReportEventMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[ipcreportevent.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *IPCReportEventMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *IPCReportEventMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *IPCReportEventMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *IPCReportEventMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *IPCReportEventMutation) ClearVideo() {
	m.clearedvideo = true
	m.clearedFields[ipcreportevent.FieldVideoID] = struct{}{}
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *IPCReportEventMutation) VideoCleared() bool {
	return m.VideoIDCleared() || m.clearedvideo
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *IPCReportEventMutation) VideoIDs() (ids []int) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *IPCReportEventMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// Where appends a list predicates to the IPCReportEventMutation builder.
func (m *IPCReportEventMutation) Where(ps ...predicate.IPCReportEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IPCReportEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IPCReportEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IPCReportEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IPCReportEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IPCReportEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IPCReportEvent).
func (m *IPCReportEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IPCReportEventMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, ipcreportevent.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, ipcreportevent.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, ipcreportevent.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, ipcreportevent.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, ipcreportevent.FieldUpdatedAt)
	}
	if m.device_brand != nil {
		fields = append(fields, ipcreportevent.FieldDeviceBrand)
	}
	if m.device_model != nil {
		fields = append(fields, ipcreportevent.FieldDeviceModel)
	}
	if m.device_id != nil {
		fields = append(fields, ipcreportevent.FieldDeviceID)
	}
	if m.event_id != nil {
		fields = append(fields, ipcreportevent.FieldEventID)
	}
	if m.event_time != nil {
		fields = append(fields, ipcreportevent.FieldEventTime)
	}
	if m.event_type != nil {
		fields = append(fields, ipcreportevent.FieldEventType)
	}
	if m.event_status != nil {
		fields = append(fields, ipcreportevent.FieldEventStatus)
	}
	if m.images != nil {
		fields = append(fields, ipcreportevent.FieldImages)
	}
	if m.labeled_images != nil {
		fields = append(fields, ipcreportevent.FieldLabeledImages)
	}
	if m.video != nil {
		fields = append(fields, ipcreportevent.FieldVideoID)
	}
	if m.description != nil {
		fields = append(fields, ipcreportevent.FieldDescription)
	}
	if m.raw_data != nil {
		fields = append(fields, ipcreportevent.FieldRawData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IPCReportEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipcreportevent.FieldCreatedAt:
		return m.CreatedAt()
	case ipcreportevent.FieldCreatedBy:
		return m.CreatedBy()
	case ipcreportevent.FieldDeletedAt:
		return m.DeletedAt()
	case ipcreportevent.FieldUpdatedBy:
		return m.UpdatedBy()
	case ipcreportevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case ipcreportevent.FieldDeviceBrand:
		return m.DeviceBrand()
	case ipcreportevent.FieldDeviceModel:
		return m.DeviceModel()
	case ipcreportevent.FieldDeviceID:
		return m.DeviceID()
	case ipcreportevent.FieldEventID:
		return m.EventID()
	case ipcreportevent.FieldEventTime:
		return m.EventTime()
	case ipcreportevent.FieldEventType:
		return m.EventType()
	case ipcreportevent.FieldEventStatus:
		return m.EventStatus()
	case ipcreportevent.FieldImages:
		return m.Images()
	case ipcreportevent.FieldLabeledImages:
		return m.LabeledImages()
	case ipcreportevent.FieldVideoID:
		return m.VideoID()
	case ipcreportevent.FieldDescription:
		return m.Description()
	case ipcreportevent.FieldRawData:
		return m.RawData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IPCReportEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipcreportevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ipcreportevent.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ipcreportevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ipcreportevent.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case ipcreportevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ipcreportevent.FieldDeviceBrand:
		return m.OldDeviceBrand(ctx)
	case ipcreportevent.FieldDeviceModel:
		return m.OldDeviceModel(ctx)
	case ipcreportevent.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case ipcreportevent.FieldEventID:
		return m.OldEventID(ctx)
	case ipcreportevent.FieldEventTime:
		return m.OldEventTime(ctx)
	case ipcreportevent.FieldEventType:
		return m.OldEventType(ctx)
	case ipcreportevent.FieldEventStatus:
		return m.OldEventStatus(ctx)
	case ipcreportevent.FieldImages:
		return m.OldImages(ctx)
	case ipcreportevent.FieldLabeledImages:
		return m.OldLabeledImages(ctx)
	case ipcreportevent.FieldVideoID:
		return m.OldVideoID(ctx)
	case ipcreportevent.FieldDescription:
		return m.OldDescription(ctx)
	case ipcreportevent.FieldRawData:
		return m.OldRawData(ctx)
	}
	return nil, fmt.Errorf("unknown IPCReportEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPCReportEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipcreportevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ipcreportevent.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ipcreportevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ipcreportevent.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case ipcreportevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ipcreportevent.FieldDeviceBrand:
		v, ok := value.(enums.IPCReportEventDeviceBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceBrand(v)
		return nil
	case ipcreportevent.FieldDeviceModel:
		v, ok := value.(enums.IPCReportEventDeviceModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceModel(v)
		return nil
	case ipcreportevent.FieldDeviceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case ipcreportevent.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case ipcreportevent.FieldEventTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTime(v)
		return nil
	case ipcreportevent.FieldEventType:
		v, ok := value.(enums.IPCReportEventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case ipcreportevent.FieldEventStatus:
		v, ok := value.(enums.IPCReportEventStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventStatus(v)
		return nil
	case ipcreportevent.FieldImages:
		v, ok := value.([]*types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case ipcreportevent.FieldLabeledImages:
		v, ok := value.([]*types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabeledImages(v)
		return nil
	case ipcreportevent.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case ipcreportevent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ipcreportevent.FieldRawData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	}
	return fmt.Errorf("unknown IPCReportEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IPCReportEventMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_brand != nil {
		fields = append(fields, ipcreportevent.FieldDeviceBrand)
	}
	if m.adddevice_model != nil {
		fields = append(fields, ipcreportevent.FieldDeviceModel)
	}
	if m.addevent_type != nil {
		fields = append(fields, ipcreportevent.FieldEventType)
	}
	if m.addevent_status != nil {
		fields = append(fields, ipcreportevent.FieldEventStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IPCReportEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipcreportevent.FieldDeviceBrand:
		return m.AddedDeviceBrand()
	case ipcreportevent.FieldDeviceModel:
		return m.AddedDeviceModel()
	case ipcreportevent.FieldEventType:
		return m.AddedEventType()
	case ipcreportevent.FieldEventStatus:
		return m.AddedEventStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPCReportEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipcreportevent.FieldDeviceBrand:
		v, ok := value.(enums.IPCReportEventDeviceBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceBrand(v)
		return nil
	case ipcreportevent.FieldDeviceModel:
		v, ok := value.(enums.IPCReportEventDeviceModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceModel(v)
		return nil
	case ipcreportevent.FieldEventType:
		v, ok := value.(enums.IPCReportEventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventType(v)
		return nil
	case ipcreportevent.FieldEventStatus:
		v, ok := value.(enums.IPCReportEventStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventStatus(v)
		return nil
	}
	return fmt.Errorf("unknown IPCReportEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IPCReportEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipcreportevent.FieldDeletedAt) {
		fields = append(fields, ipcreportevent.FieldDeletedAt)
	}
	if m.FieldCleared(ipcreportevent.FieldImages) {
		fields = append(fields, ipcreportevent.FieldImages)
	}
	if m.FieldCleared(ipcreportevent.FieldLabeledImages) {
		fields = append(fields, ipcreportevent.FieldLabeledImages)
	}
	if m.FieldCleared(ipcreportevent.FieldVideoID) {
		fields = append(fields, ipcreportevent.FieldVideoID)
	}
	if m.FieldCleared(ipcreportevent.FieldDescription) {
		fields = append(fields, ipcreportevent.FieldDescription)
	}
	if m.FieldCleared(ipcreportevent.FieldRawData) {
		fields = append(fields, ipcreportevent.FieldRawData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IPCReportEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPCReportEventMutation) ClearField(name string) error {
	switch name {
	case ipcreportevent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ipcreportevent.FieldImages:
		m.ClearImages()
		return nil
	case ipcreportevent.FieldLabeledImages:
		m.ClearLabeledImages()
		return nil
	case ipcreportevent.FieldVideoID:
		m.ClearVideoID()
		return nil
	case ipcreportevent.FieldDescription:
		m.ClearDescription()
		return nil
	case ipcreportevent.FieldRawData:
		m.ClearRawData()
		return nil
	}
	return fmt.Errorf("unknown IPCReportEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IPCReportEventMutation) ResetField(name string) error {
	switch name {
	case ipcreportevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ipcreportevent.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ipcreportevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ipcreportevent.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case ipcreportevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ipcreportevent.FieldDeviceBrand:
		m.ResetDeviceBrand()
		return nil
	case ipcreportevent.FieldDeviceModel:
		m.ResetDeviceModel()
		return nil
	case ipcreportevent.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case ipcreportevent.FieldEventID:
		m.ResetEventID()
		return nil
	case ipcreportevent.FieldEventTime:
		m.ResetEventTime()
		return nil
	case ipcreportevent.FieldEventType:
		m.ResetEventType()
		return nil
	case ipcreportevent.FieldEventStatus:
		m.ResetEventStatus()
		return nil
	case ipcreportevent.FieldImages:
		m.ResetImages()
		return nil
	case ipcreportevent.FieldLabeledImages:
		m.ResetLabeledImages()
		return nil
	case ipcreportevent.FieldVideoID:
		m.ResetVideoID()
		return nil
	case ipcreportevent.FieldDescription:
		m.ResetDescription()
		return nil
	case ipcreportevent.FieldRawData:
		m.ResetRawData()
		return nil
	}
	return fmt.Errorf("unknown IPCReportEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IPCReportEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, ipcreportevent.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, ipcreportevent.EdgeUpdater)
	}
	if m.video != nil {
		edges = append(edges, ipcreportevent.EdgeVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IPCReportEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipcreportevent.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case ipcreportevent.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case ipcreportevent.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IPCReportEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IPCReportEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IPCReportEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, ipcreportevent.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, ipcreportevent.EdgeUpdater)
	}
	if m.clearedvideo {
		edges = append(edges, ipcreportevent.EdgeVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IPCReportEventMutation) EdgeCleared(name string) bool {
	switch name {
	case ipcreportevent.EdgeCreator:
		return m.clearedcreator
	case ipcreportevent.EdgeUpdater:
		return m.clearedupdater
	case ipcreportevent.EdgeVideo:
		return m.clearedvideo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IPCReportEventMutation) ClearEdge(name string) error {
	switch name {
	case ipcreportevent.EdgeCreator:
		m.ClearCreator()
		return nil
	case ipcreportevent.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case ipcreportevent.EdgeVideo:
		m.ClearVideo()
		return nil
	}
	return fmt.Errorf("unknown IPCReportEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IPCReportEventMutation) ResetEdge(name string) error {
	switch name {
	case ipcreportevent.EdgeCreator:
		m.ResetCreator()
		return nil
	case ipcreportevent.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case ipcreportevent.EdgeVideo:
		m.ResetVideo()
		return nil
	}
	return fmt.Errorf("unknown IPCReportEvent edge %s", name)
}

// OccupationMutation represents an operation that mutates the Occupation nodes in the graph.
type OccupationMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	deleted_at       *time.Time
	updated_at       *time.Time
	name             *string
	description      *string
	clearedFields    map[string]struct{}
	creator          *int
	clearedcreator   bool
	updater          *int
	clearedupdater   bool
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	clearedemployees bool
	done             bool
	oldValue         func(context.Context) (*Occupation, error)
	predicates       []predicate.Occupation
}

var _ ent.Mutation = (*OccupationMutation)(nil)

// occupationOption allows management of the mutation configuration using functional options.
type occupationOption func(*OccupationMutation)

// newOccupationMutation creates new mutation for the Occupation entity.
func newOccupationMutation(c config, op Op, opts ...occupationOption) *OccupationMutation {
	m := &OccupationMutation{
		config:        c,
		op:            op,
		typ:           TypeOccupation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccupationID sets the ID field of the mutation.
func withOccupationID(id int) occupationOption {
	return func(m *OccupationMutation) {
		var (
			err   error
			once  sync.Once
			value *Occupation
		)
		m.oldValue = func(ctx context.Context) (*Occupation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occupation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccupation sets the old Occupation of the mutation.
func withOccupation(node *Occupation) occupationOption {
	return func(m *OccupationMutation) {
		m.oldValue = func(context.Context) (*Occupation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccupationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccupationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccupationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccupationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occupation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OccupationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OccupationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OccupationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OccupationMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OccupationMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OccupationMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OccupationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OccupationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OccupationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[occupation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OccupationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[occupation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OccupationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, occupation.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OccupationMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OccupationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OccupationMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OccupationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OccupationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OccupationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *OccupationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OccupationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OccupationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OccupationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OccupationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OccupationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[occupation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OccupationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[occupation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OccupationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, occupation.FieldDescription)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *OccupationMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *OccupationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[occupation.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *OccupationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *OccupationMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *OccupationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *OccupationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *OccupationMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *OccupationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[occupation.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *OccupationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *OccupationMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *OccupationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *OccupationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *OccupationMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *OccupationMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *OccupationMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *OccupationMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *OccupationMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *OccupationMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *OccupationMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// Where appends a list predicates to the OccupationMutation builder.
func (m *OccupationMutation) Where(ps ...predicate.Occupation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccupationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccupationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occupation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccupationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccupationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occupation).
func (m *OccupationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccupationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, occupation.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, occupation.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, occupation.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, occupation.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, occupation.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, occupation.FieldName)
	}
	if m.description != nil {
		fields = append(fields, occupation.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccupationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occupation.FieldCreatedAt:
		return m.CreatedAt()
	case occupation.FieldCreatedBy:
		return m.CreatedBy()
	case occupation.FieldDeletedAt:
		return m.DeletedAt()
	case occupation.FieldUpdatedBy:
		return m.UpdatedBy()
	case occupation.FieldUpdatedAt:
		return m.UpdatedAt()
	case occupation.FieldName:
		return m.Name()
	case occupation.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccupationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occupation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case occupation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case occupation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case occupation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case occupation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case occupation.FieldName:
		return m.OldName(ctx)
	case occupation.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Occupation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occupation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case occupation.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case occupation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case occupation.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case occupation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case occupation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case occupation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Occupation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccupationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccupationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Occupation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccupationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occupation.FieldDeletedAt) {
		fields = append(fields, occupation.FieldDeletedAt)
	}
	if m.FieldCleared(occupation.FieldDescription) {
		fields = append(fields, occupation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccupationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccupationMutation) ClearField(name string) error {
	switch name {
	case occupation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case occupation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Occupation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccupationMutation) ResetField(name string) error {
	switch name {
	case occupation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case occupation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case occupation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case occupation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case occupation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case occupation.FieldName:
		m.ResetName()
		return nil
	case occupation.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Occupation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccupationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, occupation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, occupation.EdgeUpdater)
	}
	if m.employees != nil {
		edges = append(edges, occupation.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccupationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occupation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case occupation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case occupation.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccupationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedemployees != nil {
		edges = append(edges, occupation.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccupationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case occupation.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccupationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, occupation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, occupation.EdgeUpdater)
	}
	if m.clearedemployees {
		edges = append(edges, occupation.EdgeEmployees)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccupationMutation) EdgeCleared(name string) bool {
	switch name {
	case occupation.EdgeCreator:
		return m.clearedcreator
	case occupation.EdgeUpdater:
		return m.clearedupdater
	case occupation.EdgeEmployees:
		return m.clearedemployees
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccupationMutation) ClearEdge(name string) error {
	switch name {
	case occupation.EdgeCreator:
		m.ClearCreator()
		return nil
	case occupation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Occupation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccupationMutation) ResetEdge(name string) error {
	switch name {
	case occupation.EdgeCreator:
		m.ResetCreator()
		return nil
	case occupation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case occupation.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Occupation edge %s", name)
}

// RiskMutation represents an operation that mutates the Risk nodes in the graph.
type RiskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	deleted_at           *time.Time
	updated_at           *time.Time
	title                *string
	content              *string
	images               *[]types.UploadedImage
	appendimages         []types.UploadedImage
	measures             *string
	maintain_status      *maintain_status.MaintainStatus
	addmaintain_status   *maintain_status.MaintainStatus
	due_time             *time.Time
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	updater              *int
	clearedupdater       bool
	risk_category        *int
	clearedrisk_category bool
	risk_location        *int
	clearedrisk_location bool
	reporter             *int
	clearedreporter      bool
	maintainer           *int
	clearedmaintainer    bool
	done                 bool
	oldValue             func(context.Context) (*Risk, error)
	predicates           []predicate.Risk
}

var _ ent.Mutation = (*RiskMutation)(nil)

// riskOption allows management of the mutation configuration using functional options.
type riskOption func(*RiskMutation)

// newRiskMutation creates new mutation for the Risk entity.
func newRiskMutation(c config, op Op, opts ...riskOption) *RiskMutation {
	m := &RiskMutation{
		config:        c,
		op:            op,
		typ:           TypeRisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskID sets the ID field of the mutation.
func withRiskID(id int) riskOption {
	return func(m *RiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Risk
		)
		m.oldValue = func(ctx context.Context) (*Risk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Risk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRisk sets the old Risk of the mutation.
func withRisk(node *Risk) riskOption {
	return func(m *RiskMutation) {
		m.oldValue = func(context.Context) (*Risk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Risk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[risk.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[risk.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, risk.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *RiskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RiskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RiskMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *RiskMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *RiskMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *RiskMutation) ClearContent() {
	m.content = nil
	m.clearedFields[risk.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *RiskMutation) ContentCleared() bool {
	_, ok := m.clearedFields[risk.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *RiskMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, risk.FieldContent)
}

// SetImages sets the "images" field.
func (m *RiskMutation) SetImages(ti []types.UploadedImage) {
	m.images = &ti
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *RiskMutation) Images() (r []types.UploadedImage, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldImages(ctx context.Context) (v []types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds ti to the "images" field.
func (m *RiskMutation) AppendImages(ti []types.UploadedImage) {
	m.appendimages = append(m.appendimages, ti...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *RiskMutation) AppendedImages() ([]types.UploadedImage, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *RiskMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[risk.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *RiskMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[risk.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *RiskMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, risk.FieldImages)
}

// SetRiskCategoryID sets the "risk_category_id" field.
func (m *RiskMutation) SetRiskCategoryID(i int) {
	m.risk_category = &i
}

// RiskCategoryID returns the value of the "risk_category_id" field in the mutation.
func (m *RiskMutation) RiskCategoryID() (r int, exists bool) {
	v := m.risk_category
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskCategoryID returns the old "risk_category_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskCategoryID: %w", err)
	}
	return oldValue.RiskCategoryID, nil
}

// ResetRiskCategoryID resets all changes to the "risk_category_id" field.
func (m *RiskMutation) ResetRiskCategoryID() {
	m.risk_category = nil
}

// SetRiskLocationID sets the "risk_location_id" field.
func (m *RiskMutation) SetRiskLocationID(i int) {
	m.risk_location = &i
}

// RiskLocationID returns the value of the "risk_location_id" field in the mutation.
func (m *RiskMutation) RiskLocationID() (r int, exists bool) {
	v := m.risk_location
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLocationID returns the old "risk_location_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLocationID: %w", err)
	}
	return oldValue.RiskLocationID, nil
}

// ResetRiskLocationID resets all changes to the "risk_location_id" field.
func (m *RiskMutation) ResetRiskLocationID() {
	m.risk_location = nil
}

// SetReporterID sets the "reporter_id" field.
func (m *RiskMutation) SetReporterID(i int) {
	m.reporter = &i
}

// ReporterID returns the value of the "reporter_id" field in the mutation.
func (m *RiskMutation) ReporterID() (r int, exists bool) {
	v := m.reporter
	if v == nil {
		return
	}
	return *v, true
}

// OldReporterID returns the old "reporter_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldReporterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporterID: %w", err)
	}
	return oldValue.ReporterID, nil
}

// ResetReporterID resets all changes to the "reporter_id" field.
func (m *RiskMutation) ResetReporterID() {
	m.reporter = nil
}

// SetMaintainerID sets the "maintainer_id" field.
func (m *RiskMutation) SetMaintainerID(i int) {
	m.maintainer = &i
}

// MaintainerID returns the value of the "maintainer_id" field in the mutation.
func (m *RiskMutation) MaintainerID() (r int, exists bool) {
	v := m.maintainer
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainerID returns the old "maintainer_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainerID: %w", err)
	}
	return oldValue.MaintainerID, nil
}

// ResetMaintainerID resets all changes to the "maintainer_id" field.
func (m *RiskMutation) ResetMaintainerID() {
	m.maintainer = nil
}

// SetMeasures sets the "measures" field.
func (m *RiskMutation) SetMeasures(s string) {
	m.measures = &s
}

// Measures returns the value of the "measures" field in the mutation.
func (m *RiskMutation) Measures() (r string, exists bool) {
	v := m.measures
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasures returns the old "measures" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMeasures(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasures: %w", err)
	}
	return oldValue.Measures, nil
}

// ClearMeasures clears the value of the "measures" field.
func (m *RiskMutation) ClearMeasures() {
	m.measures = nil
	m.clearedFields[risk.FieldMeasures] = struct{}{}
}

// MeasuresCleared returns if the "measures" field was cleared in this mutation.
func (m *RiskMutation) MeasuresCleared() bool {
	_, ok := m.clearedFields[risk.FieldMeasures]
	return ok
}

// ResetMeasures resets all changes to the "measures" field.
func (m *RiskMutation) ResetMeasures() {
	m.measures = nil
	delete(m.clearedFields, risk.FieldMeasures)
}

// SetMaintainStatus sets the "maintain_status" field.
func (m *RiskMutation) SetMaintainStatus(mss maintain_status.MaintainStatus) {
	m.maintain_status = &mss
	m.addmaintain_status = nil
}

// MaintainStatus returns the value of the "maintain_status" field in the mutation.
func (m *RiskMutation) MaintainStatus() (r maintain_status.MaintainStatus, exists bool) {
	v := m.maintain_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainStatus returns the old "maintain_status" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainStatus(ctx context.Context) (v maintain_status.MaintainStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainStatus: %w", err)
	}
	return oldValue.MaintainStatus, nil
}

// AddMaintainStatus adds mss to the "maintain_status" field.
func (m *RiskMutation) AddMaintainStatus(mss maintain_status.MaintainStatus) {
	if m.addmaintain_status != nil {
		*m.addmaintain_status += mss
	} else {
		m.addmaintain_status = &mss
	}
}

// AddedMaintainStatus returns the value that was added to the "maintain_status" field in this mutation.
func (m *RiskMutation) AddedMaintainStatus() (r maintain_status.MaintainStatus, exists bool) {
	v := m.addmaintain_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainStatus resets all changes to the "maintain_status" field.
func (m *RiskMutation) ResetMaintainStatus() {
	m.maintain_status = nil
	m.addmaintain_status = nil
}

// SetDueTime sets the "due_time" field.
func (m *RiskMutation) SetDueTime(t time.Time) {
	m.due_time = &t
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *RiskMutation) DueTime() (r time.Time, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *RiskMutation) ResetDueTime() {
	m.due_time = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risk.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *RiskMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[risk.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *RiskMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearRiskCategory clears the "risk_category" edge to the RiskCategory entity.
func (m *RiskMutation) ClearRiskCategory() {
	m.clearedrisk_category = true
	m.clearedFields[risk.FieldRiskCategoryID] = struct{}{}
}

// RiskCategoryCleared reports if the "risk_category" edge to the RiskCategory entity was cleared.
func (m *RiskMutation) RiskCategoryCleared() bool {
	return m.clearedrisk_category
}

// RiskCategoryIDs returns the "risk_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskCategoryID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) RiskCategoryIDs() (ids []int) {
	if id := m.risk_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskCategory resets all changes to the "risk_category" edge.
func (m *RiskMutation) ResetRiskCategory() {
	m.risk_category = nil
	m.clearedrisk_category = false
}

// ClearRiskLocation clears the "risk_location" edge to the RiskLocation entity.
func (m *RiskMutation) ClearRiskLocation() {
	m.clearedrisk_location = true
	m.clearedFields[risk.FieldRiskLocationID] = struct{}{}
}

// RiskLocationCleared reports if the "risk_location" edge to the RiskLocation entity was cleared.
func (m *RiskMutation) RiskLocationCleared() bool {
	return m.clearedrisk_location
}

// RiskLocationIDs returns the "risk_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskLocationID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) RiskLocationIDs() (ids []int) {
	if id := m.risk_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskLocation resets all changes to the "risk_location" edge.
func (m *RiskMutation) ResetRiskLocation() {
	m.risk_location = nil
	m.clearedrisk_location = false
}

// ClearReporter clears the "reporter" edge to the Employee entity.
func (m *RiskMutation) ClearReporter() {
	m.clearedreporter = true
	m.clearedFields[risk.FieldReporterID] = struct{}{}
}

// ReporterCleared reports if the "reporter" edge to the Employee entity was cleared.
func (m *RiskMutation) ReporterCleared() bool {
	return m.clearedreporter
}

// ReporterIDs returns the "reporter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReporterID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) ReporterIDs() (ids []int) {
	if id := m.reporter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReporter resets all changes to the "reporter" edge.
func (m *RiskMutation) ResetReporter() {
	m.reporter = nil
	m.clearedreporter = false
}

// ClearMaintainer clears the "maintainer" edge to the Employee entity.
func (m *RiskMutation) ClearMaintainer() {
	m.clearedmaintainer = true
	m.clearedFields[risk.FieldMaintainerID] = struct{}{}
}

// MaintainerCleared reports if the "maintainer" edge to the Employee entity was cleared.
func (m *RiskMutation) MaintainerCleared() bool {
	return m.clearedmaintainer
}

// MaintainerIDs returns the "maintainer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MaintainerID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) MaintainerIDs() (ids []int) {
	if id := m.maintainer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMaintainer resets all changes to the "maintainer" edge.
func (m *RiskMutation) ResetMaintainer() {
	m.maintainer = nil
	m.clearedmaintainer = false
}

// Where appends a list predicates to the RiskMutation builder.
func (m *RiskMutation) Where(ps ...predicate.Risk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Risk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Risk).
func (m *RiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, risk.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, risk.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, risk.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, risk.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, risk.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, risk.FieldContent)
	}
	if m.images != nil {
		fields = append(fields, risk.FieldImages)
	}
	if m.risk_category != nil {
		fields = append(fields, risk.FieldRiskCategoryID)
	}
	if m.risk_location != nil {
		fields = append(fields, risk.FieldRiskLocationID)
	}
	if m.reporter != nil {
		fields = append(fields, risk.FieldReporterID)
	}
	if m.maintainer != nil {
		fields = append(fields, risk.FieldMaintainerID)
	}
	if m.measures != nil {
		fields = append(fields, risk.FieldMeasures)
	}
	if m.maintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	if m.due_time != nil {
		fields = append(fields, risk.FieldDueTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldCreatedAt:
		return m.CreatedAt()
	case risk.FieldCreatedBy:
		return m.CreatedBy()
	case risk.FieldDeletedAt:
		return m.DeletedAt()
	case risk.FieldUpdatedBy:
		return m.UpdatedBy()
	case risk.FieldUpdatedAt:
		return m.UpdatedAt()
	case risk.FieldTitle:
		return m.Title()
	case risk.FieldContent:
		return m.Content()
	case risk.FieldImages:
		return m.Images()
	case risk.FieldRiskCategoryID:
		return m.RiskCategoryID()
	case risk.FieldRiskLocationID:
		return m.RiskLocationID()
	case risk.FieldReporterID:
		return m.ReporterID()
	case risk.FieldMaintainerID:
		return m.MaintainerID()
	case risk.FieldMeasures:
		return m.Measures()
	case risk.FieldMaintainStatus:
		return m.MaintainStatus()
	case risk.FieldDueTime:
		return m.DueTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case risk.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case risk.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case risk.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case risk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case risk.FieldTitle:
		return m.OldTitle(ctx)
	case risk.FieldContent:
		return m.OldContent(ctx)
	case risk.FieldImages:
		return m.OldImages(ctx)
	case risk.FieldRiskCategoryID:
		return m.OldRiskCategoryID(ctx)
	case risk.FieldRiskLocationID:
		return m.OldRiskLocationID(ctx)
	case risk.FieldReporterID:
		return m.OldReporterID(ctx)
	case risk.FieldMaintainerID:
		return m.OldMaintainerID(ctx)
	case risk.FieldMeasures:
		return m.OldMeasures(ctx)
	case risk.FieldMaintainStatus:
		return m.OldMaintainStatus(ctx)
	case risk.FieldDueTime:
		return m.OldDueTime(ctx)
	}
	return nil, fmt.Errorf("unknown Risk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case risk.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case risk.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case risk.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case risk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case risk.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case risk.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case risk.FieldImages:
		v, ok := value.([]types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case risk.FieldRiskCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskCategoryID(v)
		return nil
	case risk.FieldRiskLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLocationID(v)
		return nil
	case risk.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporterID(v)
		return nil
	case risk.FieldMaintainerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainerID(v)
		return nil
	case risk.FieldMeasures:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasures(v)
		return nil
	case risk.FieldMaintainStatus:
		v, ok := value.(maintain_status.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainStatus(v)
		return nil
	case risk.FieldDueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskMutation) AddedFields() []string {
	var fields []string
	if m.addmaintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldMaintainStatus:
		return m.AddedMaintainStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case risk.FieldMaintainStatus:
		v, ok := value.(maintain_status.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Risk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risk.FieldDeletedAt) {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.FieldCleared(risk.FieldContent) {
		fields = append(fields, risk.FieldContent)
	}
	if m.FieldCleared(risk.FieldImages) {
		fields = append(fields, risk.FieldImages)
	}
	if m.FieldCleared(risk.FieldMeasures) {
		fields = append(fields, risk.FieldMeasures)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskMutation) ClearField(name string) error {
	switch name {
	case risk.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case risk.FieldContent:
		m.ClearContent()
		return nil
	case risk.FieldImages:
		m.ClearImages()
		return nil
	case risk.FieldMeasures:
		m.ClearMeasures()
		return nil
	}
	return fmt.Errorf("unknown Risk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskMutation) ResetField(name string) error {
	switch name {
	case risk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case risk.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case risk.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case risk.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case risk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case risk.FieldTitle:
		m.ResetTitle()
		return nil
	case risk.FieldContent:
		m.ResetContent()
		return nil
	case risk.FieldImages:
		m.ResetImages()
		return nil
	case risk.FieldRiskCategoryID:
		m.ResetRiskCategoryID()
		return nil
	case risk.FieldRiskLocationID:
		m.ResetRiskLocationID()
		return nil
	case risk.FieldReporterID:
		m.ResetReporterID()
		return nil
	case risk.FieldMaintainerID:
		m.ResetMaintainerID()
		return nil
	case risk.FieldMeasures:
		m.ResetMeasures()
		return nil
	case risk.FieldMaintainStatus:
		m.ResetMaintainStatus()
		return nil
	case risk.FieldDueTime:
		m.ResetDueTime()
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.creator != nil {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, risk.EdgeUpdater)
	}
	if m.risk_category != nil {
		edges = append(edges, risk.EdgeRiskCategory)
	}
	if m.risk_location != nil {
		edges = append(edges, risk.EdgeRiskLocation)
	}
	if m.reporter != nil {
		edges = append(edges, risk.EdgeReporter)
	}
	if m.maintainer != nil {
		edges = append(edges, risk.EdgeMaintainer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risk.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeRiskCategory:
		if id := m.risk_category; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeRiskLocation:
		if id := m.risk_location; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeReporter:
		if id := m.reporter; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeMaintainer:
		if id := m.maintainer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcreator {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, risk.EdgeUpdater)
	}
	if m.clearedrisk_category {
		edges = append(edges, risk.EdgeRiskCategory)
	}
	if m.clearedrisk_location {
		edges = append(edges, risk.EdgeRiskLocation)
	}
	if m.clearedreporter {
		edges = append(edges, risk.EdgeReporter)
	}
	if m.clearedmaintainer {
		edges = append(edges, risk.EdgeMaintainer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskMutation) EdgeCleared(name string) bool {
	switch name {
	case risk.EdgeCreator:
		return m.clearedcreator
	case risk.EdgeUpdater:
		return m.clearedupdater
	case risk.EdgeRiskCategory:
		return m.clearedrisk_category
	case risk.EdgeRiskLocation:
		return m.clearedrisk_location
	case risk.EdgeReporter:
		return m.clearedreporter
	case risk.EdgeMaintainer:
		return m.clearedmaintainer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskMutation) ClearEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ClearCreator()
		return nil
	case risk.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case risk.EdgeRiskCategory:
		m.ClearRiskCategory()
		return nil
	case risk.EdgeRiskLocation:
		m.ClearRiskLocation()
		return nil
	case risk.EdgeReporter:
		m.ClearReporter()
		return nil
	case risk.EdgeMaintainer:
		m.ClearMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Risk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskMutation) ResetEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ResetCreator()
		return nil
	case risk.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case risk.EdgeRiskCategory:
		m.ResetRiskCategory()
		return nil
	case risk.EdgeRiskLocation:
		m.ResetRiskLocation()
		return nil
	case risk.EdgeReporter:
		m.ResetReporter()
		return nil
	case risk.EdgeMaintainer:
		m.ResetMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Risk edge %s", name)
}

// RiskCategoryMutation represents an operation that mutates the RiskCategory nodes in the graph.
type RiskCategoryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	deleted_at     *time.Time
	updated_at     *time.Time
	name           *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	risk           map[int]struct{}
	removedrisk    map[int]struct{}
	clearedrisk    bool
	done           bool
	oldValue       func(context.Context) (*RiskCategory, error)
	predicates     []predicate.RiskCategory
}

var _ ent.Mutation = (*RiskCategoryMutation)(nil)

// riskcategoryOption allows management of the mutation configuration using functional options.
type riskcategoryOption func(*RiskCategoryMutation)

// newRiskCategoryMutation creates new mutation for the RiskCategory entity.
func newRiskCategoryMutation(c config, op Op, opts ...riskcategoryOption) *RiskCategoryMutation {
	m := &RiskCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskCategoryID sets the ID field of the mutation.
func withRiskCategoryID(id int) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskCategory
		)
		m.oldValue = func(ctx context.Context) (*RiskCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskCategory sets the old RiskCategory of the mutation.
func withRiskCategory(node *RiskCategory) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		m.oldValue = func(context.Context) (*RiskCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskCategoryMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskCategoryMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskCategoryMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[riskcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[riskcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, riskcategory.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskCategoryMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskCategoryMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskCategoryMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RiskCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskCategoryMutation) ResetName() {
	m.name = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskCategoryMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskCategoryMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[riskcategory.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskCategoryMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskCategoryMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskCategoryMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskCategoryMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *RiskCategoryMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskCategoryMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[riskcategory.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskCategoryMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *RiskCategoryMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskCategoryMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskCategoryMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddRiskIDs adds the "risk" edge to the Risk entity by ids.
func (m *RiskCategoryMutation) AddRiskIDs(ids ...int) {
	if m.risk == nil {
		m.risk = make(map[int]struct{})
	}
	for i := range ids {
		m.risk[ids[i]] = struct{}{}
	}
}

// ClearRisk clears the "risk" edge to the Risk entity.
func (m *RiskCategoryMutation) ClearRisk() {
	m.clearedrisk = true
}

// RiskCleared reports if the "risk" edge to the Risk entity was cleared.
func (m *RiskCategoryMutation) RiskCleared() bool {
	return m.clearedrisk
}

// RemoveRiskIDs removes the "risk" edge to the Risk entity by IDs.
func (m *RiskCategoryMutation) RemoveRiskIDs(ids ...int) {
	if m.removedrisk == nil {
		m.removedrisk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk, ids[i])
		m.removedrisk[ids[i]] = struct{}{}
	}
}

// RemovedRisk returns the removed IDs of the "risk" edge to the Risk entity.
func (m *RiskCategoryMutation) RemovedRiskIDs() (ids []int) {
	for id := range m.removedrisk {
		ids = append(ids, id)
	}
	return
}

// RiskIDs returns the "risk" edge IDs in the mutation.
func (m *RiskCategoryMutation) RiskIDs() (ids []int) {
	for id := range m.risk {
		ids = append(ids, id)
	}
	return
}

// ResetRisk resets all changes to the "risk" edge.
func (m *RiskCategoryMutation) ResetRisk() {
	m.risk = nil
	m.clearedrisk = false
	m.removedrisk = nil
}

// Where appends a list predicates to the RiskCategoryMutation builder.
func (m *RiskCategoryMutation) Where(ps ...predicate.RiskCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskCategory).
func (m *RiskCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, riskcategory.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, riskcategory.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, riskcategory.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, riskcategory.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, riskcategory.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, riskcategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case riskcategory.FieldCreatedAt:
		return m.CreatedAt()
	case riskcategory.FieldCreatedBy:
		return m.CreatedBy()
	case riskcategory.FieldDeletedAt:
		return m.DeletedAt()
	case riskcategory.FieldUpdatedBy:
		return m.UpdatedBy()
	case riskcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case riskcategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case riskcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case riskcategory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case riskcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case riskcategory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case riskcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case riskcategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RiskCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case riskcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case riskcategory.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case riskcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case riskcategory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case riskcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case riskcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskCategoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiskCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(riskcategory.FieldDeletedAt) {
		fields = append(fields, riskcategory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ClearField(name string) error {
	switch name {
	case riskcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ResetField(name string) error {
	switch name {
	case riskcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case riskcategory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case riskcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case riskcategory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case riskcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case riskcategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, riskcategory.EdgeUpdater)
	}
	if m.risk != nil {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case riskcategory.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case riskcategory.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.risk))
		for id := range m.risk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrisk != nil {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.removedrisk))
		for id := range m.removedrisk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, riskcategory.EdgeUpdater)
	}
	if m.clearedrisk {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case riskcategory.EdgeCreator:
		return m.clearedcreator
	case riskcategory.EdgeUpdater:
		return m.clearedupdater
	case riskcategory.EdgeRisk:
		return m.clearedrisk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskCategoryMutation) ClearEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ClearCreator()
		return nil
	case riskcategory.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskCategoryMutation) ResetEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ResetCreator()
		return nil
	case riskcategory.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case riskcategory.EdgeRisk:
		m.ResetRisk()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory edge %s", name)
}

// RiskLocationMutation represents an operation that mutates the RiskLocation nodes in the graph.
type RiskLocationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	deleted_at     *time.Time
	updated_at     *time.Time
	name           *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	risk           map[int]struct{}
	removedrisk    map[int]struct{}
	clearedrisk    bool
	done           bool
	oldValue       func(context.Context) (*RiskLocation, error)
	predicates     []predicate.RiskLocation
}

var _ ent.Mutation = (*RiskLocationMutation)(nil)

// risklocationOption allows management of the mutation configuration using functional options.
type risklocationOption func(*RiskLocationMutation)

// newRiskLocationMutation creates new mutation for the RiskLocation entity.
func newRiskLocationMutation(c config, op Op, opts ...risklocationOption) *RiskLocationMutation {
	m := &RiskLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskLocationID sets the ID field of the mutation.
func withRiskLocationID(id int) risklocationOption {
	return func(m *RiskLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskLocation
		)
		m.oldValue = func(ctx context.Context) (*RiskLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskLocation sets the old RiskLocation of the mutation.
func withRiskLocation(node *RiskLocation) risklocationOption {
	return func(m *RiskLocationMutation) {
		m.oldValue = func(context.Context) (*RiskLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskLocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskLocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskLocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskLocationMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskLocationMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskLocationMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskLocationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskLocationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskLocationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[risklocation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskLocationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[risklocation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskLocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, risklocation.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskLocationMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskLocationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskLocationMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskLocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskLocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RiskLocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskLocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskLocationMutation) ResetName() {
	m.name = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskLocationMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskLocationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risklocation.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskLocationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskLocationMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskLocationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskLocationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *RiskLocationMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskLocationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[risklocation.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskLocationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *RiskLocationMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskLocationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskLocationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddRiskIDs adds the "risk" edge to the Risk entity by ids.
func (m *RiskLocationMutation) AddRiskIDs(ids ...int) {
	if m.risk == nil {
		m.risk = make(map[int]struct{})
	}
	for i := range ids {
		m.risk[ids[i]] = struct{}{}
	}
}

// ClearRisk clears the "risk" edge to the Risk entity.
func (m *RiskLocationMutation) ClearRisk() {
	m.clearedrisk = true
}

// RiskCleared reports if the "risk" edge to the Risk entity was cleared.
func (m *RiskLocationMutation) RiskCleared() bool {
	return m.clearedrisk
}

// RemoveRiskIDs removes the "risk" edge to the Risk entity by IDs.
func (m *RiskLocationMutation) RemoveRiskIDs(ids ...int) {
	if m.removedrisk == nil {
		m.removedrisk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk, ids[i])
		m.removedrisk[ids[i]] = struct{}{}
	}
}

// RemovedRisk returns the removed IDs of the "risk" edge to the Risk entity.
func (m *RiskLocationMutation) RemovedRiskIDs() (ids []int) {
	for id := range m.removedrisk {
		ids = append(ids, id)
	}
	return
}

// RiskIDs returns the "risk" edge IDs in the mutation.
func (m *RiskLocationMutation) RiskIDs() (ids []int) {
	for id := range m.risk {
		ids = append(ids, id)
	}
	return
}

// ResetRisk resets all changes to the "risk" edge.
func (m *RiskLocationMutation) ResetRisk() {
	m.risk = nil
	m.clearedrisk = false
	m.removedrisk = nil
}

// Where appends a list predicates to the RiskLocationMutation builder.
func (m *RiskLocationMutation) Where(ps ...predicate.RiskLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskLocation).
func (m *RiskLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskLocationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, risklocation.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, risklocation.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, risklocation.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, risklocation.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, risklocation.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, risklocation.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risklocation.FieldCreatedAt:
		return m.CreatedAt()
	case risklocation.FieldCreatedBy:
		return m.CreatedBy()
	case risklocation.FieldDeletedAt:
		return m.DeletedAt()
	case risklocation.FieldUpdatedBy:
		return m.UpdatedBy()
	case risklocation.FieldUpdatedAt:
		return m.UpdatedAt()
	case risklocation.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risklocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case risklocation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case risklocation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case risklocation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case risklocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case risklocation.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RiskLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risklocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case risklocation.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case risklocation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case risklocation.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case risklocation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case risklocation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskLocationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiskLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risklocation.FieldDeletedAt) {
		fields = append(fields, risklocation.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskLocationMutation) ClearField(name string) error {
	switch name {
	case risklocation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskLocationMutation) ResetField(name string) error {
	switch name {
	case risklocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case risklocation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case risklocation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case risklocation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case risklocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case risklocation.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, risklocation.EdgeUpdater)
	}
	if m.risk != nil {
		edges = append(edges, risklocation.EdgeRisk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risklocation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case risklocation.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.risk))
		for id := range m.risk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrisk != nil {
		edges = append(edges, risklocation.EdgeRisk)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskLocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.removedrisk))
		for id := range m.removedrisk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, risklocation.EdgeUpdater)
	}
	if m.clearedrisk {
		edges = append(edges, risklocation.EdgeRisk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case risklocation.EdgeCreator:
		return m.clearedcreator
	case risklocation.EdgeUpdater:
		return m.clearedupdater
	case risklocation.EdgeRisk:
		return m.clearedrisk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskLocationMutation) ClearEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ClearCreator()
		return nil
	case risklocation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskLocationMutation) ResetEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ResetCreator()
		return nil
	case risklocation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case risklocation.EdgeRisk:
		m.ResetRisk()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation edge %s", name)
}

// VideoMutation represents an operation that mutates the Video nodes in the graph.
type VideoMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	created_at                    *time.Time
	deleted_at                    *time.Time
	updated_at                    *time.Time
	name                          *string
	url                           *string
	size                          *int64
	addsize                       *int64
	duration                      *string
	uploaded_at                   *time.Time
	clearedFields                 map[string]struct{}
	creator                       *int
	clearedcreator                bool
	updater                       *int
	clearedupdater                bool
	ipc_report_event_video        map[int]struct{}
	removedipc_report_event_video map[int]struct{}
	clearedipc_report_event_video bool
	done                          bool
	oldValue                      func(context.Context) (*Video, error)
	predicates                    []predicate.Video
}

var _ ent.Mutation = (*VideoMutation)(nil)

// videoOption allows management of the mutation configuration using functional options.
type videoOption func(*VideoMutation)

// newVideoMutation creates new mutation for the Video entity.
func newVideoMutation(c config, op Op, opts ...videoOption) *VideoMutation {
	m := &VideoMutation{
		config:        c,
		op:            op,
		typ:           TypeVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoID sets the ID field of the mutation.
func withVideoID(id int) videoOption {
	return func(m *VideoMutation) {
		var (
			err   error
			once  sync.Once
			value *Video
		)
		m.oldValue = func(ctx context.Context) (*Video, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Video.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideo sets the old Video of the mutation.
func withVideo(node *Video) videoOption {
	return func(m *VideoMutation) {
		m.oldValue = func(context.Context) (*Video, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Video.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VideoMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VideoMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VideoMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VideoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VideoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VideoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[video.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VideoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[video.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VideoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, video.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VideoMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VideoMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VideoMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VideoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VideoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *VideoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VideoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VideoMutation) ClearName() {
	m.name = nil
	m.clearedFields[video.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VideoMutation) NameCleared() bool {
	_, ok := m.clearedFields[video.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VideoMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, video.FieldName)
}

// SetURL sets the "url" field.
func (m *VideoMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *VideoMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *VideoMutation) ClearURL() {
	m.url = nil
	m.clearedFields[video.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *VideoMutation) URLCleared() bool {
	_, ok := m.clearedFields[video.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *VideoMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, video.FieldURL)
}

// SetSize sets the "size" field.
func (m *VideoMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VideoMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VideoMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VideoMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VideoMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDuration sets the "duration" field.
func (m *VideoMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VideoMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *VideoMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[video.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *VideoMutation) DurationCleared() bool {
	_, ok := m.clearedFields[video.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *VideoMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, video.FieldDuration)
}

// SetUploadedAt sets the "uploaded_at" field.
func (m *VideoMutation) SetUploadedAt(t time.Time) {
	m.uploaded_at = &t
}

// UploadedAt returns the value of the "uploaded_at" field in the mutation.
func (m *VideoMutation) UploadedAt() (r time.Time, exists bool) {
	v := m.uploaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedAt returns the old "uploaded_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUploadedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedAt: %w", err)
	}
	return oldValue.UploadedAt, nil
}

// ClearUploadedAt clears the value of the "uploaded_at" field.
func (m *VideoMutation) ClearUploadedAt() {
	m.uploaded_at = nil
	m.clearedFields[video.FieldUploadedAt] = struct{}{}
}

// UploadedAtCleared returns if the "uploaded_at" field was cleared in this mutation.
func (m *VideoMutation) UploadedAtCleared() bool {
	_, ok := m.clearedFields[video.FieldUploadedAt]
	return ok
}

// ResetUploadedAt resets all changes to the "uploaded_at" field.
func (m *VideoMutation) ResetUploadedAt() {
	m.uploaded_at = nil
	delete(m.clearedFields, video.FieldUploadedAt)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *VideoMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *VideoMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[video.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *VideoMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *VideoMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *VideoMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *VideoMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *VideoMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[video.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *VideoMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *VideoMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *VideoMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddIpcReportEventVideoIDs adds the "ipc_report_event_video" edge to the IPCReportEvent entity by ids.
func (m *VideoMutation) AddIpcReportEventVideoIDs(ids ...int) {
	if m.ipc_report_event_video == nil {
		m.ipc_report_event_video = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_report_event_video[ids[i]] = struct{}{}
	}
}

// ClearIpcReportEventVideo clears the "ipc_report_event_video" edge to the IPCReportEvent entity.
func (m *VideoMutation) ClearIpcReportEventVideo() {
	m.clearedipc_report_event_video = true
}

// IpcReportEventVideoCleared reports if the "ipc_report_event_video" edge to the IPCReportEvent entity was cleared.
func (m *VideoMutation) IpcReportEventVideoCleared() bool {
	return m.clearedipc_report_event_video
}

// RemoveIpcReportEventVideoIDs removes the "ipc_report_event_video" edge to the IPCReportEvent entity by IDs.
func (m *VideoMutation) RemoveIpcReportEventVideoIDs(ids ...int) {
	if m.removedipc_report_event_video == nil {
		m.removedipc_report_event_video = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_report_event_video, ids[i])
		m.removedipc_report_event_video[ids[i]] = struct{}{}
	}
}

// RemovedIpcReportEventVideo returns the removed IDs of the "ipc_report_event_video" edge to the IPCReportEvent entity.
func (m *VideoMutation) RemovedIpcReportEventVideoIDs() (ids []int) {
	for id := range m.removedipc_report_event_video {
		ids = append(ids, id)
	}
	return
}

// IpcReportEventVideoIDs returns the "ipc_report_event_video" edge IDs in the mutation.
func (m *VideoMutation) IpcReportEventVideoIDs() (ids []int) {
	for id := range m.ipc_report_event_video {
		ids = append(ids, id)
	}
	return
}

// ResetIpcReportEventVideo resets all changes to the "ipc_report_event_video" edge.
func (m *VideoMutation) ResetIpcReportEventVideo() {
	m.ipc_report_event_video = nil
	m.clearedipc_report_event_video = false
	m.removedipc_report_event_video = nil
}

// Where appends a list predicates to the VideoMutation builder.
func (m *VideoMutation) Where(ps ...predicate.Video) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Video, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Video).
func (m *VideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, video.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, video.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, video.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, video.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, video.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, video.FieldName)
	}
	if m.url != nil {
		fields = append(fields, video.FieldURL)
	}
	if m.size != nil {
		fields = append(fields, video.FieldSize)
	}
	if m.duration != nil {
		fields = append(fields, video.FieldDuration)
	}
	if m.uploaded_at != nil {
		fields = append(fields, video.FieldUploadedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case video.FieldCreatedAt:
		return m.CreatedAt()
	case video.FieldCreatedBy:
		return m.CreatedBy()
	case video.FieldDeletedAt:
		return m.DeletedAt()
	case video.FieldUpdatedBy:
		return m.UpdatedBy()
	case video.FieldUpdatedAt:
		return m.UpdatedAt()
	case video.FieldName:
		return m.Name()
	case video.FieldURL:
		return m.URL()
	case video.FieldSize:
		return m.Size()
	case video.FieldDuration:
		return m.Duration()
	case video.FieldUploadedAt:
		return m.UploadedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case video.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case video.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case video.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case video.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case video.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case video.FieldName:
		return m.OldName(ctx)
	case video.FieldURL:
		return m.OldURL(ctx)
	case video.FieldSize:
		return m.OldSize(ctx)
	case video.FieldDuration:
		return m.OldDuration(ctx)
	case video.FieldUploadedAt:
		return m.OldUploadedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Video field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case video.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case video.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case video.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case video.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case video.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case video.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case video.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case video.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case video.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case video.FieldUploadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, video.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case video.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case video.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Video numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(video.FieldDeletedAt) {
		fields = append(fields, video.FieldDeletedAt)
	}
	if m.FieldCleared(video.FieldName) {
		fields = append(fields, video.FieldName)
	}
	if m.FieldCleared(video.FieldURL) {
		fields = append(fields, video.FieldURL)
	}
	if m.FieldCleared(video.FieldDuration) {
		fields = append(fields, video.FieldDuration)
	}
	if m.FieldCleared(video.FieldUploadedAt) {
		fields = append(fields, video.FieldUploadedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMutation) ClearField(name string) error {
	switch name {
	case video.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case video.FieldName:
		m.ClearName()
		return nil
	case video.FieldURL:
		m.ClearURL()
		return nil
	case video.FieldDuration:
		m.ClearDuration()
		return nil
	case video.FieldUploadedAt:
		m.ClearUploadedAt()
		return nil
	}
	return fmt.Errorf("unknown Video nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMutation) ResetField(name string) error {
	switch name {
	case video.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case video.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case video.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case video.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case video.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case video.FieldName:
		m.ResetName()
		return nil
	case video.FieldURL:
		m.ResetURL()
		return nil
	case video.FieldSize:
		m.ResetSize()
		return nil
	case video.FieldDuration:
		m.ResetDuration()
		return nil
	case video.FieldUploadedAt:
		m.ResetUploadedAt()
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, video.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, video.EdgeUpdater)
	}
	if m.ipc_report_event_video != nil {
		edges = append(edges, video.EdgeIpcReportEventVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeIpcReportEventVideo:
		ids := make([]ent.Value, 0, len(m.ipc_report_event_video))
		for id := range m.ipc_report_event_video {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedipc_report_event_video != nil {
		edges = append(edges, video.EdgeIpcReportEventVideo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeIpcReportEventVideo:
		ids := make([]ent.Value, 0, len(m.removedipc_report_event_video))
		for id := range m.removedipc_report_event_video {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, video.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, video.EdgeUpdater)
	}
	if m.clearedipc_report_event_video {
		edges = append(edges, video.EdgeIpcReportEventVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMutation) EdgeCleared(name string) bool {
	switch name {
	case video.EdgeCreator:
		return m.clearedcreator
	case video.EdgeUpdater:
		return m.clearedupdater
	case video.EdgeIpcReportEventVideo:
		return m.clearedipc_report_event_video
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMutation) ClearEdge(name string) error {
	switch name {
	case video.EdgeCreator:
		m.ClearCreator()
		return nil
	case video.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Video unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMutation) ResetEdge(name string) error {
	switch name {
	case video.EdgeCreator:
		m.ResetCreator()
		return nil
	case video.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case video.EdgeIpcReportEventVideo:
		m.ResetIpcReportEventVideo()
		return nil
	}
	return fmt.Errorf("unknown Video edge %s", name)
}
