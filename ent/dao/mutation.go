// Code generated by ent, DO NOT EDIT.

package dao

import (
	"aisecurity/ent/dao/admin"
	"aisecurity/ent/dao/adminrole"
	"aisecurity/ent/dao/department"
	"aisecurity/ent/dao/employee"
	"aisecurity/ent/dao/predicate"
	"aisecurity/ent/dao/risk"
	"aisecurity/ent/dao/riskcategory"
	"aisecurity/ent/dao/risklocation"
	"aisecurity/properties"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin        = "Admin"
	TypeAdminRole    = "AdminRole"
	TypeDepartment   = "Department"
	TypeEmployee     = "Employee"
	TypeRisk         = "Risk"
	TypeRiskCategory = "RiskCategory"
	TypeRiskLocation = "RiskLocation"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	created_at                   *time.Time
	deleted_at                   *time.Time
	updated_at                   *time.Time
	username                     *string
	password                     *string
	name                         *string
	clearedFields                map[string]struct{}
	creator                      *int
	clearedcreator               bool
	updator                      *int
	clearedupdator               bool
	admin_roles                  map[int]struct{}
	removedadmin_roles           map[int]struct{}
	clearedadmin_roles           bool
	admin_creator                map[int]struct{}
	removedadmin_creator         map[int]struct{}
	clearedadmin_creator         bool
	admin_updator                map[int]struct{}
	removedadmin_updator         map[int]struct{}
	clearedadmin_updator         bool
	admin_role_creator           map[int]struct{}
	removedadmin_role_creator    map[int]struct{}
	clearedadmin_role_creator    bool
	admin_role_updator           map[int]struct{}
	removedadmin_role_updator    map[int]struct{}
	clearedadmin_role_updator    bool
	risk_creator                 map[int]struct{}
	removedrisk_creator          map[int]struct{}
	clearedrisk_creator          bool
	risk_updator                 map[int]struct{}
	removedrisk_updator          map[int]struct{}
	clearedrisk_updator          bool
	risk_maintainer              map[int]struct{}
	removedrisk_maintainer       map[int]struct{}
	clearedrisk_maintainer       bool
	risk_location_creator        map[int]struct{}
	removedrisk_location_creator map[int]struct{}
	clearedrisk_location_creator bool
	risk_location_updator        map[int]struct{}
	removedrisk_location_updator map[int]struct{}
	clearedrisk_location_updator bool
	risk_category_creator        map[int]struct{}
	removedrisk_category_creator map[int]struct{}
	clearedrisk_category_creator bool
	risk_category_updator        map[int]struct{}
	removedrisk_category_updator map[int]struct{}
	clearedrisk_category_updator bool
	department_creator           map[int]struct{}
	removeddepartment_creator    map[int]struct{}
	cleareddepartment_creator    bool
	department_updator           map[int]struct{}
	removeddepartment_updator    map[int]struct{}
	cleareddepartment_updator    bool
	employee_creator             map[int]struct{}
	removedemployee_creator      map[int]struct{}
	clearedemployee_creator      bool
	employee_updator             map[int]struct{}
	removedemployee_updator      map[int]struct{}
	clearedemployee_updator      bool
	employee_admin               map[int]struct{}
	removedemployee_admin        map[int]struct{}
	clearedemployee_admin        bool
	done                         bool
	oldValue                     func(context.Context) (*Admin, error)
	predicates                   []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AdminMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AdminMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AdminMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[admin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, admin.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AdminMutation) SetUpdatedBy(i int) {
	m.updator = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AdminMutation) UpdatedBy() (r int, exists bool) {
	v := m.updator
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AdminMutation) ResetUpdatedBy() {
	m.updator = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *AdminMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdminMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AdminMutation) ClearName() {
	m.name = nil
	m.clearedFields[admin.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AdminMutation) NameCleared() bool {
	_, ok := m.clearedFields[admin.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AdminMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, admin.FieldName)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *AdminMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AdminMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[admin.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AdminMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *AdminMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AdminMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdatorID sets the "updator" edge to the Admin entity by id.
func (m *AdminMutation) SetUpdatorID(id int) {
	m.updator = &id
}

// ClearUpdator clears the "updator" edge to the Admin entity.
func (m *AdminMutation) ClearUpdator() {
	m.clearedupdator = true
	m.clearedFields[admin.FieldUpdatedBy] = struct{}{}
}

// UpdatorCleared reports if the "updator" edge to the Admin entity was cleared.
func (m *AdminMutation) UpdatorCleared() bool {
	return m.clearedupdator
}

// UpdatorID returns the "updator" edge ID in the mutation.
func (m *AdminMutation) UpdatorID() (id int, exists bool) {
	if m.updator != nil {
		return *m.updator, true
	}
	return
}

// UpdatorIDs returns the "updator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatorID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) UpdatorIDs() (ids []int) {
	if id := m.updator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdator resets all changes to the "updator" edge.
func (m *AdminMutation) ResetUpdator() {
	m.updator = nil
	m.clearedupdator = false
}

// AddAdminRoleIDs adds the "admin_roles" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleIDs(ids ...int) {
	if m.admin_roles == nil {
		m.admin_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_roles[ids[i]] = struct{}{}
	}
}

// ClearAdminRoles clears the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoles() {
	m.clearedadmin_roles = true
}

// AdminRolesCleared reports if the "admin_roles" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRolesCleared() bool {
	return m.clearedadmin_roles
}

// RemoveAdminRoleIDs removes the "admin_roles" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleIDs(ids ...int) {
	if m.removedadmin_roles == nil {
		m.removedadmin_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_roles, ids[i])
		m.removedadmin_roles[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoles returns the removed IDs of the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRolesIDs() (ids []int) {
	for id := range m.removedadmin_roles {
		ids = append(ids, id)
	}
	return
}

// AdminRolesIDs returns the "admin_roles" edge IDs in the mutation.
func (m *AdminMutation) AdminRolesIDs() (ids []int) {
	for id := range m.admin_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoles resets all changes to the "admin_roles" edge.
func (m *AdminMutation) ResetAdminRoles() {
	m.admin_roles = nil
	m.clearedadmin_roles = false
	m.removedadmin_roles = nil
}

// AddAdminCreatorIDs adds the "admin_creator" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminCreatorIDs(ids ...int) {
	if m.admin_creator == nil {
		m.admin_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_creator[ids[i]] = struct{}{}
	}
}

// ClearAdminCreator clears the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) ClearAdminCreator() {
	m.clearedadmin_creator = true
}

// AdminCreatorCleared reports if the "admin_creator" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminCreatorCleared() bool {
	return m.clearedadmin_creator
}

// RemoveAdminCreatorIDs removes the "admin_creator" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminCreatorIDs(ids ...int) {
	if m.removedadmin_creator == nil {
		m.removedadmin_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_creator, ids[i])
		m.removedadmin_creator[ids[i]] = struct{}{}
	}
}

// RemovedAdminCreator returns the removed IDs of the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminCreatorIDs() (ids []int) {
	for id := range m.removedadmin_creator {
		ids = append(ids, id)
	}
	return
}

// AdminCreatorIDs returns the "admin_creator" edge IDs in the mutation.
func (m *AdminMutation) AdminCreatorIDs() (ids []int) {
	for id := range m.admin_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminCreator resets all changes to the "admin_creator" edge.
func (m *AdminMutation) ResetAdminCreator() {
	m.admin_creator = nil
	m.clearedadmin_creator = false
	m.removedadmin_creator = nil
}

// AddAdminUpdatorIDs adds the "admin_updator" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminUpdatorIDs(ids ...int) {
	if m.admin_updator == nil {
		m.admin_updator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_updator[ids[i]] = struct{}{}
	}
}

// ClearAdminUpdator clears the "admin_updator" edge to the Admin entity.
func (m *AdminMutation) ClearAdminUpdator() {
	m.clearedadmin_updator = true
}

// AdminUpdatorCleared reports if the "admin_updator" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminUpdatorCleared() bool {
	return m.clearedadmin_updator
}

// RemoveAdminUpdatorIDs removes the "admin_updator" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminUpdatorIDs(ids ...int) {
	if m.removedadmin_updator == nil {
		m.removedadmin_updator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_updator, ids[i])
		m.removedadmin_updator[ids[i]] = struct{}{}
	}
}

// RemovedAdminUpdator returns the removed IDs of the "admin_updator" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminUpdatorIDs() (ids []int) {
	for id := range m.removedadmin_updator {
		ids = append(ids, id)
	}
	return
}

// AdminUpdatorIDs returns the "admin_updator" edge IDs in the mutation.
func (m *AdminMutation) AdminUpdatorIDs() (ids []int) {
	for id := range m.admin_updator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminUpdator resets all changes to the "admin_updator" edge.
func (m *AdminMutation) ResetAdminUpdator() {
	m.admin_updator = nil
	m.clearedadmin_updator = false
	m.removedadmin_updator = nil
}

// AddAdminRoleCreatorIDs adds the "admin_role_creator" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleCreatorIDs(ids ...int) {
	if m.admin_role_creator == nil {
		m.admin_role_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_role_creator[ids[i]] = struct{}{}
	}
}

// ClearAdminRoleCreator clears the "admin_role_creator" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoleCreator() {
	m.clearedadmin_role_creator = true
}

// AdminRoleCreatorCleared reports if the "admin_role_creator" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRoleCreatorCleared() bool {
	return m.clearedadmin_role_creator
}

// RemoveAdminRoleCreatorIDs removes the "admin_role_creator" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleCreatorIDs(ids ...int) {
	if m.removedadmin_role_creator == nil {
		m.removedadmin_role_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_role_creator, ids[i])
		m.removedadmin_role_creator[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoleCreator returns the removed IDs of the "admin_role_creator" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRoleCreatorIDs() (ids []int) {
	for id := range m.removedadmin_role_creator {
		ids = append(ids, id)
	}
	return
}

// AdminRoleCreatorIDs returns the "admin_role_creator" edge IDs in the mutation.
func (m *AdminMutation) AdminRoleCreatorIDs() (ids []int) {
	for id := range m.admin_role_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoleCreator resets all changes to the "admin_role_creator" edge.
func (m *AdminMutation) ResetAdminRoleCreator() {
	m.admin_role_creator = nil
	m.clearedadmin_role_creator = false
	m.removedadmin_role_creator = nil
}

// AddAdminRoleUpdatorIDs adds the "admin_role_updator" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleUpdatorIDs(ids ...int) {
	if m.admin_role_updator == nil {
		m.admin_role_updator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_role_updator[ids[i]] = struct{}{}
	}
}

// ClearAdminRoleUpdator clears the "admin_role_updator" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoleUpdator() {
	m.clearedadmin_role_updator = true
}

// AdminRoleUpdatorCleared reports if the "admin_role_updator" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRoleUpdatorCleared() bool {
	return m.clearedadmin_role_updator
}

// RemoveAdminRoleUpdatorIDs removes the "admin_role_updator" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleUpdatorIDs(ids ...int) {
	if m.removedadmin_role_updator == nil {
		m.removedadmin_role_updator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_role_updator, ids[i])
		m.removedadmin_role_updator[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoleUpdator returns the removed IDs of the "admin_role_updator" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRoleUpdatorIDs() (ids []int) {
	for id := range m.removedadmin_role_updator {
		ids = append(ids, id)
	}
	return
}

// AdminRoleUpdatorIDs returns the "admin_role_updator" edge IDs in the mutation.
func (m *AdminMutation) AdminRoleUpdatorIDs() (ids []int) {
	for id := range m.admin_role_updator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoleUpdator resets all changes to the "admin_role_updator" edge.
func (m *AdminMutation) ResetAdminRoleUpdator() {
	m.admin_role_updator = nil
	m.clearedadmin_role_updator = false
	m.removedadmin_role_updator = nil
}

// AddRiskCreatorIDs adds the "risk_creator" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskCreatorIDs(ids ...int) {
	if m.risk_creator == nil {
		m.risk_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCreator clears the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) ClearRiskCreator() {
	m.clearedrisk_creator = true
}

// RiskCreatorCleared reports if the "risk_creator" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskCreatorCleared() bool {
	return m.clearedrisk_creator
}

// RemoveRiskCreatorIDs removes the "risk_creator" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskCreatorIDs(ids ...int) {
	if m.removedrisk_creator == nil {
		m.removedrisk_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_creator, ids[i])
		m.removedrisk_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCreator returns the removed IDs of the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskCreatorIDs() (ids []int) {
	for id := range m.removedrisk_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCreatorIDs returns the "risk_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCreatorIDs() (ids []int) {
	for id := range m.risk_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCreator resets all changes to the "risk_creator" edge.
func (m *AdminMutation) ResetRiskCreator() {
	m.risk_creator = nil
	m.clearedrisk_creator = false
	m.removedrisk_creator = nil
}

// AddRiskUpdatorIDs adds the "risk_updator" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskUpdatorIDs(ids ...int) {
	if m.risk_updator == nil {
		m.risk_updator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_updator[ids[i]] = struct{}{}
	}
}

// ClearRiskUpdator clears the "risk_updator" edge to the Risk entity.
func (m *AdminMutation) ClearRiskUpdator() {
	m.clearedrisk_updator = true
}

// RiskUpdatorCleared reports if the "risk_updator" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskUpdatorCleared() bool {
	return m.clearedrisk_updator
}

// RemoveRiskUpdatorIDs removes the "risk_updator" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskUpdatorIDs(ids ...int) {
	if m.removedrisk_updator == nil {
		m.removedrisk_updator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_updator, ids[i])
		m.removedrisk_updator[ids[i]] = struct{}{}
	}
}

// RemovedRiskUpdator returns the removed IDs of the "risk_updator" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskUpdatorIDs() (ids []int) {
	for id := range m.removedrisk_updator {
		ids = append(ids, id)
	}
	return
}

// RiskUpdatorIDs returns the "risk_updator" edge IDs in the mutation.
func (m *AdminMutation) RiskUpdatorIDs() (ids []int) {
	for id := range m.risk_updator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskUpdator resets all changes to the "risk_updator" edge.
func (m *AdminMutation) ResetRiskUpdator() {
	m.risk_updator = nil
	m.clearedrisk_updator = false
	m.removedrisk_updator = nil
}

// AddRiskMaintainerIDs adds the "risk_maintainer" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskMaintainerIDs(ids ...int) {
	if m.risk_maintainer == nil {
		m.risk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_maintainer[ids[i]] = struct{}{}
	}
}

// ClearRiskMaintainer clears the "risk_maintainer" edge to the Risk entity.
func (m *AdminMutation) ClearRiskMaintainer() {
	m.clearedrisk_maintainer = true
}

// RiskMaintainerCleared reports if the "risk_maintainer" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskMaintainerCleared() bool {
	return m.clearedrisk_maintainer
}

// RemoveRiskMaintainerIDs removes the "risk_maintainer" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskMaintainerIDs(ids ...int) {
	if m.removedrisk_maintainer == nil {
		m.removedrisk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_maintainer, ids[i])
		m.removedrisk_maintainer[ids[i]] = struct{}{}
	}
}

// RemovedRiskMaintainer returns the removed IDs of the "risk_maintainer" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskMaintainerIDs() (ids []int) {
	for id := range m.removedrisk_maintainer {
		ids = append(ids, id)
	}
	return
}

// RiskMaintainerIDs returns the "risk_maintainer" edge IDs in the mutation.
func (m *AdminMutation) RiskMaintainerIDs() (ids []int) {
	for id := range m.risk_maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetRiskMaintainer resets all changes to the "risk_maintainer" edge.
func (m *AdminMutation) ResetRiskMaintainer() {
	m.risk_maintainer = nil
	m.clearedrisk_maintainer = false
	m.removedrisk_maintainer = nil
}

// AddRiskLocationCreatorIDs adds the "risk_location_creator" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationCreatorIDs(ids ...int) {
	if m.risk_location_creator == nil {
		m.risk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationCreator clears the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationCreator() {
	m.clearedrisk_location_creator = true
}

// RiskLocationCreatorCleared reports if the "risk_location_creator" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationCreatorCleared() bool {
	return m.clearedrisk_location_creator
}

// RemoveRiskLocationCreatorIDs removes the "risk_location_creator" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationCreatorIDs(ids ...int) {
	if m.removedrisk_location_creator == nil {
		m.removedrisk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_creator, ids[i])
		m.removedrisk_location_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationCreator returns the removed IDs of the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationCreatorIDs() (ids []int) {
	for id := range m.removedrisk_location_creator {
		ids = append(ids, id)
	}
	return
}

// RiskLocationCreatorIDs returns the "risk_location_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationCreatorIDs() (ids []int) {
	for id := range m.risk_location_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationCreator resets all changes to the "risk_location_creator" edge.
func (m *AdminMutation) ResetRiskLocationCreator() {
	m.risk_location_creator = nil
	m.clearedrisk_location_creator = false
	m.removedrisk_location_creator = nil
}

// AddRiskLocationUpdatorIDs adds the "risk_location_updator" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationUpdatorIDs(ids ...int) {
	if m.risk_location_updator == nil {
		m.risk_location_updator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_updator[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationUpdator clears the "risk_location_updator" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationUpdator() {
	m.clearedrisk_location_updator = true
}

// RiskLocationUpdatorCleared reports if the "risk_location_updator" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationUpdatorCleared() bool {
	return m.clearedrisk_location_updator
}

// RemoveRiskLocationUpdatorIDs removes the "risk_location_updator" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationUpdatorIDs(ids ...int) {
	if m.removedrisk_location_updator == nil {
		m.removedrisk_location_updator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_updator, ids[i])
		m.removedrisk_location_updator[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationUpdator returns the removed IDs of the "risk_location_updator" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationUpdatorIDs() (ids []int) {
	for id := range m.removedrisk_location_updator {
		ids = append(ids, id)
	}
	return
}

// RiskLocationUpdatorIDs returns the "risk_location_updator" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationUpdatorIDs() (ids []int) {
	for id := range m.risk_location_updator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationUpdator resets all changes to the "risk_location_updator" edge.
func (m *AdminMutation) ResetRiskLocationUpdator() {
	m.risk_location_updator = nil
	m.clearedrisk_location_updator = false
	m.removedrisk_location_updator = nil
}

// AddRiskCategoryCreatorIDs adds the "risk_category_creator" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryCreatorIDs(ids ...int) {
	if m.risk_category_creator == nil {
		m.risk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryCreator clears the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryCreator() {
	m.clearedrisk_category_creator = true
}

// RiskCategoryCreatorCleared reports if the "risk_category_creator" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryCreatorCleared() bool {
	return m.clearedrisk_category_creator
}

// RemoveRiskCategoryCreatorIDs removes the "risk_category_creator" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryCreatorIDs(ids ...int) {
	if m.removedrisk_category_creator == nil {
		m.removedrisk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_creator, ids[i])
		m.removedrisk_category_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryCreator returns the removed IDs of the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryCreatorIDs() (ids []int) {
	for id := range m.removedrisk_category_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryCreatorIDs returns the "risk_category_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryCreatorIDs() (ids []int) {
	for id := range m.risk_category_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryCreator resets all changes to the "risk_category_creator" edge.
func (m *AdminMutation) ResetRiskCategoryCreator() {
	m.risk_category_creator = nil
	m.clearedrisk_category_creator = false
	m.removedrisk_category_creator = nil
}

// AddRiskCategoryUpdatorIDs adds the "risk_category_updator" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryUpdatorIDs(ids ...int) {
	if m.risk_category_updator == nil {
		m.risk_category_updator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_updator[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryUpdator clears the "risk_category_updator" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryUpdator() {
	m.clearedrisk_category_updator = true
}

// RiskCategoryUpdatorCleared reports if the "risk_category_updator" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryUpdatorCleared() bool {
	return m.clearedrisk_category_updator
}

// RemoveRiskCategoryUpdatorIDs removes the "risk_category_updator" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryUpdatorIDs(ids ...int) {
	if m.removedrisk_category_updator == nil {
		m.removedrisk_category_updator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_updator, ids[i])
		m.removedrisk_category_updator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryUpdator returns the removed IDs of the "risk_category_updator" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryUpdatorIDs() (ids []int) {
	for id := range m.removedrisk_category_updator {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryUpdatorIDs returns the "risk_category_updator" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryUpdatorIDs() (ids []int) {
	for id := range m.risk_category_updator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryUpdator resets all changes to the "risk_category_updator" edge.
func (m *AdminMutation) ResetRiskCategoryUpdator() {
	m.risk_category_updator = nil
	m.clearedrisk_category_updator = false
	m.removedrisk_category_updator = nil
}

// AddDepartmentCreatorIDs adds the "department_creator" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentCreatorIDs(ids ...int) {
	if m.department_creator == nil {
		m.department_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.department_creator[ids[i]] = struct{}{}
	}
}

// ClearDepartmentCreator clears the "department_creator" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentCreator() {
	m.cleareddepartment_creator = true
}

// DepartmentCreatorCleared reports if the "department_creator" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentCreatorCleared() bool {
	return m.cleareddepartment_creator
}

// RemoveDepartmentCreatorIDs removes the "department_creator" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentCreatorIDs(ids ...int) {
	if m.removeddepartment_creator == nil {
		m.removeddepartment_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_creator, ids[i])
		m.removeddepartment_creator[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentCreator returns the removed IDs of the "department_creator" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentCreatorIDs() (ids []int) {
	for id := range m.removeddepartment_creator {
		ids = append(ids, id)
	}
	return
}

// DepartmentCreatorIDs returns the "department_creator" edge IDs in the mutation.
func (m *AdminMutation) DepartmentCreatorIDs() (ids []int) {
	for id := range m.department_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentCreator resets all changes to the "department_creator" edge.
func (m *AdminMutation) ResetDepartmentCreator() {
	m.department_creator = nil
	m.cleareddepartment_creator = false
	m.removeddepartment_creator = nil
}

// AddDepartmentUpdatorIDs adds the "department_updator" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentUpdatorIDs(ids ...int) {
	if m.department_updator == nil {
		m.department_updator = make(map[int]struct{})
	}
	for i := range ids {
		m.department_updator[ids[i]] = struct{}{}
	}
}

// ClearDepartmentUpdator clears the "department_updator" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentUpdator() {
	m.cleareddepartment_updator = true
}

// DepartmentUpdatorCleared reports if the "department_updator" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentUpdatorCleared() bool {
	return m.cleareddepartment_updator
}

// RemoveDepartmentUpdatorIDs removes the "department_updator" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentUpdatorIDs(ids ...int) {
	if m.removeddepartment_updator == nil {
		m.removeddepartment_updator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_updator, ids[i])
		m.removeddepartment_updator[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentUpdator returns the removed IDs of the "department_updator" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentUpdatorIDs() (ids []int) {
	for id := range m.removeddepartment_updator {
		ids = append(ids, id)
	}
	return
}

// DepartmentUpdatorIDs returns the "department_updator" edge IDs in the mutation.
func (m *AdminMutation) DepartmentUpdatorIDs() (ids []int) {
	for id := range m.department_updator {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentUpdator resets all changes to the "department_updator" edge.
func (m *AdminMutation) ResetDepartmentUpdator() {
	m.department_updator = nil
	m.cleareddepartment_updator = false
	m.removeddepartment_updator = nil
}

// AddEmployeeCreatorIDs adds the "employee_creator" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeCreatorIDs(ids ...int) {
	if m.employee_creator == nil {
		m.employee_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_creator[ids[i]] = struct{}{}
	}
}

// ClearEmployeeCreator clears the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeCreator() {
	m.clearedemployee_creator = true
}

// EmployeeCreatorCleared reports if the "employee_creator" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeCreatorCleared() bool {
	return m.clearedemployee_creator
}

// RemoveEmployeeCreatorIDs removes the "employee_creator" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeCreatorIDs(ids ...int) {
	if m.removedemployee_creator == nil {
		m.removedemployee_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_creator, ids[i])
		m.removedemployee_creator[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeCreator returns the removed IDs of the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeCreatorIDs() (ids []int) {
	for id := range m.removedemployee_creator {
		ids = append(ids, id)
	}
	return
}

// EmployeeCreatorIDs returns the "employee_creator" edge IDs in the mutation.
func (m *AdminMutation) EmployeeCreatorIDs() (ids []int) {
	for id := range m.employee_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeCreator resets all changes to the "employee_creator" edge.
func (m *AdminMutation) ResetEmployeeCreator() {
	m.employee_creator = nil
	m.clearedemployee_creator = false
	m.removedemployee_creator = nil
}

// AddEmployeeUpdatorIDs adds the "employee_updator" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeUpdatorIDs(ids ...int) {
	if m.employee_updator == nil {
		m.employee_updator = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_updator[ids[i]] = struct{}{}
	}
}

// ClearEmployeeUpdator clears the "employee_updator" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeUpdator() {
	m.clearedemployee_updator = true
}

// EmployeeUpdatorCleared reports if the "employee_updator" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeUpdatorCleared() bool {
	return m.clearedemployee_updator
}

// RemoveEmployeeUpdatorIDs removes the "employee_updator" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeUpdatorIDs(ids ...int) {
	if m.removedemployee_updator == nil {
		m.removedemployee_updator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_updator, ids[i])
		m.removedemployee_updator[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeUpdator returns the removed IDs of the "employee_updator" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeUpdatorIDs() (ids []int) {
	for id := range m.removedemployee_updator {
		ids = append(ids, id)
	}
	return
}

// EmployeeUpdatorIDs returns the "employee_updator" edge IDs in the mutation.
func (m *AdminMutation) EmployeeUpdatorIDs() (ids []int) {
	for id := range m.employee_updator {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeUpdator resets all changes to the "employee_updator" edge.
func (m *AdminMutation) ResetEmployeeUpdator() {
	m.employee_updator = nil
	m.clearedemployee_updator = false
	m.removedemployee_updator = nil
}

// AddEmployeeAdminIDs adds the "employee_admin" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeAdminIDs(ids ...int) {
	if m.employee_admin == nil {
		m.employee_admin = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_admin[ids[i]] = struct{}{}
	}
}

// ClearEmployeeAdmin clears the "employee_admin" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeAdmin() {
	m.clearedemployee_admin = true
}

// EmployeeAdminCleared reports if the "employee_admin" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeAdminCleared() bool {
	return m.clearedemployee_admin
}

// RemoveEmployeeAdminIDs removes the "employee_admin" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeAdminIDs(ids ...int) {
	if m.removedemployee_admin == nil {
		m.removedemployee_admin = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_admin, ids[i])
		m.removedemployee_admin[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeAdmin returns the removed IDs of the "employee_admin" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeAdminIDs() (ids []int) {
	for id := range m.removedemployee_admin {
		ids = append(ids, id)
	}
	return
}

// EmployeeAdminIDs returns the "employee_admin" edge IDs in the mutation.
func (m *AdminMutation) EmployeeAdminIDs() (ids []int) {
	for id := range m.employee_admin {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeAdmin resets all changes to the "employee_admin" edge.
func (m *AdminMutation) ResetEmployeeAdmin() {
	m.employee_admin = nil
	m.clearedemployee_admin = false
	m.removedemployee_admin = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, admin.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.updator != nil {
		fields = append(fields, admin.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, admin.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldCreatedBy:
		return m.CreatedBy()
	case admin.FieldDeletedAt:
		return m.DeletedAt()
	case admin.FieldUpdatedBy:
		return m.UpdatedBy()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case admin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case admin.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case admin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case admin.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldDeletedAt) {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.FieldCleared(admin.FieldName) {
		fields = append(fields, admin.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case admin.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case admin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case admin.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 19)
	if m.creator != nil {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.updator != nil {
		edges = append(edges, admin.EdgeUpdator)
	}
	if m.admin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.admin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.admin_updator != nil {
		edges = append(edges, admin.EdgeAdminUpdator)
	}
	if m.admin_role_creator != nil {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.admin_role_updator != nil {
		edges = append(edges, admin.EdgeAdminRoleUpdator)
	}
	if m.risk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.risk_updator != nil {
		edges = append(edges, admin.EdgeRiskUpdator)
	}
	if m.risk_maintainer != nil {
		edges = append(edges, admin.EdgeRiskMaintainer)
	}
	if m.risk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.risk_location_updator != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdator)
	}
	if m.risk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.risk_category_updator != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdator)
	}
	if m.department_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.department_updator != nil {
		edges = append(edges, admin.EdgeDepartmentUpdator)
	}
	if m.employee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.employee_updator != nil {
		edges = append(edges, admin.EdgeEmployeeUpdator)
	}
	if m.employee_admin != nil {
		edges = append(edges, admin.EdgeEmployeeAdmin)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeUpdator:
		if id := m.updator; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.admin_roles))
		for id := range m.admin_roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.admin_creator))
		for id := range m.admin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdator:
		ids := make([]ent.Value, 0, len(m.admin_updator))
		for id := range m.admin_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleCreator:
		ids := make([]ent.Value, 0, len(m.admin_role_creator))
		for id := range m.admin_role_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleUpdator:
		ids := make([]ent.Value, 0, len(m.admin_role_updator))
		for id := range m.admin_role_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.risk_creator))
		for id := range m.risk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdator:
		ids := make([]ent.Value, 0, len(m.risk_updator))
		for id := range m.risk_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.risk_maintainer))
		for id := range m.risk_maintainer {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.risk_location_creator))
		for id := range m.risk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdator:
		ids := make([]ent.Value, 0, len(m.risk_location_updator))
		for id := range m.risk_location_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.risk_category_creator))
		for id := range m.risk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdator:
		ids := make([]ent.Value, 0, len(m.risk_category_updator))
		for id := range m.risk_category_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.department_creator))
		for id := range m.department_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdator:
		ids := make([]ent.Value, 0, len(m.department_updator))
		for id := range m.department_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.employee_creator))
		for id := range m.employee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdator:
		ids := make([]ent.Value, 0, len(m.employee_updator))
		for id := range m.employee_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeAdmin:
		ids := make([]ent.Value, 0, len(m.employee_admin))
		for id := range m.employee_admin {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 19)
	if m.removedadmin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.removedadmin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.removedadmin_updator != nil {
		edges = append(edges, admin.EdgeAdminUpdator)
	}
	if m.removedadmin_role_creator != nil {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.removedadmin_role_updator != nil {
		edges = append(edges, admin.EdgeAdminRoleUpdator)
	}
	if m.removedrisk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.removedrisk_updator != nil {
		edges = append(edges, admin.EdgeRiskUpdator)
	}
	if m.removedrisk_maintainer != nil {
		edges = append(edges, admin.EdgeRiskMaintainer)
	}
	if m.removedrisk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.removedrisk_location_updator != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdator)
	}
	if m.removedrisk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.removedrisk_category_updator != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdator)
	}
	if m.removeddepartment_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.removeddepartment_updator != nil {
		edges = append(edges, admin.EdgeDepartmentUpdator)
	}
	if m.removedemployee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.removedemployee_updator != nil {
		edges = append(edges, admin.EdgeEmployeeUpdator)
	}
	if m.removedemployee_admin != nil {
		edges = append(edges, admin.EdgeEmployeeAdmin)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.removedadmin_roles))
		for id := range m.removedadmin_roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.removedadmin_creator))
		for id := range m.removedadmin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdator:
		ids := make([]ent.Value, 0, len(m.removedadmin_updator))
		for id := range m.removedadmin_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleCreator:
		ids := make([]ent.Value, 0, len(m.removedadmin_role_creator))
		for id := range m.removedadmin_role_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleUpdator:
		ids := make([]ent.Value, 0, len(m.removedadmin_role_updator))
		for id := range m.removedadmin_role_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_creator))
		for id := range m.removedrisk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdator:
		ids := make([]ent.Value, 0, len(m.removedrisk_updator))
		for id := range m.removedrisk_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.removedrisk_maintainer))
		for id := range m.removedrisk_maintainer {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_creator))
		for id := range m.removedrisk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdator:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_updator))
		for id := range m.removedrisk_location_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_creator))
		for id := range m.removedrisk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdator:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_updator))
		for id := range m.removedrisk_category_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.removeddepartment_creator))
		for id := range m.removeddepartment_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdator:
		ids := make([]ent.Value, 0, len(m.removeddepartment_updator))
		for id := range m.removeddepartment_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.removedemployee_creator))
		for id := range m.removedemployee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdator:
		ids := make([]ent.Value, 0, len(m.removedemployee_updator))
		for id := range m.removedemployee_updator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeAdmin:
		ids := make([]ent.Value, 0, len(m.removedemployee_admin))
		for id := range m.removedemployee_admin {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 19)
	if m.clearedcreator {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.clearedupdator {
		edges = append(edges, admin.EdgeUpdator)
	}
	if m.clearedadmin_roles {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.clearedadmin_creator {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.clearedadmin_updator {
		edges = append(edges, admin.EdgeAdminUpdator)
	}
	if m.clearedadmin_role_creator {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.clearedadmin_role_updator {
		edges = append(edges, admin.EdgeAdminRoleUpdator)
	}
	if m.clearedrisk_creator {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.clearedrisk_updator {
		edges = append(edges, admin.EdgeRiskUpdator)
	}
	if m.clearedrisk_maintainer {
		edges = append(edges, admin.EdgeRiskMaintainer)
	}
	if m.clearedrisk_location_creator {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.clearedrisk_location_updator {
		edges = append(edges, admin.EdgeRiskLocationUpdator)
	}
	if m.clearedrisk_category_creator {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.clearedrisk_category_updator {
		edges = append(edges, admin.EdgeRiskCategoryUpdator)
	}
	if m.cleareddepartment_creator {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.cleareddepartment_updator {
		edges = append(edges, admin.EdgeDepartmentUpdator)
	}
	if m.clearedemployee_creator {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.clearedemployee_updator {
		edges = append(edges, admin.EdgeEmployeeUpdator)
	}
	if m.clearedemployee_admin {
		edges = append(edges, admin.EdgeEmployeeAdmin)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeCreator:
		return m.clearedcreator
	case admin.EdgeUpdator:
		return m.clearedupdator
	case admin.EdgeAdminRoles:
		return m.clearedadmin_roles
	case admin.EdgeAdminCreator:
		return m.clearedadmin_creator
	case admin.EdgeAdminUpdator:
		return m.clearedadmin_updator
	case admin.EdgeAdminRoleCreator:
		return m.clearedadmin_role_creator
	case admin.EdgeAdminRoleUpdator:
		return m.clearedadmin_role_updator
	case admin.EdgeRiskCreator:
		return m.clearedrisk_creator
	case admin.EdgeRiskUpdator:
		return m.clearedrisk_updator
	case admin.EdgeRiskMaintainer:
		return m.clearedrisk_maintainer
	case admin.EdgeRiskLocationCreator:
		return m.clearedrisk_location_creator
	case admin.EdgeRiskLocationUpdator:
		return m.clearedrisk_location_updator
	case admin.EdgeRiskCategoryCreator:
		return m.clearedrisk_category_creator
	case admin.EdgeRiskCategoryUpdator:
		return m.clearedrisk_category_updator
	case admin.EdgeDepartmentCreator:
		return m.cleareddepartment_creator
	case admin.EdgeDepartmentUpdator:
		return m.cleareddepartment_updator
	case admin.EdgeEmployeeCreator:
		return m.clearedemployee_creator
	case admin.EdgeEmployeeUpdator:
		return m.clearedemployee_updator
	case admin.EdgeEmployeeAdmin:
		return m.clearedemployee_admin
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ClearCreator()
		return nil
	case admin.EdgeUpdator:
		m.ClearUpdator()
		return nil
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ResetCreator()
		return nil
	case admin.EdgeUpdator:
		m.ResetUpdator()
		return nil
	case admin.EdgeAdminRoles:
		m.ResetAdminRoles()
		return nil
	case admin.EdgeAdminCreator:
		m.ResetAdminCreator()
		return nil
	case admin.EdgeAdminUpdator:
		m.ResetAdminUpdator()
		return nil
	case admin.EdgeAdminRoleCreator:
		m.ResetAdminRoleCreator()
		return nil
	case admin.EdgeAdminRoleUpdator:
		m.ResetAdminRoleUpdator()
		return nil
	case admin.EdgeRiskCreator:
		m.ResetRiskCreator()
		return nil
	case admin.EdgeRiskUpdator:
		m.ResetRiskUpdator()
		return nil
	case admin.EdgeRiskMaintainer:
		m.ResetRiskMaintainer()
		return nil
	case admin.EdgeRiskLocationCreator:
		m.ResetRiskLocationCreator()
		return nil
	case admin.EdgeRiskLocationUpdator:
		m.ResetRiskLocationUpdator()
		return nil
	case admin.EdgeRiskCategoryCreator:
		m.ResetRiskCategoryCreator()
		return nil
	case admin.EdgeRiskCategoryUpdator:
		m.ResetRiskCategoryUpdator()
		return nil
	case admin.EdgeDepartmentCreator:
		m.ResetDepartmentCreator()
		return nil
	case admin.EdgeDepartmentUpdator:
		m.ResetDepartmentUpdator()
		return nil
	case admin.EdgeEmployeeCreator:
		m.ResetEmployeeCreator()
		return nil
	case admin.EdgeEmployeeUpdator:
		m.ResetEmployeeUpdator()
		return nil
	case admin.EdgeEmployeeAdmin:
		m.ResetEmployeeAdmin()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AdminRoleMutation represents an operation that mutates the AdminRole nodes in the graph.
type AdminRoleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	name           *string
	deleted_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updator        *int
	clearedupdator bool
	admins         map[int]struct{}
	removedadmins  map[int]struct{}
	clearedadmins  bool
	done           bool
	oldValue       func(context.Context) (*AdminRole, error)
	predicates     []predicate.AdminRole
}

var _ ent.Mutation = (*AdminRoleMutation)(nil)

// adminroleOption allows management of the mutation configuration using functional options.
type adminroleOption func(*AdminRoleMutation)

// newAdminRoleMutation creates new mutation for the AdminRole entity.
func newAdminRoleMutation(c config, op Op, opts ...adminroleOption) *AdminRoleMutation {
	m := &AdminRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminRoleID sets the ID field of the mutation.
func withAdminRoleID(id int) adminroleOption {
	return func(m *AdminRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminRole
		)
		m.oldValue = func(ctx context.Context) (*AdminRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminRole sets the old AdminRole of the mutation.
func withAdminRole(node *AdminRole) adminroleOption {
	return func(m *AdminRoleMutation) {
		m.oldValue = func(context.Context) (*AdminRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AdminRoleMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AdminRoleMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AdminRoleMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[adminrole.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AdminRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AdminRoleMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, adminrole.FieldCreatedBy)
}

// SetName sets the "name" field.
func (m *AdminRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdminRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdminRoleMutation) ResetName() {
	m.name = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[adminrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, adminrole.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AdminRoleMutation) SetUpdatedBy(i int) {
	m.updator = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AdminRoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updator
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AdminRoleMutation) ClearUpdatedBy() {
	m.updator = nil
	m.clearedFields[adminrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AdminRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AdminRoleMutation) ResetUpdatedBy() {
	m.updator = nil
	delete(m.clearedFields, adminrole.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *AdminRoleMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AdminRoleMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[adminrole.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *AdminRoleMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AdminRoleMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdatorID sets the "updator" edge to the Admin entity by id.
func (m *AdminRoleMutation) SetUpdatorID(id int) {
	m.updator = &id
}

// ClearUpdator clears the "updator" edge to the Admin entity.
func (m *AdminRoleMutation) ClearUpdator() {
	m.clearedupdator = true
	m.clearedFields[adminrole.FieldUpdatedBy] = struct{}{}
}

// UpdatorCleared reports if the "updator" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) UpdatorCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdator
}

// UpdatorID returns the "updator" edge ID in the mutation.
func (m *AdminRoleMutation) UpdatorID() (id int, exists bool) {
	if m.updator != nil {
		return *m.updator, true
	}
	return
}

// UpdatorIDs returns the "updator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatorID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) UpdatorIDs() (ids []int) {
	if id := m.updator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdator resets all changes to the "updator" edge.
func (m *AdminRoleMutation) ResetUpdator() {
	m.updator = nil
	m.clearedupdator = false
}

// AddAdminIDs adds the "admins" edge to the Admin entity by ids.
func (m *AdminRoleMutation) AddAdminIDs(ids ...int) {
	if m.admins == nil {
		m.admins = make(map[int]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// ClearAdmins clears the "admins" edge to the Admin entity.
func (m *AdminRoleMutation) ClearAdmins() {
	m.clearedadmins = true
}

// AdminsCleared reports if the "admins" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) AdminsCleared() bool {
	return m.clearedadmins
}

// RemoveAdminIDs removes the "admins" edge to the Admin entity by IDs.
func (m *AdminRoleMutation) RemoveAdminIDs(ids ...int) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admins, ids[i])
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed IDs of the "admins" edge to the Admin entity.
func (m *AdminRoleMutation) RemovedAdminsIDs() (ids []int) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the "admins" edge IDs in the mutation.
func (m *AdminRoleMutation) AdminsIDs() (ids []int) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins resets all changes to the "admins" edge.
func (m *AdminRoleMutation) ResetAdmins() {
	m.admins = nil
	m.clearedadmins = false
	m.removedadmins = nil
}

// Where appends a list predicates to the AdminRoleMutation builder.
func (m *AdminRoleMutation) Where(ps ...predicate.AdminRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminRole).
func (m *AdminRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminRoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, adminrole.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, adminrole.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, adminrole.FieldName)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminrole.FieldDeletedAt)
	}
	if m.updator != nil {
		fields = append(fields, adminrole.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, adminrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminrole.FieldCreatedAt:
		return m.CreatedAt()
	case adminrole.FieldCreatedBy:
		return m.CreatedBy()
	case adminrole.FieldName:
		return m.Name()
	case adminrole.FieldDeletedAt:
		return m.DeletedAt()
	case adminrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case adminrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case adminrole.FieldName:
		return m.OldName(ctx)
	case adminrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case adminrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminrole.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case adminrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case adminrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminrole.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case adminrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminrole.FieldCreatedBy) {
		fields = append(fields, adminrole.FieldCreatedBy)
	}
	if m.FieldCleared(adminrole.FieldDeletedAt) {
		fields = append(fields, adminrole.FieldDeletedAt)
	}
	if m.FieldCleared(adminrole.FieldUpdatedBy) {
		fields = append(fields, adminrole.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminRoleMutation) ClearField(name string) error {
	switch name {
	case adminrole.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case adminrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case adminrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown AdminRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminRoleMutation) ResetField(name string) error {
	switch name {
	case adminrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case adminrole.FieldName:
		m.ResetName()
		return nil
	case adminrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case adminrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, adminrole.EdgeCreator)
	}
	if m.updator != nil {
		edges = append(edges, adminrole.EdgeUpdator)
	}
	if m.admins != nil {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeUpdator:
		if id := m.updator; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedadmins != nil {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, adminrole.EdgeCreator)
	}
	if m.clearedupdator {
		edges = append(edges, adminrole.EdgeUpdator)
	}
	if m.clearedadmins {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case adminrole.EdgeCreator:
		return m.clearedcreator
	case adminrole.EdgeUpdator:
		return m.clearedupdator
	case adminrole.EdgeAdmins:
		return m.clearedadmins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminRoleMutation) ClearEdge(name string) error {
	switch name {
	case adminrole.EdgeCreator:
		m.ClearCreator()
		return nil
	case adminrole.EdgeUpdator:
		m.ClearUpdator()
		return nil
	}
	return fmt.Errorf("unknown AdminRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminRoleMutation) ResetEdge(name string) error {
	switch name {
	case adminrole.EdgeCreator:
		m.ResetCreator()
		return nil
	case adminrole.EdgeUpdator:
		m.ResetUpdator()
		return nil
	case adminrole.EdgeAdmins:
		m.ResetAdmins()
		return nil
	}
	return fmt.Errorf("unknown AdminRole edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	created_at                 *time.Time
	title                      *string
	deleted_at                 *time.Time
	updated_by                 *int
	addupdated_by              *int
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	creator                    *int
	clearedcreator             bool
	parent                     *int
	clearedparent              bool
	employee_department        map[int]struct{}
	removedemployee_department map[int]struct{}
	clearedemployee_department bool
	children                   map[int]struct{}
	removedchildren            map[int]struct{}
	clearedchildren            bool
	done                       bool
	oldValue                   func(context.Context) (*Department, error)
	predicates                 []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DepartmentMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DepartmentMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DepartmentMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetTitle sets the "title" field.
func (m *DepartmentMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *DepartmentMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *DepartmentMutation) ResetTitle() {
	m.title = nil
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, department.FieldParentID)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DepartmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DepartmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DepartmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[department.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DepartmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DepartmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, department.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DepartmentMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DepartmentMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *DepartmentMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *DepartmentMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DepartmentMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *DepartmentMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DepartmentMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[department.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DepartmentMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *DepartmentMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DepartmentMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddEmployeeDepartmentIDs adds the "employee_department" edge to the Employee entity by ids.
func (m *DepartmentMutation) AddEmployeeDepartmentIDs(ids ...int) {
	if m.employee_department == nil {
		m.employee_department = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_department[ids[i]] = struct{}{}
	}
}

// ClearEmployeeDepartment clears the "employee_department" edge to the Employee entity.
func (m *DepartmentMutation) ClearEmployeeDepartment() {
	m.clearedemployee_department = true
}

// EmployeeDepartmentCleared reports if the "employee_department" edge to the Employee entity was cleared.
func (m *DepartmentMutation) EmployeeDepartmentCleared() bool {
	return m.clearedemployee_department
}

// RemoveEmployeeDepartmentIDs removes the "employee_department" edge to the Employee entity by IDs.
func (m *DepartmentMutation) RemoveEmployeeDepartmentIDs(ids ...int) {
	if m.removedemployee_department == nil {
		m.removedemployee_department = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_department, ids[i])
		m.removedemployee_department[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeDepartment returns the removed IDs of the "employee_department" edge to the Employee entity.
func (m *DepartmentMutation) RemovedEmployeeDepartmentIDs() (ids []int) {
	for id := range m.removedemployee_department {
		ids = append(ids, id)
	}
	return
}

// EmployeeDepartmentIDs returns the "employee_department" edge IDs in the mutation.
func (m *DepartmentMutation) EmployeeDepartmentIDs() (ids []int) {
	for id := range m.employee_department {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeDepartment resets all changes to the "employee_department" edge.
func (m *DepartmentMutation) ResetEmployeeDepartment() {
	m.employee_department = nil
	m.clearedemployee_department = false
	m.removedemployee_department = nil
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, department.FieldCreatedBy)
	}
	if m.title != nil {
		fields = append(fields, department.FieldTitle)
	}
	if m.parent != nil {
		fields = append(fields, department.FieldParentID)
	}
	if m.deleted_at != nil {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, department.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldCreatedBy:
		return m.CreatedBy()
	case department.FieldTitle:
		return m.Title()
	case department.FieldParentID:
		return m.ParentID()
	case department.FieldDeletedAt:
		return m.DeletedAt()
	case department.FieldUpdatedBy:
		return m.UpdatedBy()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case department.FieldTitle:
		return m.OldTitle(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	case department.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case department.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case department.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case department.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case department.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, department.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case department.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case department.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	if m.FieldCleared(department.FieldDeletedAt) {
		fields = append(fields, department.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	case department.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case department.FieldTitle:
		m.ResetTitle()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	case department.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case department.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, department.EdgeCreator)
	}
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.employee_department != nil {
		edges = append(edges, department.EdgeEmployeeDepartment)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeEmployeeDepartment:
		ids := make([]ent.Value, 0, len(m.employee_department))
		for id := range m.employee_department {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedemployee_department != nil {
		edges = append(edges, department.EdgeEmployeeDepartment)
	}
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEmployeeDepartment:
		ids := make([]ent.Value, 0, len(m.removedemployee_department))
		for id := range m.removedemployee_department {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, department.EdgeCreator)
	}
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedemployee_department {
		edges = append(edges, department.EdgeEmployeeDepartment)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeCreator:
		return m.clearedcreator
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeEmployeeDepartment:
		return m.clearedemployee_department
	case department.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ClearCreator()
		return nil
	case department.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ResetCreator()
		return nil
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeEmployeeDepartment:
		m.ResetEmployeeDepartment()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	deleted_at        *time.Time
	updated_by        *int
	addupdated_by     *int
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	creator           *int
	clearedcreator    bool
	admin             *int
	clearedadmin      bool
	department        *int
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*Employee, error)
	predicates        []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EmployeeMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EmployeeMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EmployeeMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetAdminID sets the "admin_id" field.
func (m *EmployeeMutation) SetAdminID(i int) {
	m.admin = &i
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *EmployeeMutation) AdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *EmployeeMutation) ResetAdminID() {
	m.admin = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *EmployeeMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *EmployeeMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *EmployeeMutation) ResetDepartmentID() {
	m.department = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EmployeeMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EmployeeMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *EmployeeMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *EmployeeMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EmployeeMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *EmployeeMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EmployeeMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[employee.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EmployeeMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *EmployeeMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EmployeeMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *EmployeeMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[employee.FieldAdminID] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *EmployeeMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *EmployeeMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[employee.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, employee.FieldCreatedBy)
	}
	if m.admin != nil {
		fields = append(fields, employee.FieldAdminID)
	}
	if m.department != nil {
		fields = append(fields, employee.FieldDepartmentID)
	}
	if m.deleted_at != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, employee.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldCreatedBy:
		return m.CreatedBy()
	case employee.FieldAdminID:
		return m.AdminID()
	case employee.FieldDepartmentID:
		return m.DepartmentID()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldUpdatedBy:
		return m.UpdatedBy()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case employee.FieldAdminID:
		return m.OldAdminID(ctx)
	case employee.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case employee.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case employee.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, employee.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employee.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case employee.FieldAdminID:
		m.ResetAdminID()
		return nil
	case employee.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.admin != nil {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.clearedadmin {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCreator:
		return m.clearedcreator
	case employee.EdgeAdmin:
		return m.clearedadmin
	case employee.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ClearCreator()
		return nil
	case employee.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ResetCreator()
		return nil
	case employee.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// RiskMutation represents an operation that mutates the Risk nodes in the graph.
type RiskMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	deleted_at    *time.Time
	updated_by    *int
	addupdated_by *int
	updated_at    *time.Time
	title         *string
	content       *string
	images        *[]struct {
		Title string "json:\"title\""
		URL   string "json:\"url\""
	}
	appendimages []struct {
		Title string "json:\"title\""
		URL   string "json:\"url\""
	}
	measures                *string
	maintain_status         *properties.MaintainStatus
	addmaintain_status      *properties.MaintainStatus
	due_time                *time.Time
	clearedFields           map[string]struct{}
	creator                 *int
	clearedcreator          bool
	maintainer_admin        *int
	clearedmaintainer_admin bool
	category                *int
	clearedcategory         bool
	location                *int
	clearedlocation         bool
	done                    bool
	oldValue                func(context.Context) (*Risk, error)
	predicates              []predicate.Risk
}

var _ ent.Mutation = (*RiskMutation)(nil)

// riskOption allows management of the mutation configuration using functional options.
type riskOption func(*RiskMutation)

// newRiskMutation creates new mutation for the Risk entity.
func newRiskMutation(c config, op Op, opts ...riskOption) *RiskMutation {
	m := &RiskMutation{
		config:        c,
		op:            op,
		typ:           TypeRisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskID sets the ID field of the mutation.
func withRiskID(id int) riskOption {
	return func(m *RiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Risk
		)
		m.oldValue = func(ctx context.Context) (*Risk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Risk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRisk sets the old Risk of the mutation.
func withRisk(node *Risk) riskOption {
	return func(m *RiskMutation) {
		m.oldValue = func(context.Context) (*Risk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Risk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[risk.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[risk.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, risk.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RiskMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RiskMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *RiskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RiskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RiskMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *RiskMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *RiskMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *RiskMutation) ResetContent() {
	m.content = nil
}

// SetImages sets the "images" field.
func (m *RiskMutation) SetImages(s []struct {
	Title string "json:\"title\""
	URL   string "json:\"url\""
}) {
	m.images = &s
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *RiskMutation) Images() (r []struct {
	Title string "json:\"title\""
	URL   string "json:\"url\""
}, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldImages(ctx context.Context) (v []struct {
	Title string "json:\"title\""
	URL   string "json:\"url\""
}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds s to the "images" field.
func (m *RiskMutation) AppendImages(s []struct {
	Title string "json:\"title\""
	URL   string "json:\"url\""
}) {
	m.appendimages = append(m.appendimages, s...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *RiskMutation) AppendedImages() ([]struct {
	Title string "json:\"title\""
	URL   string "json:\"url\""
}, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *RiskMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[risk.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *RiskMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[risk.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *RiskMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, risk.FieldImages)
}

// SetRiskCategoryID sets the "risk_category_id" field.
func (m *RiskMutation) SetRiskCategoryID(i int) {
	m.category = &i
}

// RiskCategoryID returns the value of the "risk_category_id" field in the mutation.
func (m *RiskMutation) RiskCategoryID() (r int, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskCategoryID returns the old "risk_category_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskCategoryID: %w", err)
	}
	return oldValue.RiskCategoryID, nil
}

// ResetRiskCategoryID resets all changes to the "risk_category_id" field.
func (m *RiskMutation) ResetRiskCategoryID() {
	m.category = nil
}

// SetRiskLocationID sets the "risk_location_id" field.
func (m *RiskMutation) SetRiskLocationID(i int) {
	m.location = &i
}

// RiskLocationID returns the value of the "risk_location_id" field in the mutation.
func (m *RiskMutation) RiskLocationID() (r int, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLocationID returns the old "risk_location_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLocationID: %w", err)
	}
	return oldValue.RiskLocationID, nil
}

// ResetRiskLocationID resets all changes to the "risk_location_id" field.
func (m *RiskMutation) ResetRiskLocationID() {
	m.location = nil
}

// SetMaintainer sets the "maintainer" field.
func (m *RiskMutation) SetMaintainer(i int) {
	m.maintainer_admin = &i
}

// Maintainer returns the value of the "maintainer" field in the mutation.
func (m *RiskMutation) Maintainer() (r int, exists bool) {
	v := m.maintainer_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainer returns the old "maintainer" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainer(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainer: %w", err)
	}
	return oldValue.Maintainer, nil
}

// ResetMaintainer resets all changes to the "maintainer" field.
func (m *RiskMutation) ResetMaintainer() {
	m.maintainer_admin = nil
}

// SetMeasures sets the "measures" field.
func (m *RiskMutation) SetMeasures(s string) {
	m.measures = &s
}

// Measures returns the value of the "measures" field in the mutation.
func (m *RiskMutation) Measures() (r string, exists bool) {
	v := m.measures
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasures returns the old "measures" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMeasures(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasures: %w", err)
	}
	return oldValue.Measures, nil
}

// ClearMeasures clears the value of the "measures" field.
func (m *RiskMutation) ClearMeasures() {
	m.measures = nil
	m.clearedFields[risk.FieldMeasures] = struct{}{}
}

// MeasuresCleared returns if the "measures" field was cleared in this mutation.
func (m *RiskMutation) MeasuresCleared() bool {
	_, ok := m.clearedFields[risk.FieldMeasures]
	return ok
}

// ResetMeasures resets all changes to the "measures" field.
func (m *RiskMutation) ResetMeasures() {
	m.measures = nil
	delete(m.clearedFields, risk.FieldMeasures)
}

// SetMaintainStatus sets the "maintain_status" field.
func (m *RiskMutation) SetMaintainStatus(ps properties.MaintainStatus) {
	m.maintain_status = &ps
	m.addmaintain_status = nil
}

// MaintainStatus returns the value of the "maintain_status" field in the mutation.
func (m *RiskMutation) MaintainStatus() (r properties.MaintainStatus, exists bool) {
	v := m.maintain_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainStatus returns the old "maintain_status" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainStatus(ctx context.Context) (v properties.MaintainStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainStatus: %w", err)
	}
	return oldValue.MaintainStatus, nil
}

// AddMaintainStatus adds ps to the "maintain_status" field.
func (m *RiskMutation) AddMaintainStatus(ps properties.MaintainStatus) {
	if m.addmaintain_status != nil {
		*m.addmaintain_status += ps
	} else {
		m.addmaintain_status = &ps
	}
}

// AddedMaintainStatus returns the value that was added to the "maintain_status" field in this mutation.
func (m *RiskMutation) AddedMaintainStatus() (r properties.MaintainStatus, exists bool) {
	v := m.addmaintain_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainStatus resets all changes to the "maintain_status" field.
func (m *RiskMutation) ResetMaintainStatus() {
	m.maintain_status = nil
	m.addmaintain_status = nil
}

// SetDueTime sets the "due_time" field.
func (m *RiskMutation) SetDueTime(t time.Time) {
	m.due_time = &t
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *RiskMutation) DueTime() (r time.Time, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *RiskMutation) ResetDueTime() {
	m.due_time = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risk.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetMaintainerAdminID sets the "maintainer_admin" edge to the Admin entity by id.
func (m *RiskMutation) SetMaintainerAdminID(id int) {
	m.maintainer_admin = &id
}

// ClearMaintainerAdmin clears the "maintainer_admin" edge to the Admin entity.
func (m *RiskMutation) ClearMaintainerAdmin() {
	m.clearedmaintainer_admin = true
	m.clearedFields[risk.FieldMaintainer] = struct{}{}
}

// MaintainerAdminCleared reports if the "maintainer_admin" edge to the Admin entity was cleared.
func (m *RiskMutation) MaintainerAdminCleared() bool {
	return m.clearedmaintainer_admin
}

// MaintainerAdminID returns the "maintainer_admin" edge ID in the mutation.
func (m *RiskMutation) MaintainerAdminID() (id int, exists bool) {
	if m.maintainer_admin != nil {
		return *m.maintainer_admin, true
	}
	return
}

// MaintainerAdminIDs returns the "maintainer_admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MaintainerAdminID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) MaintainerAdminIDs() (ids []int) {
	if id := m.maintainer_admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMaintainerAdmin resets all changes to the "maintainer_admin" edge.
func (m *RiskMutation) ResetMaintainerAdmin() {
	m.maintainer_admin = nil
	m.clearedmaintainer_admin = false
}

// SetCategoryID sets the "category" edge to the RiskCategory entity by id.
func (m *RiskMutation) SetCategoryID(id int) {
	m.category = &id
}

// ClearCategory clears the "category" edge to the RiskCategory entity.
func (m *RiskMutation) ClearCategory() {
	m.clearedcategory = true
	m.clearedFields[risk.FieldRiskCategoryID] = struct{}{}
}

// CategoryCleared reports if the "category" edge to the RiskCategory entity was cleared.
func (m *RiskMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// CategoryID returns the "category" edge ID in the mutation.
func (m *RiskMutation) CategoryID() (id int, exists bool) {
	if m.category != nil {
		return *m.category, true
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CategoryID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) CategoryIDs() (ids []int) {
	if id := m.category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *RiskMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
}

// SetLocationID sets the "location" edge to the RiskLocation entity by id.
func (m *RiskMutation) SetLocationID(id int) {
	m.location = &id
}

// ClearLocation clears the "location" edge to the RiskLocation entity.
func (m *RiskMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[risk.FieldRiskLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the RiskLocation entity was cleared.
func (m *RiskMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationID returns the "location" edge ID in the mutation.
func (m *RiskMutation) LocationID() (id int, exists bool) {
	if m.location != nil {
		return *m.location, true
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) LocationIDs() (ids []int) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *RiskMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the RiskMutation builder.
func (m *RiskMutation) Where(ps ...predicate.Risk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Risk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Risk).
func (m *RiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, risk.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, risk.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, risk.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, risk.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, risk.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, risk.FieldContent)
	}
	if m.images != nil {
		fields = append(fields, risk.FieldImages)
	}
	if m.category != nil {
		fields = append(fields, risk.FieldRiskCategoryID)
	}
	if m.location != nil {
		fields = append(fields, risk.FieldRiskLocationID)
	}
	if m.maintainer_admin != nil {
		fields = append(fields, risk.FieldMaintainer)
	}
	if m.measures != nil {
		fields = append(fields, risk.FieldMeasures)
	}
	if m.maintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	if m.due_time != nil {
		fields = append(fields, risk.FieldDueTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldCreatedAt:
		return m.CreatedAt()
	case risk.FieldCreatedBy:
		return m.CreatedBy()
	case risk.FieldDeletedAt:
		return m.DeletedAt()
	case risk.FieldUpdatedBy:
		return m.UpdatedBy()
	case risk.FieldUpdatedAt:
		return m.UpdatedAt()
	case risk.FieldTitle:
		return m.Title()
	case risk.FieldContent:
		return m.Content()
	case risk.FieldImages:
		return m.Images()
	case risk.FieldRiskCategoryID:
		return m.RiskCategoryID()
	case risk.FieldRiskLocationID:
		return m.RiskLocationID()
	case risk.FieldMaintainer:
		return m.Maintainer()
	case risk.FieldMeasures:
		return m.Measures()
	case risk.FieldMaintainStatus:
		return m.MaintainStatus()
	case risk.FieldDueTime:
		return m.DueTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case risk.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case risk.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case risk.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case risk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case risk.FieldTitle:
		return m.OldTitle(ctx)
	case risk.FieldContent:
		return m.OldContent(ctx)
	case risk.FieldImages:
		return m.OldImages(ctx)
	case risk.FieldRiskCategoryID:
		return m.OldRiskCategoryID(ctx)
	case risk.FieldRiskLocationID:
		return m.OldRiskLocationID(ctx)
	case risk.FieldMaintainer:
		return m.OldMaintainer(ctx)
	case risk.FieldMeasures:
		return m.OldMeasures(ctx)
	case risk.FieldMaintainStatus:
		return m.OldMaintainStatus(ctx)
	case risk.FieldDueTime:
		return m.OldDueTime(ctx)
	}
	return nil, fmt.Errorf("unknown Risk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case risk.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case risk.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case risk.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case risk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case risk.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case risk.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case risk.FieldImages:
		v, ok := value.([]struct {
			Title string "json:\"title\""
			URL   string "json:\"url\""
		})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case risk.FieldRiskCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskCategoryID(v)
		return nil
	case risk.FieldRiskLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLocationID(v)
		return nil
	case risk.FieldMaintainer:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainer(v)
		return nil
	case risk.FieldMeasures:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasures(v)
		return nil
	case risk.FieldMaintainStatus:
		v, ok := value.(properties.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainStatus(v)
		return nil
	case risk.FieldDueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, risk.FieldUpdatedBy)
	}
	if m.addmaintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case risk.FieldMaintainStatus:
		return m.AddedMaintainStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case risk.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case risk.FieldMaintainStatus:
		v, ok := value.(properties.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Risk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risk.FieldDeletedAt) {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.FieldCleared(risk.FieldImages) {
		fields = append(fields, risk.FieldImages)
	}
	if m.FieldCleared(risk.FieldMeasures) {
		fields = append(fields, risk.FieldMeasures)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskMutation) ClearField(name string) error {
	switch name {
	case risk.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case risk.FieldImages:
		m.ClearImages()
		return nil
	case risk.FieldMeasures:
		m.ClearMeasures()
		return nil
	}
	return fmt.Errorf("unknown Risk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskMutation) ResetField(name string) error {
	switch name {
	case risk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case risk.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case risk.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case risk.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case risk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case risk.FieldTitle:
		m.ResetTitle()
		return nil
	case risk.FieldContent:
		m.ResetContent()
		return nil
	case risk.FieldImages:
		m.ResetImages()
		return nil
	case risk.FieldRiskCategoryID:
		m.ResetRiskCategoryID()
		return nil
	case risk.FieldRiskLocationID:
		m.ResetRiskLocationID()
		return nil
	case risk.FieldMaintainer:
		m.ResetMaintainer()
		return nil
	case risk.FieldMeasures:
		m.ResetMeasures()
		return nil
	case risk.FieldMaintainStatus:
		m.ResetMaintainStatus()
		return nil
	case risk.FieldDueTime:
		m.ResetDueTime()
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.maintainer_admin != nil {
		edges = append(edges, risk.EdgeMaintainerAdmin)
	}
	if m.category != nil {
		edges = append(edges, risk.EdgeCategory)
	}
	if m.location != nil {
		edges = append(edges, risk.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risk.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeMaintainerAdmin:
		if id := m.maintainer_admin; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeCategory:
		if id := m.category; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.clearedmaintainer_admin {
		edges = append(edges, risk.EdgeMaintainerAdmin)
	}
	if m.clearedcategory {
		edges = append(edges, risk.EdgeCategory)
	}
	if m.clearedlocation {
		edges = append(edges, risk.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskMutation) EdgeCleared(name string) bool {
	switch name {
	case risk.EdgeCreator:
		return m.clearedcreator
	case risk.EdgeMaintainerAdmin:
		return m.clearedmaintainer_admin
	case risk.EdgeCategory:
		return m.clearedcategory
	case risk.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskMutation) ClearEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ClearCreator()
		return nil
	case risk.EdgeMaintainerAdmin:
		m.ClearMaintainerAdmin()
		return nil
	case risk.EdgeCategory:
		m.ClearCategory()
		return nil
	case risk.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown Risk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskMutation) ResetEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ResetCreator()
		return nil
	case risk.EdgeMaintainerAdmin:
		m.ResetMaintainerAdmin()
		return nil
	case risk.EdgeCategory:
		m.ResetCategory()
		return nil
	case risk.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown Risk edge %s", name)
}

// RiskCategoryMutation represents an operation that mutates the RiskCategory nodes in the graph.
type RiskCategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	deleted_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_at           *time.Time
	title                *string
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	risk_category        map[int]struct{}
	removedrisk_category map[int]struct{}
	clearedrisk_category bool
	done                 bool
	oldValue             func(context.Context) (*RiskCategory, error)
	predicates           []predicate.RiskCategory
}

var _ ent.Mutation = (*RiskCategoryMutation)(nil)

// riskcategoryOption allows management of the mutation configuration using functional options.
type riskcategoryOption func(*RiskCategoryMutation)

// newRiskCategoryMutation creates new mutation for the RiskCategory entity.
func newRiskCategoryMutation(c config, op Op, opts ...riskcategoryOption) *RiskCategoryMutation {
	m := &RiskCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskCategoryID sets the ID field of the mutation.
func withRiskCategoryID(id int) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskCategory
		)
		m.oldValue = func(ctx context.Context) (*RiskCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskCategory sets the old RiskCategory of the mutation.
func withRiskCategory(node *RiskCategory) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		m.oldValue = func(context.Context) (*RiskCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskCategoryMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskCategoryMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskCategoryMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[riskcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[riskcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, riskcategory.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskCategoryMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskCategoryMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RiskCategoryMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RiskCategoryMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskCategoryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *RiskCategoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RiskCategoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RiskCategoryMutation) ResetTitle() {
	m.title = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskCategoryMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskCategoryMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[riskcategory.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskCategoryMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskCategoryMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskCategoryMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskCategoryMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddRiskCategoryIDs adds the "risk_category" edge to the Risk entity by ids.
func (m *RiskCategoryMutation) AddRiskCategoryIDs(ids ...int) {
	if m.risk_category == nil {
		m.risk_category = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category[ids[i]] = struct{}{}
	}
}

// ClearRiskCategory clears the "risk_category" edge to the Risk entity.
func (m *RiskCategoryMutation) ClearRiskCategory() {
	m.clearedrisk_category = true
}

// RiskCategoryCleared reports if the "risk_category" edge to the Risk entity was cleared.
func (m *RiskCategoryMutation) RiskCategoryCleared() bool {
	return m.clearedrisk_category
}

// RemoveRiskCategoryIDs removes the "risk_category" edge to the Risk entity by IDs.
func (m *RiskCategoryMutation) RemoveRiskCategoryIDs(ids ...int) {
	if m.removedrisk_category == nil {
		m.removedrisk_category = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category, ids[i])
		m.removedrisk_category[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategory returns the removed IDs of the "risk_category" edge to the Risk entity.
func (m *RiskCategoryMutation) RemovedRiskCategoryIDs() (ids []int) {
	for id := range m.removedrisk_category {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryIDs returns the "risk_category" edge IDs in the mutation.
func (m *RiskCategoryMutation) RiskCategoryIDs() (ids []int) {
	for id := range m.risk_category {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategory resets all changes to the "risk_category" edge.
func (m *RiskCategoryMutation) ResetRiskCategory() {
	m.risk_category = nil
	m.clearedrisk_category = false
	m.removedrisk_category = nil
}

// Where appends a list predicates to the RiskCategoryMutation builder.
func (m *RiskCategoryMutation) Where(ps ...predicate.RiskCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskCategory).
func (m *RiskCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, riskcategory.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, riskcategory.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, riskcategory.FieldDeletedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, riskcategory.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, riskcategory.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, riskcategory.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case riskcategory.FieldCreatedAt:
		return m.CreatedAt()
	case riskcategory.FieldCreatedBy:
		return m.CreatedBy()
	case riskcategory.FieldDeletedAt:
		return m.DeletedAt()
	case riskcategory.FieldUpdatedBy:
		return m.UpdatedBy()
	case riskcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case riskcategory.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case riskcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case riskcategory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case riskcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case riskcategory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case riskcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case riskcategory.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown RiskCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case riskcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case riskcategory.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case riskcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case riskcategory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case riskcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case riskcategory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, riskcategory.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case riskcategory.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case riskcategory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown RiskCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(riskcategory.FieldDeletedAt) {
		fields = append(fields, riskcategory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ClearField(name string) error {
	switch name {
	case riskcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ResetField(name string) error {
	switch name {
	case riskcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case riskcategory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case riskcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case riskcategory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case riskcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case riskcategory.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.risk_category != nil {
		edges = append(edges, riskcategory.EdgeRiskCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case riskcategory.EdgeRiskCategory:
		ids := make([]ent.Value, 0, len(m.risk_category))
		for id := range m.risk_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrisk_category != nil {
		edges = append(edges, riskcategory.EdgeRiskCategory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeRiskCategory:
		ids := make([]ent.Value, 0, len(m.removedrisk_category))
		for id := range m.removedrisk_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.clearedrisk_category {
		edges = append(edges, riskcategory.EdgeRiskCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case riskcategory.EdgeCreator:
		return m.clearedcreator
	case riskcategory.EdgeRiskCategory:
		return m.clearedrisk_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskCategoryMutation) ClearEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskCategoryMutation) ResetEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ResetCreator()
		return nil
	case riskcategory.EdgeRiskCategory:
		m.ResetRiskCategory()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory edge %s", name)
}

// RiskLocationMutation represents an operation that mutates the RiskLocation nodes in the graph.
type RiskLocationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	deleted_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	updated_at           *time.Time
	title                *string
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	risk_location        map[int]struct{}
	removedrisk_location map[int]struct{}
	clearedrisk_location bool
	done                 bool
	oldValue             func(context.Context) (*RiskLocation, error)
	predicates           []predicate.RiskLocation
}

var _ ent.Mutation = (*RiskLocationMutation)(nil)

// risklocationOption allows management of the mutation configuration using functional options.
type risklocationOption func(*RiskLocationMutation)

// newRiskLocationMutation creates new mutation for the RiskLocation entity.
func newRiskLocationMutation(c config, op Op, opts ...risklocationOption) *RiskLocationMutation {
	m := &RiskLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskLocationID sets the ID field of the mutation.
func withRiskLocationID(id int) risklocationOption {
	return func(m *RiskLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskLocation
		)
		m.oldValue = func(ctx context.Context) (*RiskLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskLocation sets the old RiskLocation of the mutation.
func withRiskLocation(node *RiskLocation) risklocationOption {
	return func(m *RiskLocationMutation) {
		m.oldValue = func(context.Context) (*RiskLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskLocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskLocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskLocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskLocationMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskLocationMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskLocationMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskLocationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskLocationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskLocationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[risklocation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskLocationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[risklocation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskLocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, risklocation.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskLocationMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskLocationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *RiskLocationMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *RiskLocationMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskLocationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskLocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskLocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *RiskLocationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RiskLocationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RiskLocationMutation) ResetTitle() {
	m.title = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskLocationMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskLocationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risklocation.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskLocationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskLocationMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskLocationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskLocationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddRiskLocationIDs adds the "risk_location" edge to the Risk entity by ids.
func (m *RiskLocationMutation) AddRiskLocationIDs(ids ...int) {
	if m.risk_location == nil {
		m.risk_location = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location[ids[i]] = struct{}{}
	}
}

// ClearRiskLocation clears the "risk_location" edge to the Risk entity.
func (m *RiskLocationMutation) ClearRiskLocation() {
	m.clearedrisk_location = true
}

// RiskLocationCleared reports if the "risk_location" edge to the Risk entity was cleared.
func (m *RiskLocationMutation) RiskLocationCleared() bool {
	return m.clearedrisk_location
}

// RemoveRiskLocationIDs removes the "risk_location" edge to the Risk entity by IDs.
func (m *RiskLocationMutation) RemoveRiskLocationIDs(ids ...int) {
	if m.removedrisk_location == nil {
		m.removedrisk_location = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location, ids[i])
		m.removedrisk_location[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocation returns the removed IDs of the "risk_location" edge to the Risk entity.
func (m *RiskLocationMutation) RemovedRiskLocationIDs() (ids []int) {
	for id := range m.removedrisk_location {
		ids = append(ids, id)
	}
	return
}

// RiskLocationIDs returns the "risk_location" edge IDs in the mutation.
func (m *RiskLocationMutation) RiskLocationIDs() (ids []int) {
	for id := range m.risk_location {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocation resets all changes to the "risk_location" edge.
func (m *RiskLocationMutation) ResetRiskLocation() {
	m.risk_location = nil
	m.clearedrisk_location = false
	m.removedrisk_location = nil
}

// Where appends a list predicates to the RiskLocationMutation builder.
func (m *RiskLocationMutation) Where(ps ...predicate.RiskLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskLocation).
func (m *RiskLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskLocationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, risklocation.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, risklocation.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, risklocation.FieldDeletedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, risklocation.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, risklocation.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, risklocation.FieldTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risklocation.FieldCreatedAt:
		return m.CreatedAt()
	case risklocation.FieldCreatedBy:
		return m.CreatedBy()
	case risklocation.FieldDeletedAt:
		return m.DeletedAt()
	case risklocation.FieldUpdatedBy:
		return m.UpdatedBy()
	case risklocation.FieldUpdatedAt:
		return m.UpdatedAt()
	case risklocation.FieldTitle:
		return m.Title()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risklocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case risklocation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case risklocation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case risklocation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case risklocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case risklocation.FieldTitle:
		return m.OldTitle(ctx)
	}
	return nil, fmt.Errorf("unknown RiskLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risklocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case risklocation.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case risklocation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case risklocation.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case risklocation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case risklocation.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskLocationMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, risklocation.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case risklocation.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case risklocation.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown RiskLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risklocation.FieldDeletedAt) {
		fields = append(fields, risklocation.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskLocationMutation) ClearField(name string) error {
	switch name {
	case risklocation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskLocationMutation) ResetField(name string) error {
	switch name {
	case risklocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case risklocation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case risklocation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case risklocation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case risklocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case risklocation.FieldTitle:
		m.ResetTitle()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.risk_location != nil {
		edges = append(edges, risklocation.EdgeRiskLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risklocation.EdgeRiskLocation:
		ids := make([]ent.Value, 0, len(m.risk_location))
		for id := range m.risk_location {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrisk_location != nil {
		edges = append(edges, risklocation.EdgeRiskLocation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskLocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeRiskLocation:
		ids := make([]ent.Value, 0, len(m.removedrisk_location))
		for id := range m.removedrisk_location {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.clearedrisk_location {
		edges = append(edges, risklocation.EdgeRiskLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case risklocation.EdgeCreator:
		return m.clearedcreator
	case risklocation.EdgeRiskLocation:
		return m.clearedrisk_location
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskLocationMutation) ClearEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskLocationMutation) ResetEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ResetCreator()
		return nil
	case risklocation.EdgeRiskLocation:
		m.ResetRiskLocation()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation edge %s", name)
}
