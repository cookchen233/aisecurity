// Code generated by ent, DO NOT EDIT.

package dao

import (
	"aisecurity/ent/dao/admin"
	"aisecurity/ent/dao/area"
	"aisecurity/ent/dao/department"
	"aisecurity/ent/dao/device"
	"aisecurity/ent/dao/deviceinstallation"
	"aisecurity/ent/dao/employee"
	"aisecurity/ent/dao/event"
	"aisecurity/ent/dao/eventlevel"
	"aisecurity/ent/dao/eventlog"
	"aisecurity/ent/dao/fixing"
	"aisecurity/ent/dao/occupation"
	"aisecurity/ent/dao/permission"
	"aisecurity/ent/dao/predicate"
	"aisecurity/ent/dao/risk"
	"aisecurity/ent/dao/riskcategory"
	"aisecurity/ent/dao/risklocation"
	"aisecurity/ent/dao/sweep"
	"aisecurity/ent/dao/sweepresult"
	"aisecurity/ent/dao/sweepresultdetails"
	"aisecurity/ent/dao/sweepschedule"
	"aisecurity/ent/dao/video"
	"aisecurity/enums"
	"aisecurity/properties/maintain_status"
	"aisecurity/structs/types"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin              = "Admin"
	TypeArea               = "Area"
	TypeDepartment         = "Department"
	TypeDevice             = "Device"
	TypeDeviceInstallation = "DeviceInstallation"
	TypeEmployee           = "Employee"
	TypeEvent              = "Event"
	TypeEventLevel         = "EventLevel"
	TypeEventLog           = "EventLog"
	TypeFixing             = "Fixing"
	TypeOccupation         = "Occupation"
	TypePermission         = "Permission"
	TypeRisk               = "Risk"
	TypeRiskCategory       = "RiskCategory"
	TypeRiskLocation       = "RiskLocation"
	TypeSweep              = "Sweep"
	TypeSweepResult        = "SweepResult"
	TypeSweepResultDetails = "SweepResultDetails"
	TypeSweepSchedule      = "SweepSchedule"
	TypeVideo              = "Video"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	create_time                         *time.Time
	delete_time                         *time.Time
	update_time                         *time.Time
	username                            *string
	password                            *string
	nickname                            *string
	real_name                           *string
	mobile                              *string
	avatar                              *types.UploadedImage
	admin_status                        *enums.AdminStatus
	addadmin_status                     *enums.AdminStatus
	clearedFields                       map[string]struct{}
	creator                             *int
	clearedcreator                      bool
	updater                             *int
	clearedupdater                      bool
	permissions                         map[int]struct{}
	removedpermissions                  map[int]struct{}
	clearedpermissions                  bool
	admin_creator                       map[int]struct{}
	removedadmin_creator                map[int]struct{}
	clearedadmin_creator                bool
	admin_updater                       map[int]struct{}
	removedadmin_updater                map[int]struct{}
	clearedadmin_updater                bool
	permission_creator                  map[int]struct{}
	removedpermission_creator           map[int]struct{}
	clearedpermission_creator           bool
	permission_updater                  map[int]struct{}
	removedpermission_updater           map[int]struct{}
	clearedpermission_updater           bool
	risk_creator                        map[int]struct{}
	removedrisk_creator                 map[int]struct{}
	clearedrisk_creator                 bool
	risk_updater                        map[int]struct{}
	removedrisk_updater                 map[int]struct{}
	clearedrisk_updater                 bool
	risk_maintainer                     map[int]struct{}
	removedrisk_maintainer              map[int]struct{}
	clearedrisk_maintainer              bool
	risk_location_creator               map[int]struct{}
	removedrisk_location_creator        map[int]struct{}
	clearedrisk_location_creator        bool
	risk_location_updater               map[int]struct{}
	removedrisk_location_updater        map[int]struct{}
	clearedrisk_location_updater        bool
	risk_category_creator               map[int]struct{}
	removedrisk_category_creator        map[int]struct{}
	clearedrisk_category_creator        bool
	risk_category_updater               map[int]struct{}
	removedrisk_category_updater        map[int]struct{}
	clearedrisk_category_updater        bool
	department_creator                  map[int]struct{}
	removeddepartment_creator           map[int]struct{}
	cleareddepartment_creator           bool
	department_updater                  map[int]struct{}
	removeddepartment_updater           map[int]struct{}
	cleareddepartment_updater           bool
	employee_creator                    map[int]struct{}
	removedemployee_creator             map[int]struct{}
	clearedemployee_creator             bool
	employee_updater                    map[int]struct{}
	removedemployee_updater             map[int]struct{}
	clearedemployee_updater             bool
	employee                            *int
	clearedemployee                     bool
	occupation_creator                  map[int]struct{}
	removedoccupation_creator           map[int]struct{}
	clearedoccupation_creator           bool
	occupation_updater                  map[int]struct{}
	removedoccupation_updater           map[int]struct{}
	clearedoccupation_updater           bool
	event_creator                       map[int]struct{}
	removedevent_creator                map[int]struct{}
	clearedevent_creator                bool
	event_updater                       map[int]struct{}
	removedevent_updater                map[int]struct{}
	clearedevent_updater                bool
	video_creator                       map[int]struct{}
	removedvideo_creator                map[int]struct{}
	clearedvideo_creator                bool
	video_updater                       map[int]struct{}
	removedvideo_updater                map[int]struct{}
	clearedvideo_updater                bool
	area_creator                        map[int]struct{}
	removedarea_creator                 map[int]struct{}
	clearedarea_creator                 bool
	area_updater                        map[int]struct{}
	removedarea_updater                 map[int]struct{}
	clearedarea_updater                 bool
	device_creator                      map[int]struct{}
	removeddevice_creator               map[int]struct{}
	cleareddevice_creator               bool
	device_updater                      map[int]struct{}
	removeddevice_updater               map[int]struct{}
	cleareddevice_updater               bool
	device_installation_creator         map[int]struct{}
	removeddevice_installation_creator  map[int]struct{}
	cleareddevice_installation_creator  bool
	device_installation_updater         map[int]struct{}
	removeddevice_installation_updater  map[int]struct{}
	cleareddevice_installation_updater  bool
	event_level_creator                 map[int]struct{}
	removedevent_level_creator          map[int]struct{}
	clearedevent_level_creator          bool
	event_level_updater                 map[int]struct{}
	removedevent_level_updater          map[int]struct{}
	clearedevent_level_updater          bool
	fixing_creator                      map[int]struct{}
	removedfixing_creator               map[int]struct{}
	clearedfixing_creator               bool
	fixing_updater                      map[int]struct{}
	removedfixing_updater               map[int]struct{}
	clearedfixing_updater               bool
	fixer                               map[int]struct{}
	removedfixer                        map[int]struct{}
	clearedfixer                        bool
	event_log_creator                   map[int]struct{}
	removedevent_log_creator            map[int]struct{}
	clearedevent_log_creator            bool
	event_log_updater                   map[int]struct{}
	removedevent_log_updater            map[int]struct{}
	clearedevent_log_updater            bool
	event_log_actor                     map[int]struct{}
	removedevent_log_actor              map[int]struct{}
	clearedevent_log_actor              bool
	event_log_actor2                    map[int]struct{}
	removedevent_log_actor2             map[int]struct{}
	clearedevent_log_actor2             bool
	sweep_creator                       map[int]struct{}
	removedsweep_creator                map[int]struct{}
	clearedsweep_creator                bool
	sweep_updater                       map[int]struct{}
	removedsweep_updater                map[int]struct{}
	clearedsweep_updater                bool
	sweep_schedule_creator              map[int]struct{}
	removedsweep_schedule_creator       map[int]struct{}
	clearedsweep_schedule_creator       bool
	sweep_schedule_updater              map[int]struct{}
	removedsweep_schedule_updater       map[int]struct{}
	clearedsweep_schedule_updater       bool
	sweep_schedule                      map[int]struct{}
	removedsweep_schedule               map[int]struct{}
	clearedsweep_schedule               bool
	sweep_result_creator                map[int]struct{}
	removedsweep_result_creator         map[int]struct{}
	clearedsweep_result_creator         bool
	sweep_result_updater                map[int]struct{}
	removedsweep_result_updater         map[int]struct{}
	clearedsweep_result_updater         bool
	sweep_result_details_creator        map[int]struct{}
	removedsweep_result_details_creator map[int]struct{}
	clearedsweep_result_details_creator bool
	sweep_result_details_updater        map[int]struct{}
	removedsweep_result_details_updater map[int]struct{}
	clearedsweep_result_details_updater bool
	done                                bool
	oldValue                            func(context.Context) (*Admin, error)
	predicates                          []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AdminMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AdminMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AdminMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *AdminMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *AdminMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *AdminMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *AdminMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AdminMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AdminMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[admin.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AdminMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AdminMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, admin.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *AdminMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *AdminMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *AdminMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AdminMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AdminMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AdminMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *AdminMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AdminMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AdminMutation) ResetNickname() {
	m.nickname = nil
}

// SetRealName sets the "real_name" field.
func (m *AdminMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *AdminMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "real_name" field.
func (m *AdminMutation) ResetRealName() {
	m.real_name = nil
}

// SetMobile sets the "mobile" field.
func (m *AdminMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *AdminMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *AdminMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[admin.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *AdminMutation) MobileCleared() bool {
	_, ok := m.clearedFields[admin.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *AdminMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, admin.FieldMobile)
}

// SetAvatar sets the "avatar" field.
func (m *AdminMutation) SetAvatar(ti types.UploadedImage) {
	m.avatar = &ti
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AdminMutation) Avatar() (r types.UploadedImage, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldAvatar(ctx context.Context) (v types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *AdminMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[admin.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *AdminMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[admin.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AdminMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, admin.FieldAvatar)
}

// SetAdminStatus sets the "admin_status" field.
func (m *AdminMutation) SetAdminStatus(es enums.AdminStatus) {
	m.admin_status = &es
	m.addadmin_status = nil
}

// AdminStatus returns the value of the "admin_status" field in the mutation.
func (m *AdminMutation) AdminStatus() (r enums.AdminStatus, exists bool) {
	v := m.admin_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminStatus returns the old "admin_status" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldAdminStatus(ctx context.Context) (v enums.AdminStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminStatus: %w", err)
	}
	return oldValue.AdminStatus, nil
}

// AddAdminStatus adds es to the "admin_status" field.
func (m *AdminMutation) AddAdminStatus(es enums.AdminStatus) {
	if m.addadmin_status != nil {
		*m.addadmin_status += es
	} else {
		m.addadmin_status = &es
	}
}

// AddedAdminStatus returns the value that was added to the "admin_status" field in this mutation.
func (m *AdminMutation) AddedAdminStatus() (r enums.AdminStatus, exists bool) {
	v := m.addadmin_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdminStatus resets all changes to the "admin_status" field.
func (m *AdminMutation) ResetAdminStatus() {
	m.admin_status = nil
	m.addadmin_status = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AdminMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[admin.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AdminMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AdminMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *AdminMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[admin.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *AdminMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *AdminMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *AdminMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *AdminMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *AdminMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *AdminMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *AdminMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *AdminMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *AdminMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddAdminCreatorIDs adds the "admin_creator" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminCreatorIDs(ids ...int) {
	if m.admin_creator == nil {
		m.admin_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_creator[ids[i]] = struct{}{}
	}
}

// ClearAdminCreator clears the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) ClearAdminCreator() {
	m.clearedadmin_creator = true
}

// AdminCreatorCleared reports if the "admin_creator" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminCreatorCleared() bool {
	return m.clearedadmin_creator
}

// RemoveAdminCreatorIDs removes the "admin_creator" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminCreatorIDs(ids ...int) {
	if m.removedadmin_creator == nil {
		m.removedadmin_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_creator, ids[i])
		m.removedadmin_creator[ids[i]] = struct{}{}
	}
}

// RemovedAdminCreator returns the removed IDs of the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminCreatorIDs() (ids []int) {
	for id := range m.removedadmin_creator {
		ids = append(ids, id)
	}
	return
}

// AdminCreatorIDs returns the "admin_creator" edge IDs in the mutation.
func (m *AdminMutation) AdminCreatorIDs() (ids []int) {
	for id := range m.admin_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminCreator resets all changes to the "admin_creator" edge.
func (m *AdminMutation) ResetAdminCreator() {
	m.admin_creator = nil
	m.clearedadmin_creator = false
	m.removedadmin_creator = nil
}

// AddAdminUpdaterIDs adds the "admin_updater" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminUpdaterIDs(ids ...int) {
	if m.admin_updater == nil {
		m.admin_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_updater[ids[i]] = struct{}{}
	}
}

// ClearAdminUpdater clears the "admin_updater" edge to the Admin entity.
func (m *AdminMutation) ClearAdminUpdater() {
	m.clearedadmin_updater = true
}

// AdminUpdaterCleared reports if the "admin_updater" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminUpdaterCleared() bool {
	return m.clearedadmin_updater
}

// RemoveAdminUpdaterIDs removes the "admin_updater" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminUpdaterIDs(ids ...int) {
	if m.removedadmin_updater == nil {
		m.removedadmin_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_updater, ids[i])
		m.removedadmin_updater[ids[i]] = struct{}{}
	}
}

// RemovedAdminUpdater returns the removed IDs of the "admin_updater" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminUpdaterIDs() (ids []int) {
	for id := range m.removedadmin_updater {
		ids = append(ids, id)
	}
	return
}

// AdminUpdaterIDs returns the "admin_updater" edge IDs in the mutation.
func (m *AdminMutation) AdminUpdaterIDs() (ids []int) {
	for id := range m.admin_updater {
		ids = append(ids, id)
	}
	return
}

// ResetAdminUpdater resets all changes to the "admin_updater" edge.
func (m *AdminMutation) ResetAdminUpdater() {
	m.admin_updater = nil
	m.clearedadmin_updater = false
	m.removedadmin_updater = nil
}

// AddPermissionCreatorIDs adds the "permission_creator" edge to the Permission entity by ids.
func (m *AdminMutation) AddPermissionCreatorIDs(ids ...int) {
	if m.permission_creator == nil {
		m.permission_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.permission_creator[ids[i]] = struct{}{}
	}
}

// ClearPermissionCreator clears the "permission_creator" edge to the Permission entity.
func (m *AdminMutation) ClearPermissionCreator() {
	m.clearedpermission_creator = true
}

// PermissionCreatorCleared reports if the "permission_creator" edge to the Permission entity was cleared.
func (m *AdminMutation) PermissionCreatorCleared() bool {
	return m.clearedpermission_creator
}

// RemovePermissionCreatorIDs removes the "permission_creator" edge to the Permission entity by IDs.
func (m *AdminMutation) RemovePermissionCreatorIDs(ids ...int) {
	if m.removedpermission_creator == nil {
		m.removedpermission_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permission_creator, ids[i])
		m.removedpermission_creator[ids[i]] = struct{}{}
	}
}

// RemovedPermissionCreator returns the removed IDs of the "permission_creator" edge to the Permission entity.
func (m *AdminMutation) RemovedPermissionCreatorIDs() (ids []int) {
	for id := range m.removedpermission_creator {
		ids = append(ids, id)
	}
	return
}

// PermissionCreatorIDs returns the "permission_creator" edge IDs in the mutation.
func (m *AdminMutation) PermissionCreatorIDs() (ids []int) {
	for id := range m.permission_creator {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionCreator resets all changes to the "permission_creator" edge.
func (m *AdminMutation) ResetPermissionCreator() {
	m.permission_creator = nil
	m.clearedpermission_creator = false
	m.removedpermission_creator = nil
}

// AddPermissionUpdaterIDs adds the "permission_updater" edge to the Permission entity by ids.
func (m *AdminMutation) AddPermissionUpdaterIDs(ids ...int) {
	if m.permission_updater == nil {
		m.permission_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.permission_updater[ids[i]] = struct{}{}
	}
}

// ClearPermissionUpdater clears the "permission_updater" edge to the Permission entity.
func (m *AdminMutation) ClearPermissionUpdater() {
	m.clearedpermission_updater = true
}

// PermissionUpdaterCleared reports if the "permission_updater" edge to the Permission entity was cleared.
func (m *AdminMutation) PermissionUpdaterCleared() bool {
	return m.clearedpermission_updater
}

// RemovePermissionUpdaterIDs removes the "permission_updater" edge to the Permission entity by IDs.
func (m *AdminMutation) RemovePermissionUpdaterIDs(ids ...int) {
	if m.removedpermission_updater == nil {
		m.removedpermission_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permission_updater, ids[i])
		m.removedpermission_updater[ids[i]] = struct{}{}
	}
}

// RemovedPermissionUpdater returns the removed IDs of the "permission_updater" edge to the Permission entity.
func (m *AdminMutation) RemovedPermissionUpdaterIDs() (ids []int) {
	for id := range m.removedpermission_updater {
		ids = append(ids, id)
	}
	return
}

// PermissionUpdaterIDs returns the "permission_updater" edge IDs in the mutation.
func (m *AdminMutation) PermissionUpdaterIDs() (ids []int) {
	for id := range m.permission_updater {
		ids = append(ids, id)
	}
	return
}

// ResetPermissionUpdater resets all changes to the "permission_updater" edge.
func (m *AdminMutation) ResetPermissionUpdater() {
	m.permission_updater = nil
	m.clearedpermission_updater = false
	m.removedpermission_updater = nil
}

// AddRiskCreatorIDs adds the "risk_creator" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskCreatorIDs(ids ...int) {
	if m.risk_creator == nil {
		m.risk_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCreator clears the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) ClearRiskCreator() {
	m.clearedrisk_creator = true
}

// RiskCreatorCleared reports if the "risk_creator" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskCreatorCleared() bool {
	return m.clearedrisk_creator
}

// RemoveRiskCreatorIDs removes the "risk_creator" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskCreatorIDs(ids ...int) {
	if m.removedrisk_creator == nil {
		m.removedrisk_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_creator, ids[i])
		m.removedrisk_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCreator returns the removed IDs of the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskCreatorIDs() (ids []int) {
	for id := range m.removedrisk_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCreatorIDs returns the "risk_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCreatorIDs() (ids []int) {
	for id := range m.risk_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCreator resets all changes to the "risk_creator" edge.
func (m *AdminMutation) ResetRiskCreator() {
	m.risk_creator = nil
	m.clearedrisk_creator = false
	m.removedrisk_creator = nil
}

// AddRiskUpdaterIDs adds the "risk_updater" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskUpdaterIDs(ids ...int) {
	if m.risk_updater == nil {
		m.risk_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskUpdater clears the "risk_updater" edge to the Risk entity.
func (m *AdminMutation) ClearRiskUpdater() {
	m.clearedrisk_updater = true
}

// RiskUpdaterCleared reports if the "risk_updater" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskUpdaterCleared() bool {
	return m.clearedrisk_updater
}

// RemoveRiskUpdaterIDs removes the "risk_updater" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskUpdaterIDs(ids ...int) {
	if m.removedrisk_updater == nil {
		m.removedrisk_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_updater, ids[i])
		m.removedrisk_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskUpdater returns the removed IDs of the "risk_updater" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_updater {
		ids = append(ids, id)
	}
	return
}

// RiskUpdaterIDs returns the "risk_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskUpdaterIDs() (ids []int) {
	for id := range m.risk_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskUpdater resets all changes to the "risk_updater" edge.
func (m *AdminMutation) ResetRiskUpdater() {
	m.risk_updater = nil
	m.clearedrisk_updater = false
	m.removedrisk_updater = nil
}

// AddRiskMaintainerIDs adds the "risk_maintainer" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskMaintainerIDs(ids ...int) {
	if m.risk_maintainer == nil {
		m.risk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_maintainer[ids[i]] = struct{}{}
	}
}

// ClearRiskMaintainer clears the "risk_maintainer" edge to the Risk entity.
func (m *AdminMutation) ClearRiskMaintainer() {
	m.clearedrisk_maintainer = true
}

// RiskMaintainerCleared reports if the "risk_maintainer" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskMaintainerCleared() bool {
	return m.clearedrisk_maintainer
}

// RemoveRiskMaintainerIDs removes the "risk_maintainer" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskMaintainerIDs(ids ...int) {
	if m.removedrisk_maintainer == nil {
		m.removedrisk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_maintainer, ids[i])
		m.removedrisk_maintainer[ids[i]] = struct{}{}
	}
}

// RemovedRiskMaintainer returns the removed IDs of the "risk_maintainer" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskMaintainerIDs() (ids []int) {
	for id := range m.removedrisk_maintainer {
		ids = append(ids, id)
	}
	return
}

// RiskMaintainerIDs returns the "risk_maintainer" edge IDs in the mutation.
func (m *AdminMutation) RiskMaintainerIDs() (ids []int) {
	for id := range m.risk_maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetRiskMaintainer resets all changes to the "risk_maintainer" edge.
func (m *AdminMutation) ResetRiskMaintainer() {
	m.risk_maintainer = nil
	m.clearedrisk_maintainer = false
	m.removedrisk_maintainer = nil
}

// AddRiskLocationCreatorIDs adds the "risk_location_creator" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationCreatorIDs(ids ...int) {
	if m.risk_location_creator == nil {
		m.risk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationCreator clears the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationCreator() {
	m.clearedrisk_location_creator = true
}

// RiskLocationCreatorCleared reports if the "risk_location_creator" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationCreatorCleared() bool {
	return m.clearedrisk_location_creator
}

// RemoveRiskLocationCreatorIDs removes the "risk_location_creator" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationCreatorIDs(ids ...int) {
	if m.removedrisk_location_creator == nil {
		m.removedrisk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_creator, ids[i])
		m.removedrisk_location_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationCreator returns the removed IDs of the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationCreatorIDs() (ids []int) {
	for id := range m.removedrisk_location_creator {
		ids = append(ids, id)
	}
	return
}

// RiskLocationCreatorIDs returns the "risk_location_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationCreatorIDs() (ids []int) {
	for id := range m.risk_location_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationCreator resets all changes to the "risk_location_creator" edge.
func (m *AdminMutation) ResetRiskLocationCreator() {
	m.risk_location_creator = nil
	m.clearedrisk_location_creator = false
	m.removedrisk_location_creator = nil
}

// AddRiskLocationUpdaterIDs adds the "risk_location_updater" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationUpdaterIDs(ids ...int) {
	if m.risk_location_updater == nil {
		m.risk_location_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationUpdater clears the "risk_location_updater" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationUpdater() {
	m.clearedrisk_location_updater = true
}

// RiskLocationUpdaterCleared reports if the "risk_location_updater" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationUpdaterCleared() bool {
	return m.clearedrisk_location_updater
}

// RemoveRiskLocationUpdaterIDs removes the "risk_location_updater" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationUpdaterIDs(ids ...int) {
	if m.removedrisk_location_updater == nil {
		m.removedrisk_location_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_updater, ids[i])
		m.removedrisk_location_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationUpdater returns the removed IDs of the "risk_location_updater" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_location_updater {
		ids = append(ids, id)
	}
	return
}

// RiskLocationUpdaterIDs returns the "risk_location_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationUpdaterIDs() (ids []int) {
	for id := range m.risk_location_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationUpdater resets all changes to the "risk_location_updater" edge.
func (m *AdminMutation) ResetRiskLocationUpdater() {
	m.risk_location_updater = nil
	m.clearedrisk_location_updater = false
	m.removedrisk_location_updater = nil
}

// AddRiskCategoryCreatorIDs adds the "risk_category_creator" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryCreatorIDs(ids ...int) {
	if m.risk_category_creator == nil {
		m.risk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryCreator clears the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryCreator() {
	m.clearedrisk_category_creator = true
}

// RiskCategoryCreatorCleared reports if the "risk_category_creator" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryCreatorCleared() bool {
	return m.clearedrisk_category_creator
}

// RemoveRiskCategoryCreatorIDs removes the "risk_category_creator" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryCreatorIDs(ids ...int) {
	if m.removedrisk_category_creator == nil {
		m.removedrisk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_creator, ids[i])
		m.removedrisk_category_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryCreator returns the removed IDs of the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryCreatorIDs() (ids []int) {
	for id := range m.removedrisk_category_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryCreatorIDs returns the "risk_category_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryCreatorIDs() (ids []int) {
	for id := range m.risk_category_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryCreator resets all changes to the "risk_category_creator" edge.
func (m *AdminMutation) ResetRiskCategoryCreator() {
	m.risk_category_creator = nil
	m.clearedrisk_category_creator = false
	m.removedrisk_category_creator = nil
}

// AddRiskCategoryUpdaterIDs adds the "risk_category_updater" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryUpdaterIDs(ids ...int) {
	if m.risk_category_updater == nil {
		m.risk_category_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryUpdater clears the "risk_category_updater" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryUpdater() {
	m.clearedrisk_category_updater = true
}

// RiskCategoryUpdaterCleared reports if the "risk_category_updater" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryUpdaterCleared() bool {
	return m.clearedrisk_category_updater
}

// RemoveRiskCategoryUpdaterIDs removes the "risk_category_updater" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryUpdaterIDs(ids ...int) {
	if m.removedrisk_category_updater == nil {
		m.removedrisk_category_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_updater, ids[i])
		m.removedrisk_category_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryUpdater returns the removed IDs of the "risk_category_updater" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_category_updater {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryUpdaterIDs returns the "risk_category_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryUpdaterIDs() (ids []int) {
	for id := range m.risk_category_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryUpdater resets all changes to the "risk_category_updater" edge.
func (m *AdminMutation) ResetRiskCategoryUpdater() {
	m.risk_category_updater = nil
	m.clearedrisk_category_updater = false
	m.removedrisk_category_updater = nil
}

// AddDepartmentCreatorIDs adds the "department_creator" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentCreatorIDs(ids ...int) {
	if m.department_creator == nil {
		m.department_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.department_creator[ids[i]] = struct{}{}
	}
}

// ClearDepartmentCreator clears the "department_creator" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentCreator() {
	m.cleareddepartment_creator = true
}

// DepartmentCreatorCleared reports if the "department_creator" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentCreatorCleared() bool {
	return m.cleareddepartment_creator
}

// RemoveDepartmentCreatorIDs removes the "department_creator" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentCreatorIDs(ids ...int) {
	if m.removeddepartment_creator == nil {
		m.removeddepartment_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_creator, ids[i])
		m.removeddepartment_creator[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentCreator returns the removed IDs of the "department_creator" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentCreatorIDs() (ids []int) {
	for id := range m.removeddepartment_creator {
		ids = append(ids, id)
	}
	return
}

// DepartmentCreatorIDs returns the "department_creator" edge IDs in the mutation.
func (m *AdminMutation) DepartmentCreatorIDs() (ids []int) {
	for id := range m.department_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentCreator resets all changes to the "department_creator" edge.
func (m *AdminMutation) ResetDepartmentCreator() {
	m.department_creator = nil
	m.cleareddepartment_creator = false
	m.removeddepartment_creator = nil
}

// AddDepartmentUpdaterIDs adds the "department_updater" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentUpdaterIDs(ids ...int) {
	if m.department_updater == nil {
		m.department_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.department_updater[ids[i]] = struct{}{}
	}
}

// ClearDepartmentUpdater clears the "department_updater" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentUpdater() {
	m.cleareddepartment_updater = true
}

// DepartmentUpdaterCleared reports if the "department_updater" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentUpdaterCleared() bool {
	return m.cleareddepartment_updater
}

// RemoveDepartmentUpdaterIDs removes the "department_updater" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentUpdaterIDs(ids ...int) {
	if m.removeddepartment_updater == nil {
		m.removeddepartment_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_updater, ids[i])
		m.removeddepartment_updater[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentUpdater returns the removed IDs of the "department_updater" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentUpdaterIDs() (ids []int) {
	for id := range m.removeddepartment_updater {
		ids = append(ids, id)
	}
	return
}

// DepartmentUpdaterIDs returns the "department_updater" edge IDs in the mutation.
func (m *AdminMutation) DepartmentUpdaterIDs() (ids []int) {
	for id := range m.department_updater {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentUpdater resets all changes to the "department_updater" edge.
func (m *AdminMutation) ResetDepartmentUpdater() {
	m.department_updater = nil
	m.cleareddepartment_updater = false
	m.removeddepartment_updater = nil
}

// AddEmployeeCreatorIDs adds the "employee_creator" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeCreatorIDs(ids ...int) {
	if m.employee_creator == nil {
		m.employee_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_creator[ids[i]] = struct{}{}
	}
}

// ClearEmployeeCreator clears the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeCreator() {
	m.clearedemployee_creator = true
}

// EmployeeCreatorCleared reports if the "employee_creator" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeCreatorCleared() bool {
	return m.clearedemployee_creator
}

// RemoveEmployeeCreatorIDs removes the "employee_creator" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeCreatorIDs(ids ...int) {
	if m.removedemployee_creator == nil {
		m.removedemployee_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_creator, ids[i])
		m.removedemployee_creator[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeCreator returns the removed IDs of the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeCreatorIDs() (ids []int) {
	for id := range m.removedemployee_creator {
		ids = append(ids, id)
	}
	return
}

// EmployeeCreatorIDs returns the "employee_creator" edge IDs in the mutation.
func (m *AdminMutation) EmployeeCreatorIDs() (ids []int) {
	for id := range m.employee_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeCreator resets all changes to the "employee_creator" edge.
func (m *AdminMutation) ResetEmployeeCreator() {
	m.employee_creator = nil
	m.clearedemployee_creator = false
	m.removedemployee_creator = nil
}

// AddEmployeeUpdaterIDs adds the "employee_updater" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeUpdaterIDs(ids ...int) {
	if m.employee_updater == nil {
		m.employee_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_updater[ids[i]] = struct{}{}
	}
}

// ClearEmployeeUpdater clears the "employee_updater" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeUpdater() {
	m.clearedemployee_updater = true
}

// EmployeeUpdaterCleared reports if the "employee_updater" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeUpdaterCleared() bool {
	return m.clearedemployee_updater
}

// RemoveEmployeeUpdaterIDs removes the "employee_updater" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeUpdaterIDs(ids ...int) {
	if m.removedemployee_updater == nil {
		m.removedemployee_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_updater, ids[i])
		m.removedemployee_updater[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeUpdater returns the removed IDs of the "employee_updater" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeUpdaterIDs() (ids []int) {
	for id := range m.removedemployee_updater {
		ids = append(ids, id)
	}
	return
}

// EmployeeUpdaterIDs returns the "employee_updater" edge IDs in the mutation.
func (m *AdminMutation) EmployeeUpdaterIDs() (ids []int) {
	for id := range m.employee_updater {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeUpdater resets all changes to the "employee_updater" edge.
func (m *AdminMutation) ResetEmployeeUpdater() {
	m.employee_updater = nil
	m.clearedemployee_updater = false
	m.removedemployee_updater = nil
}

// SetEmployeeID sets the "employee" edge to the Employee entity by id.
func (m *AdminMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AdminMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the "employee" edge ID in the mutation.
func (m *AdminMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AdminMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddOccupationCreatorIDs adds the "occupation_creator" edge to the Occupation entity by ids.
func (m *AdminMutation) AddOccupationCreatorIDs(ids ...int) {
	if m.occupation_creator == nil {
		m.occupation_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.occupation_creator[ids[i]] = struct{}{}
	}
}

// ClearOccupationCreator clears the "occupation_creator" edge to the Occupation entity.
func (m *AdminMutation) ClearOccupationCreator() {
	m.clearedoccupation_creator = true
}

// OccupationCreatorCleared reports if the "occupation_creator" edge to the Occupation entity was cleared.
func (m *AdminMutation) OccupationCreatorCleared() bool {
	return m.clearedoccupation_creator
}

// RemoveOccupationCreatorIDs removes the "occupation_creator" edge to the Occupation entity by IDs.
func (m *AdminMutation) RemoveOccupationCreatorIDs(ids ...int) {
	if m.removedoccupation_creator == nil {
		m.removedoccupation_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupation_creator, ids[i])
		m.removedoccupation_creator[ids[i]] = struct{}{}
	}
}

// RemovedOccupationCreator returns the removed IDs of the "occupation_creator" edge to the Occupation entity.
func (m *AdminMutation) RemovedOccupationCreatorIDs() (ids []int) {
	for id := range m.removedoccupation_creator {
		ids = append(ids, id)
	}
	return
}

// OccupationCreatorIDs returns the "occupation_creator" edge IDs in the mutation.
func (m *AdminMutation) OccupationCreatorIDs() (ids []int) {
	for id := range m.occupation_creator {
		ids = append(ids, id)
	}
	return
}

// ResetOccupationCreator resets all changes to the "occupation_creator" edge.
func (m *AdminMutation) ResetOccupationCreator() {
	m.occupation_creator = nil
	m.clearedoccupation_creator = false
	m.removedoccupation_creator = nil
}

// AddOccupationUpdaterIDs adds the "occupation_updater" edge to the Occupation entity by ids.
func (m *AdminMutation) AddOccupationUpdaterIDs(ids ...int) {
	if m.occupation_updater == nil {
		m.occupation_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.occupation_updater[ids[i]] = struct{}{}
	}
}

// ClearOccupationUpdater clears the "occupation_updater" edge to the Occupation entity.
func (m *AdminMutation) ClearOccupationUpdater() {
	m.clearedoccupation_updater = true
}

// OccupationUpdaterCleared reports if the "occupation_updater" edge to the Occupation entity was cleared.
func (m *AdminMutation) OccupationUpdaterCleared() bool {
	return m.clearedoccupation_updater
}

// RemoveOccupationUpdaterIDs removes the "occupation_updater" edge to the Occupation entity by IDs.
func (m *AdminMutation) RemoveOccupationUpdaterIDs(ids ...int) {
	if m.removedoccupation_updater == nil {
		m.removedoccupation_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupation_updater, ids[i])
		m.removedoccupation_updater[ids[i]] = struct{}{}
	}
}

// RemovedOccupationUpdater returns the removed IDs of the "occupation_updater" edge to the Occupation entity.
func (m *AdminMutation) RemovedOccupationUpdaterIDs() (ids []int) {
	for id := range m.removedoccupation_updater {
		ids = append(ids, id)
	}
	return
}

// OccupationUpdaterIDs returns the "occupation_updater" edge IDs in the mutation.
func (m *AdminMutation) OccupationUpdaterIDs() (ids []int) {
	for id := range m.occupation_updater {
		ids = append(ids, id)
	}
	return
}

// ResetOccupationUpdater resets all changes to the "occupation_updater" edge.
func (m *AdminMutation) ResetOccupationUpdater() {
	m.occupation_updater = nil
	m.clearedoccupation_updater = false
	m.removedoccupation_updater = nil
}

// AddEventCreatorIDs adds the "event_creator" edge to the Event entity by ids.
func (m *AdminMutation) AddEventCreatorIDs(ids ...int) {
	if m.event_creator == nil {
		m.event_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.event_creator[ids[i]] = struct{}{}
	}
}

// ClearEventCreator clears the "event_creator" edge to the Event entity.
func (m *AdminMutation) ClearEventCreator() {
	m.clearedevent_creator = true
}

// EventCreatorCleared reports if the "event_creator" edge to the Event entity was cleared.
func (m *AdminMutation) EventCreatorCleared() bool {
	return m.clearedevent_creator
}

// RemoveEventCreatorIDs removes the "event_creator" edge to the Event entity by IDs.
func (m *AdminMutation) RemoveEventCreatorIDs(ids ...int) {
	if m.removedevent_creator == nil {
		m.removedevent_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_creator, ids[i])
		m.removedevent_creator[ids[i]] = struct{}{}
	}
}

// RemovedEventCreator returns the removed IDs of the "event_creator" edge to the Event entity.
func (m *AdminMutation) RemovedEventCreatorIDs() (ids []int) {
	for id := range m.removedevent_creator {
		ids = append(ids, id)
	}
	return
}

// EventCreatorIDs returns the "event_creator" edge IDs in the mutation.
func (m *AdminMutation) EventCreatorIDs() (ids []int) {
	for id := range m.event_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEventCreator resets all changes to the "event_creator" edge.
func (m *AdminMutation) ResetEventCreator() {
	m.event_creator = nil
	m.clearedevent_creator = false
	m.removedevent_creator = nil
}

// AddEventUpdaterIDs adds the "event_updater" edge to the Event entity by ids.
func (m *AdminMutation) AddEventUpdaterIDs(ids ...int) {
	if m.event_updater == nil {
		m.event_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.event_updater[ids[i]] = struct{}{}
	}
}

// ClearEventUpdater clears the "event_updater" edge to the Event entity.
func (m *AdminMutation) ClearEventUpdater() {
	m.clearedevent_updater = true
}

// EventUpdaterCleared reports if the "event_updater" edge to the Event entity was cleared.
func (m *AdminMutation) EventUpdaterCleared() bool {
	return m.clearedevent_updater
}

// RemoveEventUpdaterIDs removes the "event_updater" edge to the Event entity by IDs.
func (m *AdminMutation) RemoveEventUpdaterIDs(ids ...int) {
	if m.removedevent_updater == nil {
		m.removedevent_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_updater, ids[i])
		m.removedevent_updater[ids[i]] = struct{}{}
	}
}

// RemovedEventUpdater returns the removed IDs of the "event_updater" edge to the Event entity.
func (m *AdminMutation) RemovedEventUpdaterIDs() (ids []int) {
	for id := range m.removedevent_updater {
		ids = append(ids, id)
	}
	return
}

// EventUpdaterIDs returns the "event_updater" edge IDs in the mutation.
func (m *AdminMutation) EventUpdaterIDs() (ids []int) {
	for id := range m.event_updater {
		ids = append(ids, id)
	}
	return
}

// ResetEventUpdater resets all changes to the "event_updater" edge.
func (m *AdminMutation) ResetEventUpdater() {
	m.event_updater = nil
	m.clearedevent_updater = false
	m.removedevent_updater = nil
}

// AddVideoCreatorIDs adds the "video_creator" edge to the Video entity by ids.
func (m *AdminMutation) AddVideoCreatorIDs(ids ...int) {
	if m.video_creator == nil {
		m.video_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.video_creator[ids[i]] = struct{}{}
	}
}

// ClearVideoCreator clears the "video_creator" edge to the Video entity.
func (m *AdminMutation) ClearVideoCreator() {
	m.clearedvideo_creator = true
}

// VideoCreatorCleared reports if the "video_creator" edge to the Video entity was cleared.
func (m *AdminMutation) VideoCreatorCleared() bool {
	return m.clearedvideo_creator
}

// RemoveVideoCreatorIDs removes the "video_creator" edge to the Video entity by IDs.
func (m *AdminMutation) RemoveVideoCreatorIDs(ids ...int) {
	if m.removedvideo_creator == nil {
		m.removedvideo_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.video_creator, ids[i])
		m.removedvideo_creator[ids[i]] = struct{}{}
	}
}

// RemovedVideoCreator returns the removed IDs of the "video_creator" edge to the Video entity.
func (m *AdminMutation) RemovedVideoCreatorIDs() (ids []int) {
	for id := range m.removedvideo_creator {
		ids = append(ids, id)
	}
	return
}

// VideoCreatorIDs returns the "video_creator" edge IDs in the mutation.
func (m *AdminMutation) VideoCreatorIDs() (ids []int) {
	for id := range m.video_creator {
		ids = append(ids, id)
	}
	return
}

// ResetVideoCreator resets all changes to the "video_creator" edge.
func (m *AdminMutation) ResetVideoCreator() {
	m.video_creator = nil
	m.clearedvideo_creator = false
	m.removedvideo_creator = nil
}

// AddVideoUpdaterIDs adds the "video_updater" edge to the Video entity by ids.
func (m *AdminMutation) AddVideoUpdaterIDs(ids ...int) {
	if m.video_updater == nil {
		m.video_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.video_updater[ids[i]] = struct{}{}
	}
}

// ClearVideoUpdater clears the "video_updater" edge to the Video entity.
func (m *AdminMutation) ClearVideoUpdater() {
	m.clearedvideo_updater = true
}

// VideoUpdaterCleared reports if the "video_updater" edge to the Video entity was cleared.
func (m *AdminMutation) VideoUpdaterCleared() bool {
	return m.clearedvideo_updater
}

// RemoveVideoUpdaterIDs removes the "video_updater" edge to the Video entity by IDs.
func (m *AdminMutation) RemoveVideoUpdaterIDs(ids ...int) {
	if m.removedvideo_updater == nil {
		m.removedvideo_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.video_updater, ids[i])
		m.removedvideo_updater[ids[i]] = struct{}{}
	}
}

// RemovedVideoUpdater returns the removed IDs of the "video_updater" edge to the Video entity.
func (m *AdminMutation) RemovedVideoUpdaterIDs() (ids []int) {
	for id := range m.removedvideo_updater {
		ids = append(ids, id)
	}
	return
}

// VideoUpdaterIDs returns the "video_updater" edge IDs in the mutation.
func (m *AdminMutation) VideoUpdaterIDs() (ids []int) {
	for id := range m.video_updater {
		ids = append(ids, id)
	}
	return
}

// ResetVideoUpdater resets all changes to the "video_updater" edge.
func (m *AdminMutation) ResetVideoUpdater() {
	m.video_updater = nil
	m.clearedvideo_updater = false
	m.removedvideo_updater = nil
}

// AddAreaCreatorIDs adds the "area_creator" edge to the Area entity by ids.
func (m *AdminMutation) AddAreaCreatorIDs(ids ...int) {
	if m.area_creator == nil {
		m.area_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.area_creator[ids[i]] = struct{}{}
	}
}

// ClearAreaCreator clears the "area_creator" edge to the Area entity.
func (m *AdminMutation) ClearAreaCreator() {
	m.clearedarea_creator = true
}

// AreaCreatorCleared reports if the "area_creator" edge to the Area entity was cleared.
func (m *AdminMutation) AreaCreatorCleared() bool {
	return m.clearedarea_creator
}

// RemoveAreaCreatorIDs removes the "area_creator" edge to the Area entity by IDs.
func (m *AdminMutation) RemoveAreaCreatorIDs(ids ...int) {
	if m.removedarea_creator == nil {
		m.removedarea_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.area_creator, ids[i])
		m.removedarea_creator[ids[i]] = struct{}{}
	}
}

// RemovedAreaCreator returns the removed IDs of the "area_creator" edge to the Area entity.
func (m *AdminMutation) RemovedAreaCreatorIDs() (ids []int) {
	for id := range m.removedarea_creator {
		ids = append(ids, id)
	}
	return
}

// AreaCreatorIDs returns the "area_creator" edge IDs in the mutation.
func (m *AdminMutation) AreaCreatorIDs() (ids []int) {
	for id := range m.area_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAreaCreator resets all changes to the "area_creator" edge.
func (m *AdminMutation) ResetAreaCreator() {
	m.area_creator = nil
	m.clearedarea_creator = false
	m.removedarea_creator = nil
}

// AddAreaUpdaterIDs adds the "area_updater" edge to the Area entity by ids.
func (m *AdminMutation) AddAreaUpdaterIDs(ids ...int) {
	if m.area_updater == nil {
		m.area_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.area_updater[ids[i]] = struct{}{}
	}
}

// ClearAreaUpdater clears the "area_updater" edge to the Area entity.
func (m *AdminMutation) ClearAreaUpdater() {
	m.clearedarea_updater = true
}

// AreaUpdaterCleared reports if the "area_updater" edge to the Area entity was cleared.
func (m *AdminMutation) AreaUpdaterCleared() bool {
	return m.clearedarea_updater
}

// RemoveAreaUpdaterIDs removes the "area_updater" edge to the Area entity by IDs.
func (m *AdminMutation) RemoveAreaUpdaterIDs(ids ...int) {
	if m.removedarea_updater == nil {
		m.removedarea_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.area_updater, ids[i])
		m.removedarea_updater[ids[i]] = struct{}{}
	}
}

// RemovedAreaUpdater returns the removed IDs of the "area_updater" edge to the Area entity.
func (m *AdminMutation) RemovedAreaUpdaterIDs() (ids []int) {
	for id := range m.removedarea_updater {
		ids = append(ids, id)
	}
	return
}

// AreaUpdaterIDs returns the "area_updater" edge IDs in the mutation.
func (m *AdminMutation) AreaUpdaterIDs() (ids []int) {
	for id := range m.area_updater {
		ids = append(ids, id)
	}
	return
}

// ResetAreaUpdater resets all changes to the "area_updater" edge.
func (m *AdminMutation) ResetAreaUpdater() {
	m.area_updater = nil
	m.clearedarea_updater = false
	m.removedarea_updater = nil
}

// AddDeviceCreatorIDs adds the "device_creator" edge to the Device entity by ids.
func (m *AdminMutation) AddDeviceCreatorIDs(ids ...int) {
	if m.device_creator == nil {
		m.device_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.device_creator[ids[i]] = struct{}{}
	}
}

// ClearDeviceCreator clears the "device_creator" edge to the Device entity.
func (m *AdminMutation) ClearDeviceCreator() {
	m.cleareddevice_creator = true
}

// DeviceCreatorCleared reports if the "device_creator" edge to the Device entity was cleared.
func (m *AdminMutation) DeviceCreatorCleared() bool {
	return m.cleareddevice_creator
}

// RemoveDeviceCreatorIDs removes the "device_creator" edge to the Device entity by IDs.
func (m *AdminMutation) RemoveDeviceCreatorIDs(ids ...int) {
	if m.removeddevice_creator == nil {
		m.removeddevice_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_creator, ids[i])
		m.removeddevice_creator[ids[i]] = struct{}{}
	}
}

// RemovedDeviceCreator returns the removed IDs of the "device_creator" edge to the Device entity.
func (m *AdminMutation) RemovedDeviceCreatorIDs() (ids []int) {
	for id := range m.removeddevice_creator {
		ids = append(ids, id)
	}
	return
}

// DeviceCreatorIDs returns the "device_creator" edge IDs in the mutation.
func (m *AdminMutation) DeviceCreatorIDs() (ids []int) {
	for id := range m.device_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceCreator resets all changes to the "device_creator" edge.
func (m *AdminMutation) ResetDeviceCreator() {
	m.device_creator = nil
	m.cleareddevice_creator = false
	m.removeddevice_creator = nil
}

// AddDeviceUpdaterIDs adds the "device_updater" edge to the Device entity by ids.
func (m *AdminMutation) AddDeviceUpdaterIDs(ids ...int) {
	if m.device_updater == nil {
		m.device_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.device_updater[ids[i]] = struct{}{}
	}
}

// ClearDeviceUpdater clears the "device_updater" edge to the Device entity.
func (m *AdminMutation) ClearDeviceUpdater() {
	m.cleareddevice_updater = true
}

// DeviceUpdaterCleared reports if the "device_updater" edge to the Device entity was cleared.
func (m *AdminMutation) DeviceUpdaterCleared() bool {
	return m.cleareddevice_updater
}

// RemoveDeviceUpdaterIDs removes the "device_updater" edge to the Device entity by IDs.
func (m *AdminMutation) RemoveDeviceUpdaterIDs(ids ...int) {
	if m.removeddevice_updater == nil {
		m.removeddevice_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_updater, ids[i])
		m.removeddevice_updater[ids[i]] = struct{}{}
	}
}

// RemovedDeviceUpdater returns the removed IDs of the "device_updater" edge to the Device entity.
func (m *AdminMutation) RemovedDeviceUpdaterIDs() (ids []int) {
	for id := range m.removeddevice_updater {
		ids = append(ids, id)
	}
	return
}

// DeviceUpdaterIDs returns the "device_updater" edge IDs in the mutation.
func (m *AdminMutation) DeviceUpdaterIDs() (ids []int) {
	for id := range m.device_updater {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceUpdater resets all changes to the "device_updater" edge.
func (m *AdminMutation) ResetDeviceUpdater() {
	m.device_updater = nil
	m.cleareddevice_updater = false
	m.removeddevice_updater = nil
}

// AddDeviceInstallationCreatorIDs adds the "device_installation_creator" edge to the DeviceInstallation entity by ids.
func (m *AdminMutation) AddDeviceInstallationCreatorIDs(ids ...int) {
	if m.device_installation_creator == nil {
		m.device_installation_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation_creator[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallationCreator clears the "device_installation_creator" edge to the DeviceInstallation entity.
func (m *AdminMutation) ClearDeviceInstallationCreator() {
	m.cleareddevice_installation_creator = true
}

// DeviceInstallationCreatorCleared reports if the "device_installation_creator" edge to the DeviceInstallation entity was cleared.
func (m *AdminMutation) DeviceInstallationCreatorCleared() bool {
	return m.cleareddevice_installation_creator
}

// RemoveDeviceInstallationCreatorIDs removes the "device_installation_creator" edge to the DeviceInstallation entity by IDs.
func (m *AdminMutation) RemoveDeviceInstallationCreatorIDs(ids ...int) {
	if m.removeddevice_installation_creator == nil {
		m.removeddevice_installation_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation_creator, ids[i])
		m.removeddevice_installation_creator[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallationCreator returns the removed IDs of the "device_installation_creator" edge to the DeviceInstallation entity.
func (m *AdminMutation) RemovedDeviceInstallationCreatorIDs() (ids []int) {
	for id := range m.removeddevice_installation_creator {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationCreatorIDs returns the "device_installation_creator" edge IDs in the mutation.
func (m *AdminMutation) DeviceInstallationCreatorIDs() (ids []int) {
	for id := range m.device_installation_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallationCreator resets all changes to the "device_installation_creator" edge.
func (m *AdminMutation) ResetDeviceInstallationCreator() {
	m.device_installation_creator = nil
	m.cleareddevice_installation_creator = false
	m.removeddevice_installation_creator = nil
}

// AddDeviceInstallationUpdaterIDs adds the "device_installation_updater" edge to the DeviceInstallation entity by ids.
func (m *AdminMutation) AddDeviceInstallationUpdaterIDs(ids ...int) {
	if m.device_installation_updater == nil {
		m.device_installation_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation_updater[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallationUpdater clears the "device_installation_updater" edge to the DeviceInstallation entity.
func (m *AdminMutation) ClearDeviceInstallationUpdater() {
	m.cleareddevice_installation_updater = true
}

// DeviceInstallationUpdaterCleared reports if the "device_installation_updater" edge to the DeviceInstallation entity was cleared.
func (m *AdminMutation) DeviceInstallationUpdaterCleared() bool {
	return m.cleareddevice_installation_updater
}

// RemoveDeviceInstallationUpdaterIDs removes the "device_installation_updater" edge to the DeviceInstallation entity by IDs.
func (m *AdminMutation) RemoveDeviceInstallationUpdaterIDs(ids ...int) {
	if m.removeddevice_installation_updater == nil {
		m.removeddevice_installation_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation_updater, ids[i])
		m.removeddevice_installation_updater[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallationUpdater returns the removed IDs of the "device_installation_updater" edge to the DeviceInstallation entity.
func (m *AdminMutation) RemovedDeviceInstallationUpdaterIDs() (ids []int) {
	for id := range m.removeddevice_installation_updater {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationUpdaterIDs returns the "device_installation_updater" edge IDs in the mutation.
func (m *AdminMutation) DeviceInstallationUpdaterIDs() (ids []int) {
	for id := range m.device_installation_updater {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallationUpdater resets all changes to the "device_installation_updater" edge.
func (m *AdminMutation) ResetDeviceInstallationUpdater() {
	m.device_installation_updater = nil
	m.cleareddevice_installation_updater = false
	m.removeddevice_installation_updater = nil
}

// AddEventLevelCreatorIDs adds the "event_level_creator" edge to the EventLevel entity by ids.
func (m *AdminMutation) AddEventLevelCreatorIDs(ids ...int) {
	if m.event_level_creator == nil {
		m.event_level_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.event_level_creator[ids[i]] = struct{}{}
	}
}

// ClearEventLevelCreator clears the "event_level_creator" edge to the EventLevel entity.
func (m *AdminMutation) ClearEventLevelCreator() {
	m.clearedevent_level_creator = true
}

// EventLevelCreatorCleared reports if the "event_level_creator" edge to the EventLevel entity was cleared.
func (m *AdminMutation) EventLevelCreatorCleared() bool {
	return m.clearedevent_level_creator
}

// RemoveEventLevelCreatorIDs removes the "event_level_creator" edge to the EventLevel entity by IDs.
func (m *AdminMutation) RemoveEventLevelCreatorIDs(ids ...int) {
	if m.removedevent_level_creator == nil {
		m.removedevent_level_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_level_creator, ids[i])
		m.removedevent_level_creator[ids[i]] = struct{}{}
	}
}

// RemovedEventLevelCreator returns the removed IDs of the "event_level_creator" edge to the EventLevel entity.
func (m *AdminMutation) RemovedEventLevelCreatorIDs() (ids []int) {
	for id := range m.removedevent_level_creator {
		ids = append(ids, id)
	}
	return
}

// EventLevelCreatorIDs returns the "event_level_creator" edge IDs in the mutation.
func (m *AdminMutation) EventLevelCreatorIDs() (ids []int) {
	for id := range m.event_level_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEventLevelCreator resets all changes to the "event_level_creator" edge.
func (m *AdminMutation) ResetEventLevelCreator() {
	m.event_level_creator = nil
	m.clearedevent_level_creator = false
	m.removedevent_level_creator = nil
}

// AddEventLevelUpdaterIDs adds the "event_level_updater" edge to the EventLevel entity by ids.
func (m *AdminMutation) AddEventLevelUpdaterIDs(ids ...int) {
	if m.event_level_updater == nil {
		m.event_level_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.event_level_updater[ids[i]] = struct{}{}
	}
}

// ClearEventLevelUpdater clears the "event_level_updater" edge to the EventLevel entity.
func (m *AdminMutation) ClearEventLevelUpdater() {
	m.clearedevent_level_updater = true
}

// EventLevelUpdaterCleared reports if the "event_level_updater" edge to the EventLevel entity was cleared.
func (m *AdminMutation) EventLevelUpdaterCleared() bool {
	return m.clearedevent_level_updater
}

// RemoveEventLevelUpdaterIDs removes the "event_level_updater" edge to the EventLevel entity by IDs.
func (m *AdminMutation) RemoveEventLevelUpdaterIDs(ids ...int) {
	if m.removedevent_level_updater == nil {
		m.removedevent_level_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_level_updater, ids[i])
		m.removedevent_level_updater[ids[i]] = struct{}{}
	}
}

// RemovedEventLevelUpdater returns the removed IDs of the "event_level_updater" edge to the EventLevel entity.
func (m *AdminMutation) RemovedEventLevelUpdaterIDs() (ids []int) {
	for id := range m.removedevent_level_updater {
		ids = append(ids, id)
	}
	return
}

// EventLevelUpdaterIDs returns the "event_level_updater" edge IDs in the mutation.
func (m *AdminMutation) EventLevelUpdaterIDs() (ids []int) {
	for id := range m.event_level_updater {
		ids = append(ids, id)
	}
	return
}

// ResetEventLevelUpdater resets all changes to the "event_level_updater" edge.
func (m *AdminMutation) ResetEventLevelUpdater() {
	m.event_level_updater = nil
	m.clearedevent_level_updater = false
	m.removedevent_level_updater = nil
}

// AddFixingCreatorIDs adds the "fixing_creator" edge to the Fixing entity by ids.
func (m *AdminMutation) AddFixingCreatorIDs(ids ...int) {
	if m.fixing_creator == nil {
		m.fixing_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.fixing_creator[ids[i]] = struct{}{}
	}
}

// ClearFixingCreator clears the "fixing_creator" edge to the Fixing entity.
func (m *AdminMutation) ClearFixingCreator() {
	m.clearedfixing_creator = true
}

// FixingCreatorCleared reports if the "fixing_creator" edge to the Fixing entity was cleared.
func (m *AdminMutation) FixingCreatorCleared() bool {
	return m.clearedfixing_creator
}

// RemoveFixingCreatorIDs removes the "fixing_creator" edge to the Fixing entity by IDs.
func (m *AdminMutation) RemoveFixingCreatorIDs(ids ...int) {
	if m.removedfixing_creator == nil {
		m.removedfixing_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixing_creator, ids[i])
		m.removedfixing_creator[ids[i]] = struct{}{}
	}
}

// RemovedFixingCreator returns the removed IDs of the "fixing_creator" edge to the Fixing entity.
func (m *AdminMutation) RemovedFixingCreatorIDs() (ids []int) {
	for id := range m.removedfixing_creator {
		ids = append(ids, id)
	}
	return
}

// FixingCreatorIDs returns the "fixing_creator" edge IDs in the mutation.
func (m *AdminMutation) FixingCreatorIDs() (ids []int) {
	for id := range m.fixing_creator {
		ids = append(ids, id)
	}
	return
}

// ResetFixingCreator resets all changes to the "fixing_creator" edge.
func (m *AdminMutation) ResetFixingCreator() {
	m.fixing_creator = nil
	m.clearedfixing_creator = false
	m.removedfixing_creator = nil
}

// AddFixingUpdaterIDs adds the "fixing_updater" edge to the Fixing entity by ids.
func (m *AdminMutation) AddFixingUpdaterIDs(ids ...int) {
	if m.fixing_updater == nil {
		m.fixing_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.fixing_updater[ids[i]] = struct{}{}
	}
}

// ClearFixingUpdater clears the "fixing_updater" edge to the Fixing entity.
func (m *AdminMutation) ClearFixingUpdater() {
	m.clearedfixing_updater = true
}

// FixingUpdaterCleared reports if the "fixing_updater" edge to the Fixing entity was cleared.
func (m *AdminMutation) FixingUpdaterCleared() bool {
	return m.clearedfixing_updater
}

// RemoveFixingUpdaterIDs removes the "fixing_updater" edge to the Fixing entity by IDs.
func (m *AdminMutation) RemoveFixingUpdaterIDs(ids ...int) {
	if m.removedfixing_updater == nil {
		m.removedfixing_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixing_updater, ids[i])
		m.removedfixing_updater[ids[i]] = struct{}{}
	}
}

// RemovedFixingUpdater returns the removed IDs of the "fixing_updater" edge to the Fixing entity.
func (m *AdminMutation) RemovedFixingUpdaterIDs() (ids []int) {
	for id := range m.removedfixing_updater {
		ids = append(ids, id)
	}
	return
}

// FixingUpdaterIDs returns the "fixing_updater" edge IDs in the mutation.
func (m *AdminMutation) FixingUpdaterIDs() (ids []int) {
	for id := range m.fixing_updater {
		ids = append(ids, id)
	}
	return
}

// ResetFixingUpdater resets all changes to the "fixing_updater" edge.
func (m *AdminMutation) ResetFixingUpdater() {
	m.fixing_updater = nil
	m.clearedfixing_updater = false
	m.removedfixing_updater = nil
}

// AddFixerIDs adds the "fixer" edge to the Fixing entity by ids.
func (m *AdminMutation) AddFixerIDs(ids ...int) {
	if m.fixer == nil {
		m.fixer = make(map[int]struct{})
	}
	for i := range ids {
		m.fixer[ids[i]] = struct{}{}
	}
}

// ClearFixer clears the "fixer" edge to the Fixing entity.
func (m *AdminMutation) ClearFixer() {
	m.clearedfixer = true
}

// FixerCleared reports if the "fixer" edge to the Fixing entity was cleared.
func (m *AdminMutation) FixerCleared() bool {
	return m.clearedfixer
}

// RemoveFixerIDs removes the "fixer" edge to the Fixing entity by IDs.
func (m *AdminMutation) RemoveFixerIDs(ids ...int) {
	if m.removedfixer == nil {
		m.removedfixer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixer, ids[i])
		m.removedfixer[ids[i]] = struct{}{}
	}
}

// RemovedFixer returns the removed IDs of the "fixer" edge to the Fixing entity.
func (m *AdminMutation) RemovedFixerIDs() (ids []int) {
	for id := range m.removedfixer {
		ids = append(ids, id)
	}
	return
}

// FixerIDs returns the "fixer" edge IDs in the mutation.
func (m *AdminMutation) FixerIDs() (ids []int) {
	for id := range m.fixer {
		ids = append(ids, id)
	}
	return
}

// ResetFixer resets all changes to the "fixer" edge.
func (m *AdminMutation) ResetFixer() {
	m.fixer = nil
	m.clearedfixer = false
	m.removedfixer = nil
}

// AddEventLogCreatorIDs adds the "event_log_creator" edge to the EventLog entity by ids.
func (m *AdminMutation) AddEventLogCreatorIDs(ids ...int) {
	if m.event_log_creator == nil {
		m.event_log_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.event_log_creator[ids[i]] = struct{}{}
	}
}

// ClearEventLogCreator clears the "event_log_creator" edge to the EventLog entity.
func (m *AdminMutation) ClearEventLogCreator() {
	m.clearedevent_log_creator = true
}

// EventLogCreatorCleared reports if the "event_log_creator" edge to the EventLog entity was cleared.
func (m *AdminMutation) EventLogCreatorCleared() bool {
	return m.clearedevent_log_creator
}

// RemoveEventLogCreatorIDs removes the "event_log_creator" edge to the EventLog entity by IDs.
func (m *AdminMutation) RemoveEventLogCreatorIDs(ids ...int) {
	if m.removedevent_log_creator == nil {
		m.removedevent_log_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_log_creator, ids[i])
		m.removedevent_log_creator[ids[i]] = struct{}{}
	}
}

// RemovedEventLogCreator returns the removed IDs of the "event_log_creator" edge to the EventLog entity.
func (m *AdminMutation) RemovedEventLogCreatorIDs() (ids []int) {
	for id := range m.removedevent_log_creator {
		ids = append(ids, id)
	}
	return
}

// EventLogCreatorIDs returns the "event_log_creator" edge IDs in the mutation.
func (m *AdminMutation) EventLogCreatorIDs() (ids []int) {
	for id := range m.event_log_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEventLogCreator resets all changes to the "event_log_creator" edge.
func (m *AdminMutation) ResetEventLogCreator() {
	m.event_log_creator = nil
	m.clearedevent_log_creator = false
	m.removedevent_log_creator = nil
}

// AddEventLogUpdaterIDs adds the "event_log_updater" edge to the EventLog entity by ids.
func (m *AdminMutation) AddEventLogUpdaterIDs(ids ...int) {
	if m.event_log_updater == nil {
		m.event_log_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.event_log_updater[ids[i]] = struct{}{}
	}
}

// ClearEventLogUpdater clears the "event_log_updater" edge to the EventLog entity.
func (m *AdminMutation) ClearEventLogUpdater() {
	m.clearedevent_log_updater = true
}

// EventLogUpdaterCleared reports if the "event_log_updater" edge to the EventLog entity was cleared.
func (m *AdminMutation) EventLogUpdaterCleared() bool {
	return m.clearedevent_log_updater
}

// RemoveEventLogUpdaterIDs removes the "event_log_updater" edge to the EventLog entity by IDs.
func (m *AdminMutation) RemoveEventLogUpdaterIDs(ids ...int) {
	if m.removedevent_log_updater == nil {
		m.removedevent_log_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_log_updater, ids[i])
		m.removedevent_log_updater[ids[i]] = struct{}{}
	}
}

// RemovedEventLogUpdater returns the removed IDs of the "event_log_updater" edge to the EventLog entity.
func (m *AdminMutation) RemovedEventLogUpdaterIDs() (ids []int) {
	for id := range m.removedevent_log_updater {
		ids = append(ids, id)
	}
	return
}

// EventLogUpdaterIDs returns the "event_log_updater" edge IDs in the mutation.
func (m *AdminMutation) EventLogUpdaterIDs() (ids []int) {
	for id := range m.event_log_updater {
		ids = append(ids, id)
	}
	return
}

// ResetEventLogUpdater resets all changes to the "event_log_updater" edge.
func (m *AdminMutation) ResetEventLogUpdater() {
	m.event_log_updater = nil
	m.clearedevent_log_updater = false
	m.removedevent_log_updater = nil
}

// AddEventLogActorIDs adds the "event_log_actor" edge to the EventLog entity by ids.
func (m *AdminMutation) AddEventLogActorIDs(ids ...int) {
	if m.event_log_actor == nil {
		m.event_log_actor = make(map[int]struct{})
	}
	for i := range ids {
		m.event_log_actor[ids[i]] = struct{}{}
	}
}

// ClearEventLogActor clears the "event_log_actor" edge to the EventLog entity.
func (m *AdminMutation) ClearEventLogActor() {
	m.clearedevent_log_actor = true
}

// EventLogActorCleared reports if the "event_log_actor" edge to the EventLog entity was cleared.
func (m *AdminMutation) EventLogActorCleared() bool {
	return m.clearedevent_log_actor
}

// RemoveEventLogActorIDs removes the "event_log_actor" edge to the EventLog entity by IDs.
func (m *AdminMutation) RemoveEventLogActorIDs(ids ...int) {
	if m.removedevent_log_actor == nil {
		m.removedevent_log_actor = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_log_actor, ids[i])
		m.removedevent_log_actor[ids[i]] = struct{}{}
	}
}

// RemovedEventLogActor returns the removed IDs of the "event_log_actor" edge to the EventLog entity.
func (m *AdminMutation) RemovedEventLogActorIDs() (ids []int) {
	for id := range m.removedevent_log_actor {
		ids = append(ids, id)
	}
	return
}

// EventLogActorIDs returns the "event_log_actor" edge IDs in the mutation.
func (m *AdminMutation) EventLogActorIDs() (ids []int) {
	for id := range m.event_log_actor {
		ids = append(ids, id)
	}
	return
}

// ResetEventLogActor resets all changes to the "event_log_actor" edge.
func (m *AdminMutation) ResetEventLogActor() {
	m.event_log_actor = nil
	m.clearedevent_log_actor = false
	m.removedevent_log_actor = nil
}

// AddEventLogActor2IDs adds the "event_log_actor2" edge to the EventLog entity by ids.
func (m *AdminMutation) AddEventLogActor2IDs(ids ...int) {
	if m.event_log_actor2 == nil {
		m.event_log_actor2 = make(map[int]struct{})
	}
	for i := range ids {
		m.event_log_actor2[ids[i]] = struct{}{}
	}
}

// ClearEventLogActor2 clears the "event_log_actor2" edge to the EventLog entity.
func (m *AdminMutation) ClearEventLogActor2() {
	m.clearedevent_log_actor2 = true
}

// EventLogActor2Cleared reports if the "event_log_actor2" edge to the EventLog entity was cleared.
func (m *AdminMutation) EventLogActor2Cleared() bool {
	return m.clearedevent_log_actor2
}

// RemoveEventLogActor2IDs removes the "event_log_actor2" edge to the EventLog entity by IDs.
func (m *AdminMutation) RemoveEventLogActor2IDs(ids ...int) {
	if m.removedevent_log_actor2 == nil {
		m.removedevent_log_actor2 = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_log_actor2, ids[i])
		m.removedevent_log_actor2[ids[i]] = struct{}{}
	}
}

// RemovedEventLogActor2 returns the removed IDs of the "event_log_actor2" edge to the EventLog entity.
func (m *AdminMutation) RemovedEventLogActor2IDs() (ids []int) {
	for id := range m.removedevent_log_actor2 {
		ids = append(ids, id)
	}
	return
}

// EventLogActor2IDs returns the "event_log_actor2" edge IDs in the mutation.
func (m *AdminMutation) EventLogActor2IDs() (ids []int) {
	for id := range m.event_log_actor2 {
		ids = append(ids, id)
	}
	return
}

// ResetEventLogActor2 resets all changes to the "event_log_actor2" edge.
func (m *AdminMutation) ResetEventLogActor2() {
	m.event_log_actor2 = nil
	m.clearedevent_log_actor2 = false
	m.removedevent_log_actor2 = nil
}

// AddSweepCreatorIDs adds the "sweep_creator" edge to the Sweep entity by ids.
func (m *AdminMutation) AddSweepCreatorIDs(ids ...int) {
	if m.sweep_creator == nil {
		m.sweep_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_creator[ids[i]] = struct{}{}
	}
}

// ClearSweepCreator clears the "sweep_creator" edge to the Sweep entity.
func (m *AdminMutation) ClearSweepCreator() {
	m.clearedsweep_creator = true
}

// SweepCreatorCleared reports if the "sweep_creator" edge to the Sweep entity was cleared.
func (m *AdminMutation) SweepCreatorCleared() bool {
	return m.clearedsweep_creator
}

// RemoveSweepCreatorIDs removes the "sweep_creator" edge to the Sweep entity by IDs.
func (m *AdminMutation) RemoveSweepCreatorIDs(ids ...int) {
	if m.removedsweep_creator == nil {
		m.removedsweep_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_creator, ids[i])
		m.removedsweep_creator[ids[i]] = struct{}{}
	}
}

// RemovedSweepCreator returns the removed IDs of the "sweep_creator" edge to the Sweep entity.
func (m *AdminMutation) RemovedSweepCreatorIDs() (ids []int) {
	for id := range m.removedsweep_creator {
		ids = append(ids, id)
	}
	return
}

// SweepCreatorIDs returns the "sweep_creator" edge IDs in the mutation.
func (m *AdminMutation) SweepCreatorIDs() (ids []int) {
	for id := range m.sweep_creator {
		ids = append(ids, id)
	}
	return
}

// ResetSweepCreator resets all changes to the "sweep_creator" edge.
func (m *AdminMutation) ResetSweepCreator() {
	m.sweep_creator = nil
	m.clearedsweep_creator = false
	m.removedsweep_creator = nil
}

// AddSweepUpdaterIDs adds the "sweep_updater" edge to the Sweep entity by ids.
func (m *AdminMutation) AddSweepUpdaterIDs(ids ...int) {
	if m.sweep_updater == nil {
		m.sweep_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_updater[ids[i]] = struct{}{}
	}
}

// ClearSweepUpdater clears the "sweep_updater" edge to the Sweep entity.
func (m *AdminMutation) ClearSweepUpdater() {
	m.clearedsweep_updater = true
}

// SweepUpdaterCleared reports if the "sweep_updater" edge to the Sweep entity was cleared.
func (m *AdminMutation) SweepUpdaterCleared() bool {
	return m.clearedsweep_updater
}

// RemoveSweepUpdaterIDs removes the "sweep_updater" edge to the Sweep entity by IDs.
func (m *AdminMutation) RemoveSweepUpdaterIDs(ids ...int) {
	if m.removedsweep_updater == nil {
		m.removedsweep_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_updater, ids[i])
		m.removedsweep_updater[ids[i]] = struct{}{}
	}
}

// RemovedSweepUpdater returns the removed IDs of the "sweep_updater" edge to the Sweep entity.
func (m *AdminMutation) RemovedSweepUpdaterIDs() (ids []int) {
	for id := range m.removedsweep_updater {
		ids = append(ids, id)
	}
	return
}

// SweepUpdaterIDs returns the "sweep_updater" edge IDs in the mutation.
func (m *AdminMutation) SweepUpdaterIDs() (ids []int) {
	for id := range m.sweep_updater {
		ids = append(ids, id)
	}
	return
}

// ResetSweepUpdater resets all changes to the "sweep_updater" edge.
func (m *AdminMutation) ResetSweepUpdater() {
	m.sweep_updater = nil
	m.clearedsweep_updater = false
	m.removedsweep_updater = nil
}

// AddSweepScheduleCreatorIDs adds the "sweep_schedule_creator" edge to the SweepSchedule entity by ids.
func (m *AdminMutation) AddSweepScheduleCreatorIDs(ids ...int) {
	if m.sweep_schedule_creator == nil {
		m.sweep_schedule_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_schedule_creator[ids[i]] = struct{}{}
	}
}

// ClearSweepScheduleCreator clears the "sweep_schedule_creator" edge to the SweepSchedule entity.
func (m *AdminMutation) ClearSweepScheduleCreator() {
	m.clearedsweep_schedule_creator = true
}

// SweepScheduleCreatorCleared reports if the "sweep_schedule_creator" edge to the SweepSchedule entity was cleared.
func (m *AdminMutation) SweepScheduleCreatorCleared() bool {
	return m.clearedsweep_schedule_creator
}

// RemoveSweepScheduleCreatorIDs removes the "sweep_schedule_creator" edge to the SweepSchedule entity by IDs.
func (m *AdminMutation) RemoveSweepScheduleCreatorIDs(ids ...int) {
	if m.removedsweep_schedule_creator == nil {
		m.removedsweep_schedule_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_schedule_creator, ids[i])
		m.removedsweep_schedule_creator[ids[i]] = struct{}{}
	}
}

// RemovedSweepScheduleCreator returns the removed IDs of the "sweep_schedule_creator" edge to the SweepSchedule entity.
func (m *AdminMutation) RemovedSweepScheduleCreatorIDs() (ids []int) {
	for id := range m.removedsweep_schedule_creator {
		ids = append(ids, id)
	}
	return
}

// SweepScheduleCreatorIDs returns the "sweep_schedule_creator" edge IDs in the mutation.
func (m *AdminMutation) SweepScheduleCreatorIDs() (ids []int) {
	for id := range m.sweep_schedule_creator {
		ids = append(ids, id)
	}
	return
}

// ResetSweepScheduleCreator resets all changes to the "sweep_schedule_creator" edge.
func (m *AdminMutation) ResetSweepScheduleCreator() {
	m.sweep_schedule_creator = nil
	m.clearedsweep_schedule_creator = false
	m.removedsweep_schedule_creator = nil
}

// AddSweepScheduleUpdaterIDs adds the "sweep_schedule_updater" edge to the SweepSchedule entity by ids.
func (m *AdminMutation) AddSweepScheduleUpdaterIDs(ids ...int) {
	if m.sweep_schedule_updater == nil {
		m.sweep_schedule_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_schedule_updater[ids[i]] = struct{}{}
	}
}

// ClearSweepScheduleUpdater clears the "sweep_schedule_updater" edge to the SweepSchedule entity.
func (m *AdminMutation) ClearSweepScheduleUpdater() {
	m.clearedsweep_schedule_updater = true
}

// SweepScheduleUpdaterCleared reports if the "sweep_schedule_updater" edge to the SweepSchedule entity was cleared.
func (m *AdminMutation) SweepScheduleUpdaterCleared() bool {
	return m.clearedsweep_schedule_updater
}

// RemoveSweepScheduleUpdaterIDs removes the "sweep_schedule_updater" edge to the SweepSchedule entity by IDs.
func (m *AdminMutation) RemoveSweepScheduleUpdaterIDs(ids ...int) {
	if m.removedsweep_schedule_updater == nil {
		m.removedsweep_schedule_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_schedule_updater, ids[i])
		m.removedsweep_schedule_updater[ids[i]] = struct{}{}
	}
}

// RemovedSweepScheduleUpdater returns the removed IDs of the "sweep_schedule_updater" edge to the SweepSchedule entity.
func (m *AdminMutation) RemovedSweepScheduleUpdaterIDs() (ids []int) {
	for id := range m.removedsweep_schedule_updater {
		ids = append(ids, id)
	}
	return
}

// SweepScheduleUpdaterIDs returns the "sweep_schedule_updater" edge IDs in the mutation.
func (m *AdminMutation) SweepScheduleUpdaterIDs() (ids []int) {
	for id := range m.sweep_schedule_updater {
		ids = append(ids, id)
	}
	return
}

// ResetSweepScheduleUpdater resets all changes to the "sweep_schedule_updater" edge.
func (m *AdminMutation) ResetSweepScheduleUpdater() {
	m.sweep_schedule_updater = nil
	m.clearedsweep_schedule_updater = false
	m.removedsweep_schedule_updater = nil
}

// AddSweepScheduleIDs adds the "sweep_schedule" edge to the SweepSchedule entity by ids.
func (m *AdminMutation) AddSweepScheduleIDs(ids ...int) {
	if m.sweep_schedule == nil {
		m.sweep_schedule = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_schedule[ids[i]] = struct{}{}
	}
}

// ClearSweepSchedule clears the "sweep_schedule" edge to the SweepSchedule entity.
func (m *AdminMutation) ClearSweepSchedule() {
	m.clearedsweep_schedule = true
}

// SweepScheduleCleared reports if the "sweep_schedule" edge to the SweepSchedule entity was cleared.
func (m *AdminMutation) SweepScheduleCleared() bool {
	return m.clearedsweep_schedule
}

// RemoveSweepScheduleIDs removes the "sweep_schedule" edge to the SweepSchedule entity by IDs.
func (m *AdminMutation) RemoveSweepScheduleIDs(ids ...int) {
	if m.removedsweep_schedule == nil {
		m.removedsweep_schedule = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_schedule, ids[i])
		m.removedsweep_schedule[ids[i]] = struct{}{}
	}
}

// RemovedSweepSchedule returns the removed IDs of the "sweep_schedule" edge to the SweepSchedule entity.
func (m *AdminMutation) RemovedSweepScheduleIDs() (ids []int) {
	for id := range m.removedsweep_schedule {
		ids = append(ids, id)
	}
	return
}

// SweepScheduleIDs returns the "sweep_schedule" edge IDs in the mutation.
func (m *AdminMutation) SweepScheduleIDs() (ids []int) {
	for id := range m.sweep_schedule {
		ids = append(ids, id)
	}
	return
}

// ResetSweepSchedule resets all changes to the "sweep_schedule" edge.
func (m *AdminMutation) ResetSweepSchedule() {
	m.sweep_schedule = nil
	m.clearedsweep_schedule = false
	m.removedsweep_schedule = nil
}

// AddSweepResultCreatorIDs adds the "sweep_result_creator" edge to the SweepResult entity by ids.
func (m *AdminMutation) AddSweepResultCreatorIDs(ids ...int) {
	if m.sweep_result_creator == nil {
		m.sweep_result_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result_creator[ids[i]] = struct{}{}
	}
}

// ClearSweepResultCreator clears the "sweep_result_creator" edge to the SweepResult entity.
func (m *AdminMutation) ClearSweepResultCreator() {
	m.clearedsweep_result_creator = true
}

// SweepResultCreatorCleared reports if the "sweep_result_creator" edge to the SweepResult entity was cleared.
func (m *AdminMutation) SweepResultCreatorCleared() bool {
	return m.clearedsweep_result_creator
}

// RemoveSweepResultCreatorIDs removes the "sweep_result_creator" edge to the SweepResult entity by IDs.
func (m *AdminMutation) RemoveSweepResultCreatorIDs(ids ...int) {
	if m.removedsweep_result_creator == nil {
		m.removedsweep_result_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result_creator, ids[i])
		m.removedsweep_result_creator[ids[i]] = struct{}{}
	}
}

// RemovedSweepResultCreator returns the removed IDs of the "sweep_result_creator" edge to the SweepResult entity.
func (m *AdminMutation) RemovedSweepResultCreatorIDs() (ids []int) {
	for id := range m.removedsweep_result_creator {
		ids = append(ids, id)
	}
	return
}

// SweepResultCreatorIDs returns the "sweep_result_creator" edge IDs in the mutation.
func (m *AdminMutation) SweepResultCreatorIDs() (ids []int) {
	for id := range m.sweep_result_creator {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResultCreator resets all changes to the "sweep_result_creator" edge.
func (m *AdminMutation) ResetSweepResultCreator() {
	m.sweep_result_creator = nil
	m.clearedsweep_result_creator = false
	m.removedsweep_result_creator = nil
}

// AddSweepResultUpdaterIDs adds the "sweep_result_updater" edge to the SweepResult entity by ids.
func (m *AdminMutation) AddSweepResultUpdaterIDs(ids ...int) {
	if m.sweep_result_updater == nil {
		m.sweep_result_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result_updater[ids[i]] = struct{}{}
	}
}

// ClearSweepResultUpdater clears the "sweep_result_updater" edge to the SweepResult entity.
func (m *AdminMutation) ClearSweepResultUpdater() {
	m.clearedsweep_result_updater = true
}

// SweepResultUpdaterCleared reports if the "sweep_result_updater" edge to the SweepResult entity was cleared.
func (m *AdminMutation) SweepResultUpdaterCleared() bool {
	return m.clearedsweep_result_updater
}

// RemoveSweepResultUpdaterIDs removes the "sweep_result_updater" edge to the SweepResult entity by IDs.
func (m *AdminMutation) RemoveSweepResultUpdaterIDs(ids ...int) {
	if m.removedsweep_result_updater == nil {
		m.removedsweep_result_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result_updater, ids[i])
		m.removedsweep_result_updater[ids[i]] = struct{}{}
	}
}

// RemovedSweepResultUpdater returns the removed IDs of the "sweep_result_updater" edge to the SweepResult entity.
func (m *AdminMutation) RemovedSweepResultUpdaterIDs() (ids []int) {
	for id := range m.removedsweep_result_updater {
		ids = append(ids, id)
	}
	return
}

// SweepResultUpdaterIDs returns the "sweep_result_updater" edge IDs in the mutation.
func (m *AdminMutation) SweepResultUpdaterIDs() (ids []int) {
	for id := range m.sweep_result_updater {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResultUpdater resets all changes to the "sweep_result_updater" edge.
func (m *AdminMutation) ResetSweepResultUpdater() {
	m.sweep_result_updater = nil
	m.clearedsweep_result_updater = false
	m.removedsweep_result_updater = nil
}

// AddSweepResultDetailsCreatorIDs adds the "sweep_result_details_creator" edge to the SweepResultDetails entity by ids.
func (m *AdminMutation) AddSweepResultDetailsCreatorIDs(ids ...int) {
	if m.sweep_result_details_creator == nil {
		m.sweep_result_details_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result_details_creator[ids[i]] = struct{}{}
	}
}

// ClearSweepResultDetailsCreator clears the "sweep_result_details_creator" edge to the SweepResultDetails entity.
func (m *AdminMutation) ClearSweepResultDetailsCreator() {
	m.clearedsweep_result_details_creator = true
}

// SweepResultDetailsCreatorCleared reports if the "sweep_result_details_creator" edge to the SweepResultDetails entity was cleared.
func (m *AdminMutation) SweepResultDetailsCreatorCleared() bool {
	return m.clearedsweep_result_details_creator
}

// RemoveSweepResultDetailsCreatorIDs removes the "sweep_result_details_creator" edge to the SweepResultDetails entity by IDs.
func (m *AdminMutation) RemoveSweepResultDetailsCreatorIDs(ids ...int) {
	if m.removedsweep_result_details_creator == nil {
		m.removedsweep_result_details_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result_details_creator, ids[i])
		m.removedsweep_result_details_creator[ids[i]] = struct{}{}
	}
}

// RemovedSweepResultDetailsCreator returns the removed IDs of the "sweep_result_details_creator" edge to the SweepResultDetails entity.
func (m *AdminMutation) RemovedSweepResultDetailsCreatorIDs() (ids []int) {
	for id := range m.removedsweep_result_details_creator {
		ids = append(ids, id)
	}
	return
}

// SweepResultDetailsCreatorIDs returns the "sweep_result_details_creator" edge IDs in the mutation.
func (m *AdminMutation) SweepResultDetailsCreatorIDs() (ids []int) {
	for id := range m.sweep_result_details_creator {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResultDetailsCreator resets all changes to the "sweep_result_details_creator" edge.
func (m *AdminMutation) ResetSweepResultDetailsCreator() {
	m.sweep_result_details_creator = nil
	m.clearedsweep_result_details_creator = false
	m.removedsweep_result_details_creator = nil
}

// AddSweepResultDetailsUpdaterIDs adds the "sweep_result_details_updater" edge to the SweepResultDetails entity by ids.
func (m *AdminMutation) AddSweepResultDetailsUpdaterIDs(ids ...int) {
	if m.sweep_result_details_updater == nil {
		m.sweep_result_details_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result_details_updater[ids[i]] = struct{}{}
	}
}

// ClearSweepResultDetailsUpdater clears the "sweep_result_details_updater" edge to the SweepResultDetails entity.
func (m *AdminMutation) ClearSweepResultDetailsUpdater() {
	m.clearedsweep_result_details_updater = true
}

// SweepResultDetailsUpdaterCleared reports if the "sweep_result_details_updater" edge to the SweepResultDetails entity was cleared.
func (m *AdminMutation) SweepResultDetailsUpdaterCleared() bool {
	return m.clearedsweep_result_details_updater
}

// RemoveSweepResultDetailsUpdaterIDs removes the "sweep_result_details_updater" edge to the SweepResultDetails entity by IDs.
func (m *AdminMutation) RemoveSweepResultDetailsUpdaterIDs(ids ...int) {
	if m.removedsweep_result_details_updater == nil {
		m.removedsweep_result_details_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result_details_updater, ids[i])
		m.removedsweep_result_details_updater[ids[i]] = struct{}{}
	}
}

// RemovedSweepResultDetailsUpdater returns the removed IDs of the "sweep_result_details_updater" edge to the SweepResultDetails entity.
func (m *AdminMutation) RemovedSweepResultDetailsUpdaterIDs() (ids []int) {
	for id := range m.removedsweep_result_details_updater {
		ids = append(ids, id)
	}
	return
}

// SweepResultDetailsUpdaterIDs returns the "sweep_result_details_updater" edge IDs in the mutation.
func (m *AdminMutation) SweepResultDetailsUpdaterIDs() (ids []int) {
	for id := range m.sweep_result_details_updater {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResultDetailsUpdater resets all changes to the "sweep_result_details_updater" edge.
func (m *AdminMutation) ResetSweepResultDetailsUpdater() {
	m.sweep_result_details_updater = nil
	m.clearedsweep_result_details_updater = false
	m.removedsweep_result_details_updater = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, admin.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, admin.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, admin.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, admin.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, admin.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, admin.FieldNickname)
	}
	if m.real_name != nil {
		fields = append(fields, admin.FieldRealName)
	}
	if m.mobile != nil {
		fields = append(fields, admin.FieldMobile)
	}
	if m.avatar != nil {
		fields = append(fields, admin.FieldAvatar)
	}
	if m.admin_status != nil {
		fields = append(fields, admin.FieldAdminStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreateTime:
		return m.CreateTime()
	case admin.FieldCreatorID:
		return m.CreatorID()
	case admin.FieldDeleteTime:
		return m.DeleteTime()
	case admin.FieldUpdaterID:
		return m.UpdaterID()
	case admin.FieldUpdateTime:
		return m.UpdateTime()
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldNickname:
		return m.Nickname()
	case admin.FieldRealName:
		return m.RealName()
	case admin.FieldMobile:
		return m.Mobile()
	case admin.FieldAvatar:
		return m.Avatar()
	case admin.FieldAdminStatus:
		return m.AdminStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case admin.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case admin.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case admin.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case admin.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldNickname:
		return m.OldNickname(ctx)
	case admin.FieldRealName:
		return m.OldRealName(ctx)
	case admin.FieldMobile:
		return m.OldMobile(ctx)
	case admin.FieldAvatar:
		return m.OldAvatar(ctx)
	case admin.FieldAdminStatus:
		return m.OldAdminStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case admin.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case admin.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case admin.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case admin.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case admin.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case admin.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case admin.FieldAvatar:
		v, ok := value.(types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case admin.FieldAdminStatus:
		v, ok := value.(enums.AdminStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	var fields []string
	if m.addadmin_status != nil {
		fields = append(fields, admin.FieldAdminStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldAdminStatus:
		return m.AddedAdminStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	case admin.FieldAdminStatus:
		v, ok := value.(enums.AdminStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdminStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldDeleteTime) {
		fields = append(fields, admin.FieldDeleteTime)
	}
	if m.FieldCleared(admin.FieldMobile) {
		fields = append(fields, admin.FieldMobile)
	}
	if m.FieldCleared(admin.FieldAvatar) {
		fields = append(fields, admin.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case admin.FieldMobile:
		m.ClearMobile()
		return nil
	case admin.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case admin.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case admin.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case admin.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case admin.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldNickname:
		m.ResetNickname()
		return nil
	case admin.FieldRealName:
		m.ResetRealName()
		return nil
	case admin.FieldMobile:
		m.ResetMobile()
		return nil
	case admin.FieldAvatar:
		m.ResetAvatar()
		return nil
	case admin.FieldAdminStatus:
		m.ResetAdminStatus()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 49)
	if m.creator != nil {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, admin.EdgeUpdater)
	}
	if m.permissions != nil {
		edges = append(edges, admin.EdgePermissions)
	}
	if m.admin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.admin_updater != nil {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.permission_creator != nil {
		edges = append(edges, admin.EdgePermissionCreator)
	}
	if m.permission_updater != nil {
		edges = append(edges, admin.EdgePermissionUpdater)
	}
	if m.risk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.risk_updater != nil {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.risk_maintainer != nil {
		edges = append(edges, admin.EdgeRiskMaintainer)
	}
	if m.risk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.risk_location_updater != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.risk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.risk_category_updater != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.department_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.department_updater != nil {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.employee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.employee_updater != nil {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.employee != nil {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.occupation_creator != nil {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.occupation_updater != nil {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.event_creator != nil {
		edges = append(edges, admin.EdgeEventCreator)
	}
	if m.event_updater != nil {
		edges = append(edges, admin.EdgeEventUpdater)
	}
	if m.video_creator != nil {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.video_updater != nil {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	if m.area_creator != nil {
		edges = append(edges, admin.EdgeAreaCreator)
	}
	if m.area_updater != nil {
		edges = append(edges, admin.EdgeAreaUpdater)
	}
	if m.device_creator != nil {
		edges = append(edges, admin.EdgeDeviceCreator)
	}
	if m.device_updater != nil {
		edges = append(edges, admin.EdgeDeviceUpdater)
	}
	if m.device_installation_creator != nil {
		edges = append(edges, admin.EdgeDeviceInstallationCreator)
	}
	if m.device_installation_updater != nil {
		edges = append(edges, admin.EdgeDeviceInstallationUpdater)
	}
	if m.event_level_creator != nil {
		edges = append(edges, admin.EdgeEventLevelCreator)
	}
	if m.event_level_updater != nil {
		edges = append(edges, admin.EdgeEventLevelUpdater)
	}
	if m.fixing_creator != nil {
		edges = append(edges, admin.EdgeFixingCreator)
	}
	if m.fixing_updater != nil {
		edges = append(edges, admin.EdgeFixingUpdater)
	}
	if m.fixer != nil {
		edges = append(edges, admin.EdgeFixer)
	}
	if m.event_log_creator != nil {
		edges = append(edges, admin.EdgeEventLogCreator)
	}
	if m.event_log_updater != nil {
		edges = append(edges, admin.EdgeEventLogUpdater)
	}
	if m.event_log_actor != nil {
		edges = append(edges, admin.EdgeEventLogActor)
	}
	if m.event_log_actor2 != nil {
		edges = append(edges, admin.EdgeEventLogActor2)
	}
	if m.sweep_creator != nil {
		edges = append(edges, admin.EdgeSweepCreator)
	}
	if m.sweep_updater != nil {
		edges = append(edges, admin.EdgeSweepUpdater)
	}
	if m.sweep_schedule_creator != nil {
		edges = append(edges, admin.EdgeSweepScheduleCreator)
	}
	if m.sweep_schedule_updater != nil {
		edges = append(edges, admin.EdgeSweepScheduleUpdater)
	}
	if m.sweep_schedule != nil {
		edges = append(edges, admin.EdgeSweepSchedule)
	}
	if m.sweep_result_creator != nil {
		edges = append(edges, admin.EdgeSweepResultCreator)
	}
	if m.sweep_result_updater != nil {
		edges = append(edges, admin.EdgeSweepResultUpdater)
	}
	if m.sweep_result_details_creator != nil {
		edges = append(edges, admin.EdgeSweepResultDetailsCreator)
	}
	if m.sweep_result_details_updater != nil {
		edges = append(edges, admin.EdgeSweepResultDetailsUpdater)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.admin_creator))
		for id := range m.admin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdater:
		ids := make([]ent.Value, 0, len(m.admin_updater))
		for id := range m.admin_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgePermissionCreator:
		ids := make([]ent.Value, 0, len(m.permission_creator))
		for id := range m.permission_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgePermissionUpdater:
		ids := make([]ent.Value, 0, len(m.permission_updater))
		for id := range m.permission_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.risk_creator))
		for id := range m.risk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdater:
		ids := make([]ent.Value, 0, len(m.risk_updater))
		for id := range m.risk_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.risk_maintainer))
		for id := range m.risk_maintainer {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.risk_location_creator))
		for id := range m.risk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdater:
		ids := make([]ent.Value, 0, len(m.risk_location_updater))
		for id := range m.risk_location_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.risk_category_creator))
		for id := range m.risk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdater:
		ids := make([]ent.Value, 0, len(m.risk_category_updater))
		for id := range m.risk_category_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.department_creator))
		for id := range m.department_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdater:
		ids := make([]ent.Value, 0, len(m.department_updater))
		for id := range m.department_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.employee_creator))
		for id := range m.employee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdater:
		ids := make([]ent.Value, 0, len(m.employee_updater))
		for id := range m.employee_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeOccupationCreator:
		ids := make([]ent.Value, 0, len(m.occupation_creator))
		for id := range m.occupation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationUpdater:
		ids := make([]ent.Value, 0, len(m.occupation_updater))
		for id := range m.occupation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventCreator:
		ids := make([]ent.Value, 0, len(m.event_creator))
		for id := range m.event_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventUpdater:
		ids := make([]ent.Value, 0, len(m.event_updater))
		for id := range m.event_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoCreator:
		ids := make([]ent.Value, 0, len(m.video_creator))
		for id := range m.video_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoUpdater:
		ids := make([]ent.Value, 0, len(m.video_updater))
		for id := range m.video_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaCreator:
		ids := make([]ent.Value, 0, len(m.area_creator))
		for id := range m.area_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaUpdater:
		ids := make([]ent.Value, 0, len(m.area_updater))
		for id := range m.area_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceCreator:
		ids := make([]ent.Value, 0, len(m.device_creator))
		for id := range m.device_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceUpdater:
		ids := make([]ent.Value, 0, len(m.device_updater))
		for id := range m.device_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationCreator:
		ids := make([]ent.Value, 0, len(m.device_installation_creator))
		for id := range m.device_installation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationUpdater:
		ids := make([]ent.Value, 0, len(m.device_installation_updater))
		for id := range m.device_installation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelCreator:
		ids := make([]ent.Value, 0, len(m.event_level_creator))
		for id := range m.event_level_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelUpdater:
		ids := make([]ent.Value, 0, len(m.event_level_updater))
		for id := range m.event_level_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeFixingCreator:
		ids := make([]ent.Value, 0, len(m.fixing_creator))
		for id := range m.fixing_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeFixingUpdater:
		ids := make([]ent.Value, 0, len(m.fixing_updater))
		for id := range m.fixing_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeFixer:
		ids := make([]ent.Value, 0, len(m.fixer))
		for id := range m.fixer {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogCreator:
		ids := make([]ent.Value, 0, len(m.event_log_creator))
		for id := range m.event_log_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogUpdater:
		ids := make([]ent.Value, 0, len(m.event_log_updater))
		for id := range m.event_log_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogActor:
		ids := make([]ent.Value, 0, len(m.event_log_actor))
		for id := range m.event_log_actor {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogActor2:
		ids := make([]ent.Value, 0, len(m.event_log_actor2))
		for id := range m.event_log_actor2 {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepCreator:
		ids := make([]ent.Value, 0, len(m.sweep_creator))
		for id := range m.sweep_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepUpdater:
		ids := make([]ent.Value, 0, len(m.sweep_updater))
		for id := range m.sweep_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepScheduleCreator:
		ids := make([]ent.Value, 0, len(m.sweep_schedule_creator))
		for id := range m.sweep_schedule_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepScheduleUpdater:
		ids := make([]ent.Value, 0, len(m.sweep_schedule_updater))
		for id := range m.sweep_schedule_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepSchedule:
		ids := make([]ent.Value, 0, len(m.sweep_schedule))
		for id := range m.sweep_schedule {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultCreator:
		ids := make([]ent.Value, 0, len(m.sweep_result_creator))
		for id := range m.sweep_result_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultUpdater:
		ids := make([]ent.Value, 0, len(m.sweep_result_updater))
		for id := range m.sweep_result_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultDetailsCreator:
		ids := make([]ent.Value, 0, len(m.sweep_result_details_creator))
		for id := range m.sweep_result_details_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultDetailsUpdater:
		ids := make([]ent.Value, 0, len(m.sweep_result_details_updater))
		for id := range m.sweep_result_details_updater {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 49)
	if m.removedpermissions != nil {
		edges = append(edges, admin.EdgePermissions)
	}
	if m.removedadmin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.removedadmin_updater != nil {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.removedpermission_creator != nil {
		edges = append(edges, admin.EdgePermissionCreator)
	}
	if m.removedpermission_updater != nil {
		edges = append(edges, admin.EdgePermissionUpdater)
	}
	if m.removedrisk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.removedrisk_updater != nil {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.removedrisk_maintainer != nil {
		edges = append(edges, admin.EdgeRiskMaintainer)
	}
	if m.removedrisk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.removedrisk_location_updater != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.removedrisk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.removedrisk_category_updater != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.removeddepartment_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.removeddepartment_updater != nil {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.removedemployee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.removedemployee_updater != nil {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.removedoccupation_creator != nil {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.removedoccupation_updater != nil {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.removedevent_creator != nil {
		edges = append(edges, admin.EdgeEventCreator)
	}
	if m.removedevent_updater != nil {
		edges = append(edges, admin.EdgeEventUpdater)
	}
	if m.removedvideo_creator != nil {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.removedvideo_updater != nil {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	if m.removedarea_creator != nil {
		edges = append(edges, admin.EdgeAreaCreator)
	}
	if m.removedarea_updater != nil {
		edges = append(edges, admin.EdgeAreaUpdater)
	}
	if m.removeddevice_creator != nil {
		edges = append(edges, admin.EdgeDeviceCreator)
	}
	if m.removeddevice_updater != nil {
		edges = append(edges, admin.EdgeDeviceUpdater)
	}
	if m.removeddevice_installation_creator != nil {
		edges = append(edges, admin.EdgeDeviceInstallationCreator)
	}
	if m.removeddevice_installation_updater != nil {
		edges = append(edges, admin.EdgeDeviceInstallationUpdater)
	}
	if m.removedevent_level_creator != nil {
		edges = append(edges, admin.EdgeEventLevelCreator)
	}
	if m.removedevent_level_updater != nil {
		edges = append(edges, admin.EdgeEventLevelUpdater)
	}
	if m.removedfixing_creator != nil {
		edges = append(edges, admin.EdgeFixingCreator)
	}
	if m.removedfixing_updater != nil {
		edges = append(edges, admin.EdgeFixingUpdater)
	}
	if m.removedfixer != nil {
		edges = append(edges, admin.EdgeFixer)
	}
	if m.removedevent_log_creator != nil {
		edges = append(edges, admin.EdgeEventLogCreator)
	}
	if m.removedevent_log_updater != nil {
		edges = append(edges, admin.EdgeEventLogUpdater)
	}
	if m.removedevent_log_actor != nil {
		edges = append(edges, admin.EdgeEventLogActor)
	}
	if m.removedevent_log_actor2 != nil {
		edges = append(edges, admin.EdgeEventLogActor2)
	}
	if m.removedsweep_creator != nil {
		edges = append(edges, admin.EdgeSweepCreator)
	}
	if m.removedsweep_updater != nil {
		edges = append(edges, admin.EdgeSweepUpdater)
	}
	if m.removedsweep_schedule_creator != nil {
		edges = append(edges, admin.EdgeSweepScheduleCreator)
	}
	if m.removedsweep_schedule_updater != nil {
		edges = append(edges, admin.EdgeSweepScheduleUpdater)
	}
	if m.removedsweep_schedule != nil {
		edges = append(edges, admin.EdgeSweepSchedule)
	}
	if m.removedsweep_result_creator != nil {
		edges = append(edges, admin.EdgeSweepResultCreator)
	}
	if m.removedsweep_result_updater != nil {
		edges = append(edges, admin.EdgeSweepResultUpdater)
	}
	if m.removedsweep_result_details_creator != nil {
		edges = append(edges, admin.EdgeSweepResultDetailsCreator)
	}
	if m.removedsweep_result_details_updater != nil {
		edges = append(edges, admin.EdgeSweepResultDetailsUpdater)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.removedadmin_creator))
		for id := range m.removedadmin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdater:
		ids := make([]ent.Value, 0, len(m.removedadmin_updater))
		for id := range m.removedadmin_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgePermissionCreator:
		ids := make([]ent.Value, 0, len(m.removedpermission_creator))
		for id := range m.removedpermission_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgePermissionUpdater:
		ids := make([]ent.Value, 0, len(m.removedpermission_updater))
		for id := range m.removedpermission_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_creator))
		for id := range m.removedrisk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_updater))
		for id := range m.removedrisk_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.removedrisk_maintainer))
		for id := range m.removedrisk_maintainer {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_creator))
		for id := range m.removedrisk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_updater))
		for id := range m.removedrisk_location_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_creator))
		for id := range m.removedrisk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_updater))
		for id := range m.removedrisk_category_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.removeddepartment_creator))
		for id := range m.removeddepartment_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdater:
		ids := make([]ent.Value, 0, len(m.removeddepartment_updater))
		for id := range m.removeddepartment_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.removedemployee_creator))
		for id := range m.removedemployee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdater:
		ids := make([]ent.Value, 0, len(m.removedemployee_updater))
		for id := range m.removedemployee_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationCreator:
		ids := make([]ent.Value, 0, len(m.removedoccupation_creator))
		for id := range m.removedoccupation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationUpdater:
		ids := make([]ent.Value, 0, len(m.removedoccupation_updater))
		for id := range m.removedoccupation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventCreator:
		ids := make([]ent.Value, 0, len(m.removedevent_creator))
		for id := range m.removedevent_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventUpdater:
		ids := make([]ent.Value, 0, len(m.removedevent_updater))
		for id := range m.removedevent_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoCreator:
		ids := make([]ent.Value, 0, len(m.removedvideo_creator))
		for id := range m.removedvideo_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoUpdater:
		ids := make([]ent.Value, 0, len(m.removedvideo_updater))
		for id := range m.removedvideo_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaCreator:
		ids := make([]ent.Value, 0, len(m.removedarea_creator))
		for id := range m.removedarea_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaUpdater:
		ids := make([]ent.Value, 0, len(m.removedarea_updater))
		for id := range m.removedarea_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceCreator:
		ids := make([]ent.Value, 0, len(m.removeddevice_creator))
		for id := range m.removeddevice_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceUpdater:
		ids := make([]ent.Value, 0, len(m.removeddevice_updater))
		for id := range m.removeddevice_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationCreator:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation_creator))
		for id := range m.removeddevice_installation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationUpdater:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation_updater))
		for id := range m.removeddevice_installation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelCreator:
		ids := make([]ent.Value, 0, len(m.removedevent_level_creator))
		for id := range m.removedevent_level_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelUpdater:
		ids := make([]ent.Value, 0, len(m.removedevent_level_updater))
		for id := range m.removedevent_level_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeFixingCreator:
		ids := make([]ent.Value, 0, len(m.removedfixing_creator))
		for id := range m.removedfixing_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeFixingUpdater:
		ids := make([]ent.Value, 0, len(m.removedfixing_updater))
		for id := range m.removedfixing_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeFixer:
		ids := make([]ent.Value, 0, len(m.removedfixer))
		for id := range m.removedfixer {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogCreator:
		ids := make([]ent.Value, 0, len(m.removedevent_log_creator))
		for id := range m.removedevent_log_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogUpdater:
		ids := make([]ent.Value, 0, len(m.removedevent_log_updater))
		for id := range m.removedevent_log_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogActor:
		ids := make([]ent.Value, 0, len(m.removedevent_log_actor))
		for id := range m.removedevent_log_actor {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLogActor2:
		ids := make([]ent.Value, 0, len(m.removedevent_log_actor2))
		for id := range m.removedevent_log_actor2 {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepCreator:
		ids := make([]ent.Value, 0, len(m.removedsweep_creator))
		for id := range m.removedsweep_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepUpdater:
		ids := make([]ent.Value, 0, len(m.removedsweep_updater))
		for id := range m.removedsweep_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepScheduleCreator:
		ids := make([]ent.Value, 0, len(m.removedsweep_schedule_creator))
		for id := range m.removedsweep_schedule_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepScheduleUpdater:
		ids := make([]ent.Value, 0, len(m.removedsweep_schedule_updater))
		for id := range m.removedsweep_schedule_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepSchedule:
		ids := make([]ent.Value, 0, len(m.removedsweep_schedule))
		for id := range m.removedsweep_schedule {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultCreator:
		ids := make([]ent.Value, 0, len(m.removedsweep_result_creator))
		for id := range m.removedsweep_result_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultUpdater:
		ids := make([]ent.Value, 0, len(m.removedsweep_result_updater))
		for id := range m.removedsweep_result_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultDetailsCreator:
		ids := make([]ent.Value, 0, len(m.removedsweep_result_details_creator))
		for id := range m.removedsweep_result_details_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeSweepResultDetailsUpdater:
		ids := make([]ent.Value, 0, len(m.removedsweep_result_details_updater))
		for id := range m.removedsweep_result_details_updater {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 49)
	if m.clearedcreator {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, admin.EdgeUpdater)
	}
	if m.clearedpermissions {
		edges = append(edges, admin.EdgePermissions)
	}
	if m.clearedadmin_creator {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.clearedadmin_updater {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.clearedpermission_creator {
		edges = append(edges, admin.EdgePermissionCreator)
	}
	if m.clearedpermission_updater {
		edges = append(edges, admin.EdgePermissionUpdater)
	}
	if m.clearedrisk_creator {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.clearedrisk_updater {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.clearedrisk_maintainer {
		edges = append(edges, admin.EdgeRiskMaintainer)
	}
	if m.clearedrisk_location_creator {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.clearedrisk_location_updater {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.clearedrisk_category_creator {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.clearedrisk_category_updater {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.cleareddepartment_creator {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.cleareddepartment_updater {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.clearedemployee_creator {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.clearedemployee_updater {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.clearedemployee {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.clearedoccupation_creator {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.clearedoccupation_updater {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.clearedevent_creator {
		edges = append(edges, admin.EdgeEventCreator)
	}
	if m.clearedevent_updater {
		edges = append(edges, admin.EdgeEventUpdater)
	}
	if m.clearedvideo_creator {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.clearedvideo_updater {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	if m.clearedarea_creator {
		edges = append(edges, admin.EdgeAreaCreator)
	}
	if m.clearedarea_updater {
		edges = append(edges, admin.EdgeAreaUpdater)
	}
	if m.cleareddevice_creator {
		edges = append(edges, admin.EdgeDeviceCreator)
	}
	if m.cleareddevice_updater {
		edges = append(edges, admin.EdgeDeviceUpdater)
	}
	if m.cleareddevice_installation_creator {
		edges = append(edges, admin.EdgeDeviceInstallationCreator)
	}
	if m.cleareddevice_installation_updater {
		edges = append(edges, admin.EdgeDeviceInstallationUpdater)
	}
	if m.clearedevent_level_creator {
		edges = append(edges, admin.EdgeEventLevelCreator)
	}
	if m.clearedevent_level_updater {
		edges = append(edges, admin.EdgeEventLevelUpdater)
	}
	if m.clearedfixing_creator {
		edges = append(edges, admin.EdgeFixingCreator)
	}
	if m.clearedfixing_updater {
		edges = append(edges, admin.EdgeFixingUpdater)
	}
	if m.clearedfixer {
		edges = append(edges, admin.EdgeFixer)
	}
	if m.clearedevent_log_creator {
		edges = append(edges, admin.EdgeEventLogCreator)
	}
	if m.clearedevent_log_updater {
		edges = append(edges, admin.EdgeEventLogUpdater)
	}
	if m.clearedevent_log_actor {
		edges = append(edges, admin.EdgeEventLogActor)
	}
	if m.clearedevent_log_actor2 {
		edges = append(edges, admin.EdgeEventLogActor2)
	}
	if m.clearedsweep_creator {
		edges = append(edges, admin.EdgeSweepCreator)
	}
	if m.clearedsweep_updater {
		edges = append(edges, admin.EdgeSweepUpdater)
	}
	if m.clearedsweep_schedule_creator {
		edges = append(edges, admin.EdgeSweepScheduleCreator)
	}
	if m.clearedsweep_schedule_updater {
		edges = append(edges, admin.EdgeSweepScheduleUpdater)
	}
	if m.clearedsweep_schedule {
		edges = append(edges, admin.EdgeSweepSchedule)
	}
	if m.clearedsweep_result_creator {
		edges = append(edges, admin.EdgeSweepResultCreator)
	}
	if m.clearedsweep_result_updater {
		edges = append(edges, admin.EdgeSweepResultUpdater)
	}
	if m.clearedsweep_result_details_creator {
		edges = append(edges, admin.EdgeSweepResultDetailsCreator)
	}
	if m.clearedsweep_result_details_updater {
		edges = append(edges, admin.EdgeSweepResultDetailsUpdater)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeCreator:
		return m.clearedcreator
	case admin.EdgeUpdater:
		return m.clearedupdater
	case admin.EdgePermissions:
		return m.clearedpermissions
	case admin.EdgeAdminCreator:
		return m.clearedadmin_creator
	case admin.EdgeAdminUpdater:
		return m.clearedadmin_updater
	case admin.EdgePermissionCreator:
		return m.clearedpermission_creator
	case admin.EdgePermissionUpdater:
		return m.clearedpermission_updater
	case admin.EdgeRiskCreator:
		return m.clearedrisk_creator
	case admin.EdgeRiskUpdater:
		return m.clearedrisk_updater
	case admin.EdgeRiskMaintainer:
		return m.clearedrisk_maintainer
	case admin.EdgeRiskLocationCreator:
		return m.clearedrisk_location_creator
	case admin.EdgeRiskLocationUpdater:
		return m.clearedrisk_location_updater
	case admin.EdgeRiskCategoryCreator:
		return m.clearedrisk_category_creator
	case admin.EdgeRiskCategoryUpdater:
		return m.clearedrisk_category_updater
	case admin.EdgeDepartmentCreator:
		return m.cleareddepartment_creator
	case admin.EdgeDepartmentUpdater:
		return m.cleareddepartment_updater
	case admin.EdgeEmployeeCreator:
		return m.clearedemployee_creator
	case admin.EdgeEmployeeUpdater:
		return m.clearedemployee_updater
	case admin.EdgeEmployee:
		return m.clearedemployee
	case admin.EdgeOccupationCreator:
		return m.clearedoccupation_creator
	case admin.EdgeOccupationUpdater:
		return m.clearedoccupation_updater
	case admin.EdgeEventCreator:
		return m.clearedevent_creator
	case admin.EdgeEventUpdater:
		return m.clearedevent_updater
	case admin.EdgeVideoCreator:
		return m.clearedvideo_creator
	case admin.EdgeVideoUpdater:
		return m.clearedvideo_updater
	case admin.EdgeAreaCreator:
		return m.clearedarea_creator
	case admin.EdgeAreaUpdater:
		return m.clearedarea_updater
	case admin.EdgeDeviceCreator:
		return m.cleareddevice_creator
	case admin.EdgeDeviceUpdater:
		return m.cleareddevice_updater
	case admin.EdgeDeviceInstallationCreator:
		return m.cleareddevice_installation_creator
	case admin.EdgeDeviceInstallationUpdater:
		return m.cleareddevice_installation_updater
	case admin.EdgeEventLevelCreator:
		return m.clearedevent_level_creator
	case admin.EdgeEventLevelUpdater:
		return m.clearedevent_level_updater
	case admin.EdgeFixingCreator:
		return m.clearedfixing_creator
	case admin.EdgeFixingUpdater:
		return m.clearedfixing_updater
	case admin.EdgeFixer:
		return m.clearedfixer
	case admin.EdgeEventLogCreator:
		return m.clearedevent_log_creator
	case admin.EdgeEventLogUpdater:
		return m.clearedevent_log_updater
	case admin.EdgeEventLogActor:
		return m.clearedevent_log_actor
	case admin.EdgeEventLogActor2:
		return m.clearedevent_log_actor2
	case admin.EdgeSweepCreator:
		return m.clearedsweep_creator
	case admin.EdgeSweepUpdater:
		return m.clearedsweep_updater
	case admin.EdgeSweepScheduleCreator:
		return m.clearedsweep_schedule_creator
	case admin.EdgeSweepScheduleUpdater:
		return m.clearedsweep_schedule_updater
	case admin.EdgeSweepSchedule:
		return m.clearedsweep_schedule
	case admin.EdgeSweepResultCreator:
		return m.clearedsweep_result_creator
	case admin.EdgeSweepResultUpdater:
		return m.clearedsweep_result_updater
	case admin.EdgeSweepResultDetailsCreator:
		return m.clearedsweep_result_details_creator
	case admin.EdgeSweepResultDetailsUpdater:
		return m.clearedsweep_result_details_updater
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ClearCreator()
		return nil
	case admin.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case admin.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ResetCreator()
		return nil
	case admin.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case admin.EdgePermissions:
		m.ResetPermissions()
		return nil
	case admin.EdgeAdminCreator:
		m.ResetAdminCreator()
		return nil
	case admin.EdgeAdminUpdater:
		m.ResetAdminUpdater()
		return nil
	case admin.EdgePermissionCreator:
		m.ResetPermissionCreator()
		return nil
	case admin.EdgePermissionUpdater:
		m.ResetPermissionUpdater()
		return nil
	case admin.EdgeRiskCreator:
		m.ResetRiskCreator()
		return nil
	case admin.EdgeRiskUpdater:
		m.ResetRiskUpdater()
		return nil
	case admin.EdgeRiskMaintainer:
		m.ResetRiskMaintainer()
		return nil
	case admin.EdgeRiskLocationCreator:
		m.ResetRiskLocationCreator()
		return nil
	case admin.EdgeRiskLocationUpdater:
		m.ResetRiskLocationUpdater()
		return nil
	case admin.EdgeRiskCategoryCreator:
		m.ResetRiskCategoryCreator()
		return nil
	case admin.EdgeRiskCategoryUpdater:
		m.ResetRiskCategoryUpdater()
		return nil
	case admin.EdgeDepartmentCreator:
		m.ResetDepartmentCreator()
		return nil
	case admin.EdgeDepartmentUpdater:
		m.ResetDepartmentUpdater()
		return nil
	case admin.EdgeEmployeeCreator:
		m.ResetEmployeeCreator()
		return nil
	case admin.EdgeEmployeeUpdater:
		m.ResetEmployeeUpdater()
		return nil
	case admin.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case admin.EdgeOccupationCreator:
		m.ResetOccupationCreator()
		return nil
	case admin.EdgeOccupationUpdater:
		m.ResetOccupationUpdater()
		return nil
	case admin.EdgeEventCreator:
		m.ResetEventCreator()
		return nil
	case admin.EdgeEventUpdater:
		m.ResetEventUpdater()
		return nil
	case admin.EdgeVideoCreator:
		m.ResetVideoCreator()
		return nil
	case admin.EdgeVideoUpdater:
		m.ResetVideoUpdater()
		return nil
	case admin.EdgeAreaCreator:
		m.ResetAreaCreator()
		return nil
	case admin.EdgeAreaUpdater:
		m.ResetAreaUpdater()
		return nil
	case admin.EdgeDeviceCreator:
		m.ResetDeviceCreator()
		return nil
	case admin.EdgeDeviceUpdater:
		m.ResetDeviceUpdater()
		return nil
	case admin.EdgeDeviceInstallationCreator:
		m.ResetDeviceInstallationCreator()
		return nil
	case admin.EdgeDeviceInstallationUpdater:
		m.ResetDeviceInstallationUpdater()
		return nil
	case admin.EdgeEventLevelCreator:
		m.ResetEventLevelCreator()
		return nil
	case admin.EdgeEventLevelUpdater:
		m.ResetEventLevelUpdater()
		return nil
	case admin.EdgeFixingCreator:
		m.ResetFixingCreator()
		return nil
	case admin.EdgeFixingUpdater:
		m.ResetFixingUpdater()
		return nil
	case admin.EdgeFixer:
		m.ResetFixer()
		return nil
	case admin.EdgeEventLogCreator:
		m.ResetEventLogCreator()
		return nil
	case admin.EdgeEventLogUpdater:
		m.ResetEventLogUpdater()
		return nil
	case admin.EdgeEventLogActor:
		m.ResetEventLogActor()
		return nil
	case admin.EdgeEventLogActor2:
		m.ResetEventLogActor2()
		return nil
	case admin.EdgeSweepCreator:
		m.ResetSweepCreator()
		return nil
	case admin.EdgeSweepUpdater:
		m.ResetSweepUpdater()
		return nil
	case admin.EdgeSweepScheduleCreator:
		m.ResetSweepScheduleCreator()
		return nil
	case admin.EdgeSweepScheduleUpdater:
		m.ResetSweepScheduleUpdater()
		return nil
	case admin.EdgeSweepSchedule:
		m.ResetSweepSchedule()
		return nil
	case admin.EdgeSweepResultCreator:
		m.ResetSweepResultCreator()
		return nil
	case admin.EdgeSweepResultUpdater:
		m.ResetSweepResultUpdater()
		return nil
	case admin.EdgeSweepResultDetailsCreator:
		m.ResetSweepResultDetailsCreator()
		return nil
	case admin.EdgeSweepResultDetailsUpdater:
		m.ResetSweepResultDetailsUpdater()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AreaMutation represents an operation that mutates the Area nodes in the graph.
type AreaMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	delete_time                *time.Time
	update_time                *time.Time
	name                       *string
	description                *string
	clearedFields              map[string]struct{}
	creator                    *int
	clearedcreator             bool
	updater                    *int
	clearedupdater             bool
	device_installation        map[int]struct{}
	removeddevice_installation map[int]struct{}
	cleareddevice_installation bool
	done                       bool
	oldValue                   func(context.Context) (*Area, error)
	predicates                 []predicate.Area
}

var _ ent.Mutation = (*AreaMutation)(nil)

// areaOption allows management of the mutation configuration using functional options.
type areaOption func(*AreaMutation)

// newAreaMutation creates new mutation for the Area entity.
func newAreaMutation(c config, op Op, opts ...areaOption) *AreaMutation {
	m := &AreaMutation{
		config:        c,
		op:            op,
		typ:           TypeArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAreaID sets the ID field of the mutation.
func withAreaID(id int) areaOption {
	return func(m *AreaMutation) {
		var (
			err   error
			once  sync.Once
			value *Area
		)
		m.oldValue = func(ctx context.Context) (*Area, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Area.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArea sets the old Area of the mutation.
func withArea(node *Area) areaOption {
	return func(m *AreaMutation) {
		m.oldValue = func(context.Context) (*Area, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Area.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AreaMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AreaMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AreaMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *AreaMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *AreaMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *AreaMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *AreaMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *AreaMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *AreaMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[area.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *AreaMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[area.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *AreaMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, area.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *AreaMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *AreaMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *AreaMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AreaMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AreaMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AreaMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *AreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AreaMutation) ClearName() {
	m.name = nil
	m.clearedFields[area.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AreaMutation) NameCleared() bool {
	_, ok := m.clearedFields[area.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AreaMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, area.FieldName)
}

// SetDescription sets the "description" field.
func (m *AreaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AreaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AreaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[area.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AreaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[area.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AreaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, area.FieldDescription)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AreaMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[area.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AreaMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AreaMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AreaMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *AreaMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[area.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *AreaMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *AreaMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *AreaMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddDeviceInstallationIDs adds the "device_installation" edge to the DeviceInstallation entity by ids.
func (m *AreaMutation) AddDeviceInstallationIDs(ids ...int) {
	if m.device_installation == nil {
		m.device_installation = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallation clears the "device_installation" edge to the DeviceInstallation entity.
func (m *AreaMutation) ClearDeviceInstallation() {
	m.cleareddevice_installation = true
}

// DeviceInstallationCleared reports if the "device_installation" edge to the DeviceInstallation entity was cleared.
func (m *AreaMutation) DeviceInstallationCleared() bool {
	return m.cleareddevice_installation
}

// RemoveDeviceInstallationIDs removes the "device_installation" edge to the DeviceInstallation entity by IDs.
func (m *AreaMutation) RemoveDeviceInstallationIDs(ids ...int) {
	if m.removeddevice_installation == nil {
		m.removeddevice_installation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation, ids[i])
		m.removeddevice_installation[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallation returns the removed IDs of the "device_installation" edge to the DeviceInstallation entity.
func (m *AreaMutation) RemovedDeviceInstallationIDs() (ids []int) {
	for id := range m.removeddevice_installation {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationIDs returns the "device_installation" edge IDs in the mutation.
func (m *AreaMutation) DeviceInstallationIDs() (ids []int) {
	for id := range m.device_installation {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallation resets all changes to the "device_installation" edge.
func (m *AreaMutation) ResetDeviceInstallation() {
	m.device_installation = nil
	m.cleareddevice_installation = false
	m.removeddevice_installation = nil
}

// Where appends a list predicates to the AreaMutation builder.
func (m *AreaMutation) Where(ps ...predicate.Area) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Area, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Area).
func (m *AreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AreaMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, area.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, area.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, area.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, area.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, area.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, area.FieldName)
	}
	if m.description != nil {
		fields = append(fields, area.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case area.FieldCreateTime:
		return m.CreateTime()
	case area.FieldCreatorID:
		return m.CreatorID()
	case area.FieldDeleteTime:
		return m.DeleteTime()
	case area.FieldUpdaterID:
		return m.UpdaterID()
	case area.FieldUpdateTime:
		return m.UpdateTime()
	case area.FieldName:
		return m.Name()
	case area.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case area.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case area.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case area.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case area.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case area.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case area.FieldName:
		return m.OldName(ctx)
	case area.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Area field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case area.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case area.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case area.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case area.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case area.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case area.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case area.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AreaMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Area numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AreaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(area.FieldDeleteTime) {
		fields = append(fields, area.FieldDeleteTime)
	}
	if m.FieldCleared(area.FieldName) {
		fields = append(fields, area.FieldName)
	}
	if m.FieldCleared(area.FieldDescription) {
		fields = append(fields, area.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AreaMutation) ClearField(name string) error {
	switch name {
	case area.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case area.FieldName:
		m.ClearName()
		return nil
	case area.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Area nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AreaMutation) ResetField(name string) error {
	switch name {
	case area.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case area.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case area.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case area.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case area.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case area.FieldName:
		m.ResetName()
		return nil
	case area.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, area.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, area.EdgeUpdater)
	}
	if m.device_installation != nil {
		edges = append(edges, area.EdgeDeviceInstallation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case area.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case area.EdgeDeviceInstallation:
		ids := make([]ent.Value, 0, len(m.device_installation))
		for id := range m.device_installation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddevice_installation != nil {
		edges = append(edges, area.EdgeDeviceInstallation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeDeviceInstallation:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation))
		for id := range m.removeddevice_installation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, area.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, area.EdgeUpdater)
	}
	if m.cleareddevice_installation {
		edges = append(edges, area.EdgeDeviceInstallation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AreaMutation) EdgeCleared(name string) bool {
	switch name {
	case area.EdgeCreator:
		return m.clearedcreator
	case area.EdgeUpdater:
		return m.clearedupdater
	case area.EdgeDeviceInstallation:
		return m.cleareddevice_installation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AreaMutation) ClearEdge(name string) error {
	switch name {
	case area.EdgeCreator:
		m.ClearCreator()
		return nil
	case area.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Area unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AreaMutation) ResetEdge(name string) error {
	switch name {
	case area.EdgeCreator:
		m.ResetCreator()
		return nil
	case area.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case area.EdgeDeviceInstallation:
		m.ResetDeviceInstallation()
		return nil
	}
	return fmt.Errorf("unknown Area edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	delete_time        *time.Time
	update_time        *time.Time
	name               *string
	notes              *string
	clearedFields      map[string]struct{}
	creator            *int
	clearedcreator     bool
	updater            *int
	clearedupdater     bool
	parent             *int
	clearedparent      bool
	permissions        map[int]struct{}
	removedpermissions map[int]struct{}
	clearedpermissions bool
	employees          map[int]struct{}
	removedemployees   map[int]struct{}
	clearedemployees   bool
	children           map[int]struct{}
	removedchildren    map[int]struct{}
	clearedchildren    bool
	done               bool
	oldValue           func(context.Context) (*Department, error)
	predicates         []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DepartmentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DepartmentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DepartmentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *DepartmentMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *DepartmentMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *DepartmentMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *DepartmentMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DepartmentMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DepartmentMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[department.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DepartmentMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[department.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DepartmentMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, department.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *DepartmentMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *DepartmentMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *DepartmentMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DepartmentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DepartmentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DepartmentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, department.FieldParentID)
}

// SetNotes sets the "notes" field.
func (m *DepartmentMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *DepartmentMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *DepartmentMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[department.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *DepartmentMutation) NotesCleared() bool {
	_, ok := m.clearedFields[department.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *DepartmentMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, department.FieldNotes)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DepartmentMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[department.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DepartmentMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DepartmentMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *DepartmentMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[department.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *DepartmentMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *DepartmentMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *DepartmentMutation) AddPermissionIDs(ids ...int) {
	if m.permissions == nil {
		m.permissions = make(map[int]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *DepartmentMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *DepartmentMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *DepartmentMutation) RemovePermissionIDs(ids ...int) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *DepartmentMutation) RemovedPermissionsIDs() (ids []int) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *DepartmentMutation) PermissionsIDs() (ids []int) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *DepartmentMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *DepartmentMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *DepartmentMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *DepartmentMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *DepartmentMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *DepartmentMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *DepartmentMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *DepartmentMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, department.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, department.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, department.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, department.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, department.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.parent != nil {
		fields = append(fields, department.FieldParentID)
	}
	if m.notes != nil {
		fields = append(fields, department.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldCreateTime:
		return m.CreateTime()
	case department.FieldCreatorID:
		return m.CreatorID()
	case department.FieldDeleteTime:
		return m.DeleteTime()
	case department.FieldUpdaterID:
		return m.UpdaterID()
	case department.FieldUpdateTime:
		return m.UpdateTime()
	case department.FieldName:
		return m.Name()
	case department.FieldParentID:
		return m.ParentID()
	case department.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case department.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case department.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case department.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case department.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	case department.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case department.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case department.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case department.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case department.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case department.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDeleteTime) {
		fields = append(fields, department.FieldDeleteTime)
	}
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	if m.FieldCleared(department.FieldNotes) {
		fields = append(fields, department.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	case department.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case department.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case department.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case department.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case department.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	case department.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.creator != nil {
		edges = append(edges, department.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, department.EdgeUpdater)
	}
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.permissions != nil {
		edges = append(edges, department.EdgePermissions)
	}
	if m.employees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedpermissions != nil {
		edges = append(edges, department.EdgePermissions)
	}
	if m.removedemployees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcreator {
		edges = append(edges, department.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, department.EdgeUpdater)
	}
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedpermissions {
		edges = append(edges, department.EdgePermissions)
	}
	if m.clearedemployees {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeCreator:
		return m.clearedcreator
	case department.EdgeUpdater:
		return m.clearedupdater
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgePermissions:
		return m.clearedpermissions
	case department.EdgeEmployees:
		return m.clearedemployees
	case department.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ClearCreator()
		return nil
	case department.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case department.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ResetCreator()
		return nil
	case department.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgePermissions:
		m.ResetPermissions()
		return nil
	case department.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	create_time                *time.Time
	delete_time                *time.Time
	update_time                *time.Time
	brand                      *enums.DeviceBrand
	addbrand                   *enums.DeviceBrand
	model                      *enums.DeviceModel
	addmodel                   *enums.DeviceModel
	name                       *string
	sn                         *string
	device_type                *enums.DeviceType
	adddevice_type             *enums.DeviceType
	clearedFields              map[string]struct{}
	creator                    *int
	clearedcreator             bool
	updater                    *int
	clearedupdater             bool
	event                      map[int]struct{}
	removedevent               map[int]struct{}
	clearedevent               bool
	device_installation        map[int]struct{}
	removeddevice_installation map[int]struct{}
	cleareddevice_installation bool
	event_log                  map[int]struct{}
	removedevent_log           map[int]struct{}
	clearedevent_log           bool
	fixing                     map[int]struct{}
	removedfixing              map[int]struct{}
	clearedfixing              bool
	done                       bool
	oldValue                   func(context.Context) (*Device, error)
	predicates                 []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DeviceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeviceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeviceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *DeviceMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *DeviceMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *DeviceMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *DeviceMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DeviceMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DeviceMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[device.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DeviceMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[device.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DeviceMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, device.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *DeviceMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *DeviceMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *DeviceMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DeviceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeviceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeviceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetBrand sets the "brand" field.
func (m *DeviceMutation) SetBrand(eb enums.DeviceBrand) {
	m.brand = &eb
	m.addbrand = nil
}

// Brand returns the value of the "brand" field in the mutation.
func (m *DeviceMutation) Brand() (r enums.DeviceBrand, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldBrand(ctx context.Context) (v enums.DeviceBrand, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// AddBrand adds eb to the "brand" field.
func (m *DeviceMutation) AddBrand(eb enums.DeviceBrand) {
	if m.addbrand != nil {
		*m.addbrand += eb
	} else {
		m.addbrand = &eb
	}
}

// AddedBrand returns the value that was added to the "brand" field in this mutation.
func (m *DeviceMutation) AddedBrand() (r enums.DeviceBrand, exists bool) {
	v := m.addbrand
	if v == nil {
		return
	}
	return *v, true
}

// ClearBrand clears the value of the "brand" field.
func (m *DeviceMutation) ClearBrand() {
	m.brand = nil
	m.addbrand = nil
	m.clearedFields[device.FieldBrand] = struct{}{}
}

// BrandCleared returns if the "brand" field was cleared in this mutation.
func (m *DeviceMutation) BrandCleared() bool {
	_, ok := m.clearedFields[device.FieldBrand]
	return ok
}

// ResetBrand resets all changes to the "brand" field.
func (m *DeviceMutation) ResetBrand() {
	m.brand = nil
	m.addbrand = nil
	delete(m.clearedFields, device.FieldBrand)
}

// SetModel sets the "model" field.
func (m *DeviceMutation) SetModel(em enums.DeviceModel) {
	m.model = &em
	m.addmodel = nil
}

// Model returns the value of the "model" field in the mutation.
func (m *DeviceMutation) Model() (r enums.DeviceModel, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldModel(ctx context.Context) (v enums.DeviceModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// AddModel adds em to the "model" field.
func (m *DeviceMutation) AddModel(em enums.DeviceModel) {
	if m.addmodel != nil {
		*m.addmodel += em
	} else {
		m.addmodel = &em
	}
}

// AddedModel returns the value that was added to the "model" field in this mutation.
func (m *DeviceMutation) AddedModel() (r enums.DeviceModel, exists bool) {
	v := m.addmodel
	if v == nil {
		return
	}
	return *v, true
}

// ClearModel clears the value of the "model" field.
func (m *DeviceMutation) ClearModel() {
	m.model = nil
	m.addmodel = nil
	m.clearedFields[device.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *DeviceMutation) ModelCleared() bool {
	_, ok := m.clearedFields[device.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *DeviceMutation) ResetModel() {
	m.model = nil
	m.addmodel = nil
	delete(m.clearedFields, device.FieldModel)
}

// SetName sets the "name" field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DeviceMutation) ClearName() {
	m.name = nil
	m.clearedFields[device.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DeviceMutation) NameCleared() bool {
	_, ok := m.clearedFields[device.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, device.FieldName)
}

// SetSn sets the "sn" field.
func (m *DeviceMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *DeviceMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *DeviceMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[device.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *DeviceMutation) SnCleared() bool {
	_, ok := m.clearedFields[device.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *DeviceMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, device.FieldSn)
}

// SetDeviceType sets the "device_type" field.
func (m *DeviceMutation) SetDeviceType(et enums.DeviceType) {
	m.device_type = &et
	m.adddevice_type = nil
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *DeviceMutation) DeviceType() (r enums.DeviceType, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceType(ctx context.Context) (v enums.DeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// AddDeviceType adds et to the "device_type" field.
func (m *DeviceMutation) AddDeviceType(et enums.DeviceType) {
	if m.adddevice_type != nil {
		*m.adddevice_type += et
	} else {
		m.adddevice_type = &et
	}
}

// AddedDeviceType returns the value that was added to the "device_type" field in this mutation.
func (m *DeviceMutation) AddedDeviceType() (r enums.DeviceType, exists bool) {
	v := m.adddevice_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *DeviceMutation) ResetDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DeviceMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[device.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DeviceMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DeviceMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *DeviceMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[device.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *DeviceMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *DeviceMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *DeviceMutation) AddEventIDs(ids ...int) {
	if m.event == nil {
		m.event = make(map[int]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *DeviceMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *DeviceMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *DeviceMutation) RemoveEventIDs(ids ...int) {
	if m.removedevent == nil {
		m.removedevent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *DeviceMutation) RemovedEventIDs() (ids []int) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *DeviceMutation) EventIDs() (ids []int) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *DeviceMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// AddDeviceInstallationIDs adds the "device_installation" edge to the DeviceInstallation entity by ids.
func (m *DeviceMutation) AddDeviceInstallationIDs(ids ...int) {
	if m.device_installation == nil {
		m.device_installation = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallation clears the "device_installation" edge to the DeviceInstallation entity.
func (m *DeviceMutation) ClearDeviceInstallation() {
	m.cleareddevice_installation = true
}

// DeviceInstallationCleared reports if the "device_installation" edge to the DeviceInstallation entity was cleared.
func (m *DeviceMutation) DeviceInstallationCleared() bool {
	return m.cleareddevice_installation
}

// RemoveDeviceInstallationIDs removes the "device_installation" edge to the DeviceInstallation entity by IDs.
func (m *DeviceMutation) RemoveDeviceInstallationIDs(ids ...int) {
	if m.removeddevice_installation == nil {
		m.removeddevice_installation = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation, ids[i])
		m.removeddevice_installation[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallation returns the removed IDs of the "device_installation" edge to the DeviceInstallation entity.
func (m *DeviceMutation) RemovedDeviceInstallationIDs() (ids []int) {
	for id := range m.removeddevice_installation {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationIDs returns the "device_installation" edge IDs in the mutation.
func (m *DeviceMutation) DeviceInstallationIDs() (ids []int) {
	for id := range m.device_installation {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallation resets all changes to the "device_installation" edge.
func (m *DeviceMutation) ResetDeviceInstallation() {
	m.device_installation = nil
	m.cleareddevice_installation = false
	m.removeddevice_installation = nil
}

// AddEventLogIDs adds the "event_log" edge to the EventLog entity by ids.
func (m *DeviceMutation) AddEventLogIDs(ids ...int) {
	if m.event_log == nil {
		m.event_log = make(map[int]struct{})
	}
	for i := range ids {
		m.event_log[ids[i]] = struct{}{}
	}
}

// ClearEventLog clears the "event_log" edge to the EventLog entity.
func (m *DeviceMutation) ClearEventLog() {
	m.clearedevent_log = true
}

// EventLogCleared reports if the "event_log" edge to the EventLog entity was cleared.
func (m *DeviceMutation) EventLogCleared() bool {
	return m.clearedevent_log
}

// RemoveEventLogIDs removes the "event_log" edge to the EventLog entity by IDs.
func (m *DeviceMutation) RemoveEventLogIDs(ids ...int) {
	if m.removedevent_log == nil {
		m.removedevent_log = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_log, ids[i])
		m.removedevent_log[ids[i]] = struct{}{}
	}
}

// RemovedEventLog returns the removed IDs of the "event_log" edge to the EventLog entity.
func (m *DeviceMutation) RemovedEventLogIDs() (ids []int) {
	for id := range m.removedevent_log {
		ids = append(ids, id)
	}
	return
}

// EventLogIDs returns the "event_log" edge IDs in the mutation.
func (m *DeviceMutation) EventLogIDs() (ids []int) {
	for id := range m.event_log {
		ids = append(ids, id)
	}
	return
}

// ResetEventLog resets all changes to the "event_log" edge.
func (m *DeviceMutation) ResetEventLog() {
	m.event_log = nil
	m.clearedevent_log = false
	m.removedevent_log = nil
}

// AddFixingIDs adds the "fixing" edge to the Fixing entity by ids.
func (m *DeviceMutation) AddFixingIDs(ids ...int) {
	if m.fixing == nil {
		m.fixing = make(map[int]struct{})
	}
	for i := range ids {
		m.fixing[ids[i]] = struct{}{}
	}
}

// ClearFixing clears the "fixing" edge to the Fixing entity.
func (m *DeviceMutation) ClearFixing() {
	m.clearedfixing = true
}

// FixingCleared reports if the "fixing" edge to the Fixing entity was cleared.
func (m *DeviceMutation) FixingCleared() bool {
	return m.clearedfixing
}

// RemoveFixingIDs removes the "fixing" edge to the Fixing entity by IDs.
func (m *DeviceMutation) RemoveFixingIDs(ids ...int) {
	if m.removedfixing == nil {
		m.removedfixing = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixing, ids[i])
		m.removedfixing[ids[i]] = struct{}{}
	}
}

// RemovedFixing returns the removed IDs of the "fixing" edge to the Fixing entity.
func (m *DeviceMutation) RemovedFixingIDs() (ids []int) {
	for id := range m.removedfixing {
		ids = append(ids, id)
	}
	return
}

// FixingIDs returns the "fixing" edge IDs in the mutation.
func (m *DeviceMutation) FixingIDs() (ids []int) {
	for id := range m.fixing {
		ids = append(ids, id)
	}
	return
}

// ResetFixing resets all changes to the "fixing" edge.
func (m *DeviceMutation) ResetFixing() {
	m.fixing = nil
	m.clearedfixing = false
	m.removedfixing = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, device.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, device.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, device.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, device.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, device.FieldUpdateTime)
	}
	if m.brand != nil {
		fields = append(fields, device.FieldBrand)
	}
	if m.model != nil {
		fields = append(fields, device.FieldModel)
	}
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m.sn != nil {
		fields = append(fields, device.FieldSn)
	}
	if m.device_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreateTime:
		return m.CreateTime()
	case device.FieldCreatorID:
		return m.CreatorID()
	case device.FieldDeleteTime:
		return m.DeleteTime()
	case device.FieldUpdaterID:
		return m.UpdaterID()
	case device.FieldUpdateTime:
		return m.UpdateTime()
	case device.FieldBrand:
		return m.Brand()
	case device.FieldModel:
		return m.Model()
	case device.FieldName:
		return m.Name()
	case device.FieldSn:
		return m.Sn()
	case device.FieldDeviceType:
		return m.DeviceType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case device.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case device.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case device.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case device.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case device.FieldBrand:
		return m.OldBrand(ctx)
	case device.FieldModel:
		return m.OldModel(ctx)
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldSn:
		return m.OldSn(ctx)
	case device.FieldDeviceType:
		return m.OldDeviceType(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case device.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case device.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case device.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case device.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case device.FieldBrand:
		v, ok := value.(enums.DeviceBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case device.FieldModel:
		v, ok := value.(enums.DeviceModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(enums.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.addbrand != nil {
		fields = append(fields, device.FieldBrand)
	}
	if m.addmodel != nil {
		fields = append(fields, device.FieldModel)
	}
	if m.adddevice_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldBrand:
		return m.AddedBrand()
	case device.FieldModel:
		return m.AddedModel()
	case device.FieldDeviceType:
		return m.AddedDeviceType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldBrand:
		v, ok := value.(enums.DeviceBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrand(v)
		return nil
	case device.FieldModel:
		v, ok := value.(enums.DeviceModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModel(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(enums.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceType(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldDeleteTime) {
		fields = append(fields, device.FieldDeleteTime)
	}
	if m.FieldCleared(device.FieldBrand) {
		fields = append(fields, device.FieldBrand)
	}
	if m.FieldCleared(device.FieldModel) {
		fields = append(fields, device.FieldModel)
	}
	if m.FieldCleared(device.FieldName) {
		fields = append(fields, device.FieldName)
	}
	if m.FieldCleared(device.FieldSn) {
		fields = append(fields, device.FieldSn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case device.FieldBrand:
		m.ClearBrand()
		return nil
	case device.FieldModel:
		m.ClearModel()
		return nil
	case device.FieldName:
		m.ClearName()
		return nil
	case device.FieldSn:
		m.ClearSn()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case device.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case device.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case device.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case device.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case device.FieldBrand:
		m.ResetBrand()
		return nil
	case device.FieldModel:
		m.ResetModel()
		return nil
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldSn:
		m.ResetSn()
		return nil
	case device.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.creator != nil {
		edges = append(edges, device.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, device.EdgeUpdater)
	}
	if m.event != nil {
		edges = append(edges, device.EdgeEvent)
	}
	if m.device_installation != nil {
		edges = append(edges, device.EdgeDeviceInstallation)
	}
	if m.event_log != nil {
		edges = append(edges, device.EdgeEventLog)
	}
	if m.fixing != nil {
		edges = append(edges, device.EdgeFixing)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceInstallation:
		ids := make([]ent.Value, 0, len(m.device_installation))
		for id := range m.device_installation {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeEventLog:
		ids := make([]ent.Value, 0, len(m.event_log))
		for id := range m.event_log {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeFixing:
		ids := make([]ent.Value, 0, len(m.fixing))
		for id := range m.fixing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedevent != nil {
		edges = append(edges, device.EdgeEvent)
	}
	if m.removeddevice_installation != nil {
		edges = append(edges, device.EdgeDeviceInstallation)
	}
	if m.removedevent_log != nil {
		edges = append(edges, device.EdgeEventLog)
	}
	if m.removedfixing != nil {
		edges = append(edges, device.EdgeFixing)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceInstallation:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation))
		for id := range m.removeddevice_installation {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeEventLog:
		ids := make([]ent.Value, 0, len(m.removedevent_log))
		for id := range m.removedevent_log {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeFixing:
		ids := make([]ent.Value, 0, len(m.removedfixing))
		for id := range m.removedfixing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcreator {
		edges = append(edges, device.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, device.EdgeUpdater)
	}
	if m.clearedevent {
		edges = append(edges, device.EdgeEvent)
	}
	if m.cleareddevice_installation {
		edges = append(edges, device.EdgeDeviceInstallation)
	}
	if m.clearedevent_log {
		edges = append(edges, device.EdgeEventLog)
	}
	if m.clearedfixing {
		edges = append(edges, device.EdgeFixing)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeCreator:
		return m.clearedcreator
	case device.EdgeUpdater:
		return m.clearedupdater
	case device.EdgeEvent:
		return m.clearedevent
	case device.EdgeDeviceInstallation:
		return m.cleareddevice_installation
	case device.EdgeEventLog:
		return m.clearedevent_log
	case device.EdgeFixing:
		return m.clearedfixing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeCreator:
		m.ClearCreator()
		return nil
	case device.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeCreator:
		m.ResetCreator()
		return nil
	case device.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case device.EdgeEvent:
		m.ResetEvent()
		return nil
	case device.EdgeDeviceInstallation:
		m.ResetDeviceInstallation()
		return nil
	case device.EdgeEventLog:
		m.ResetEventLog()
		return nil
	case device.EdgeFixing:
		m.ResetFixing()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceInstallationMutation represents an operation that mutates the DeviceInstallation nodes in the graph.
type DeviceInstallationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	delete_time    *time.Time
	update_time    *time.Time
	alias_name     *string
	longitude      *float64
	addlongitude   *float64
	latitude       *float64
	addlatitude    *float64
	location_data  *string
	location       *string
	installer      *string
	install_time   *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	area           *int
	clearedarea    bool
	device         *int
	cleareddevice  bool
	done           bool
	oldValue       func(context.Context) (*DeviceInstallation, error)
	predicates     []predicate.DeviceInstallation
}

var _ ent.Mutation = (*DeviceInstallationMutation)(nil)

// deviceinstallationOption allows management of the mutation configuration using functional options.
type deviceinstallationOption func(*DeviceInstallationMutation)

// newDeviceInstallationMutation creates new mutation for the DeviceInstallation entity.
func newDeviceInstallationMutation(c config, op Op, opts ...deviceinstallationOption) *DeviceInstallationMutation {
	m := &DeviceInstallationMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInstallation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInstallationID sets the ID field of the mutation.
func withDeviceInstallationID(id int) deviceinstallationOption {
	return func(m *DeviceInstallationMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInstallation
		)
		m.oldValue = func(ctx context.Context) (*DeviceInstallation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInstallation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInstallation sets the old DeviceInstallation of the mutation.
func withDeviceInstallation(node *DeviceInstallation) deviceinstallationOption {
	return func(m *DeviceInstallationMutation) {
		m.oldValue = func(context.Context) (*DeviceInstallation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInstallationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInstallationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInstallationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInstallationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInstallation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DeviceInstallationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeviceInstallationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeviceInstallationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *DeviceInstallationMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *DeviceInstallationMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *DeviceInstallationMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *DeviceInstallationMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *DeviceInstallationMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *DeviceInstallationMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[deviceinstallation.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *DeviceInstallationMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *DeviceInstallationMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, deviceinstallation.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *DeviceInstallationMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *DeviceInstallationMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *DeviceInstallationMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DeviceInstallationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeviceInstallationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeviceInstallationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceInstallationMutation) SetDeviceID(i int) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceInstallationMutation) DeviceID() (r int, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldDeviceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceInstallationMutation) ResetDeviceID() {
	m.device = nil
}

// SetAreaID sets the "area_id" field.
func (m *DeviceInstallationMutation) SetAreaID(i int) {
	m.area = &i
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *DeviceInstallationMutation) AreaID() (r int, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *DeviceInstallationMutation) ResetAreaID() {
	m.area = nil
}

// SetAliasName sets the "alias_name" field.
func (m *DeviceInstallationMutation) SetAliasName(s string) {
	m.alias_name = &s
}

// AliasName returns the value of the "alias_name" field in the mutation.
func (m *DeviceInstallationMutation) AliasName() (r string, exists bool) {
	v := m.alias_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasName returns the old "alias_name" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldAliasName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasName: %w", err)
	}
	return oldValue.AliasName, nil
}

// ClearAliasName clears the value of the "alias_name" field.
func (m *DeviceInstallationMutation) ClearAliasName() {
	m.alias_name = nil
	m.clearedFields[deviceinstallation.FieldAliasName] = struct{}{}
}

// AliasNameCleared returns if the "alias_name" field was cleared in this mutation.
func (m *DeviceInstallationMutation) AliasNameCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldAliasName]
	return ok
}

// ResetAliasName resets all changes to the "alias_name" field.
func (m *DeviceInstallationMutation) ResetAliasName() {
	m.alias_name = nil
	delete(m.clearedFields, deviceinstallation.FieldAliasName)
}

// SetLongitude sets the "longitude" field.
func (m *DeviceInstallationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *DeviceInstallationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *DeviceInstallationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *DeviceInstallationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *DeviceInstallationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLatitude sets the "latitude" field.
func (m *DeviceInstallationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *DeviceInstallationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *DeviceInstallationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *DeviceInstallationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *DeviceInstallationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLocationData sets the "location_data" field.
func (m *DeviceInstallationMutation) SetLocationData(s string) {
	m.location_data = &s
}

// LocationData returns the value of the "location_data" field in the mutation.
func (m *DeviceInstallationMutation) LocationData() (r string, exists bool) {
	v := m.location_data
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationData returns the old "location_data" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLocationData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationData: %w", err)
	}
	return oldValue.LocationData, nil
}

// ClearLocationData clears the value of the "location_data" field.
func (m *DeviceInstallationMutation) ClearLocationData() {
	m.location_data = nil
	m.clearedFields[deviceinstallation.FieldLocationData] = struct{}{}
}

// LocationDataCleared returns if the "location_data" field was cleared in this mutation.
func (m *DeviceInstallationMutation) LocationDataCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldLocationData]
	return ok
}

// ResetLocationData resets all changes to the "location_data" field.
func (m *DeviceInstallationMutation) ResetLocationData() {
	m.location_data = nil
	delete(m.clearedFields, deviceinstallation.FieldLocationData)
}

// SetLocation sets the "location" field.
func (m *DeviceInstallationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *DeviceInstallationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *DeviceInstallationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[deviceinstallation.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *DeviceInstallationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *DeviceInstallationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, deviceinstallation.FieldLocation)
}

// SetInstaller sets the "installer" field.
func (m *DeviceInstallationMutation) SetInstaller(s string) {
	m.installer = &s
}

// Installer returns the value of the "installer" field in the mutation.
func (m *DeviceInstallationMutation) Installer() (r string, exists bool) {
	v := m.installer
	if v == nil {
		return
	}
	return *v, true
}

// OldInstaller returns the old "installer" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldInstaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstaller: %w", err)
	}
	return oldValue.Installer, nil
}

// ClearInstaller clears the value of the "installer" field.
func (m *DeviceInstallationMutation) ClearInstaller() {
	m.installer = nil
	m.clearedFields[deviceinstallation.FieldInstaller] = struct{}{}
}

// InstallerCleared returns if the "installer" field was cleared in this mutation.
func (m *DeviceInstallationMutation) InstallerCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldInstaller]
	return ok
}

// ResetInstaller resets all changes to the "installer" field.
func (m *DeviceInstallationMutation) ResetInstaller() {
	m.installer = nil
	delete(m.clearedFields, deviceinstallation.FieldInstaller)
}

// SetInstallTime sets the "install_time" field.
func (m *DeviceInstallationMutation) SetInstallTime(t time.Time) {
	m.install_time = &t
}

// InstallTime returns the value of the "install_time" field in the mutation.
func (m *DeviceInstallationMutation) InstallTime() (r time.Time, exists bool) {
	v := m.install_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallTime returns the old "install_time" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldInstallTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallTime: %w", err)
	}
	return oldValue.InstallTime, nil
}

// ClearInstallTime clears the value of the "install_time" field.
func (m *DeviceInstallationMutation) ClearInstallTime() {
	m.install_time = nil
	m.clearedFields[deviceinstallation.FieldInstallTime] = struct{}{}
}

// InstallTimeCleared returns if the "install_time" field was cleared in this mutation.
func (m *DeviceInstallationMutation) InstallTimeCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldInstallTime]
	return ok
}

// ResetInstallTime resets all changes to the "install_time" field.
func (m *DeviceInstallationMutation) ResetInstallTime() {
	m.install_time = nil
	delete(m.clearedFields, deviceinstallation.FieldInstallTime)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DeviceInstallationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[deviceinstallation.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DeviceInstallationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DeviceInstallationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *DeviceInstallationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[deviceinstallation.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *DeviceInstallationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *DeviceInstallationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearArea clears the "area" edge to the Area entity.
func (m *DeviceInstallationMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[deviceinstallation.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *DeviceInstallationMutation) AreaCleared() bool {
	return m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) AreaIDs() (ids []int) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *DeviceInstallationMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceInstallationMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[deviceinstallation.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceInstallationMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceInstallationMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the DeviceInstallationMutation builder.
func (m *DeviceInstallationMutation) Where(ps ...predicate.DeviceInstallation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInstallationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInstallationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInstallation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInstallationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInstallationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInstallation).
func (m *DeviceInstallationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInstallationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, deviceinstallation.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, deviceinstallation.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, deviceinstallation.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, deviceinstallation.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, deviceinstallation.FieldUpdateTime)
	}
	if m.device != nil {
		fields = append(fields, deviceinstallation.FieldDeviceID)
	}
	if m.area != nil {
		fields = append(fields, deviceinstallation.FieldAreaID)
	}
	if m.alias_name != nil {
		fields = append(fields, deviceinstallation.FieldAliasName)
	}
	if m.longitude != nil {
		fields = append(fields, deviceinstallation.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, deviceinstallation.FieldLatitude)
	}
	if m.location_data != nil {
		fields = append(fields, deviceinstallation.FieldLocationData)
	}
	if m.location != nil {
		fields = append(fields, deviceinstallation.FieldLocation)
	}
	if m.installer != nil {
		fields = append(fields, deviceinstallation.FieldInstaller)
	}
	if m.install_time != nil {
		fields = append(fields, deviceinstallation.FieldInstallTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInstallationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinstallation.FieldCreateTime:
		return m.CreateTime()
	case deviceinstallation.FieldCreatorID:
		return m.CreatorID()
	case deviceinstallation.FieldDeleteTime:
		return m.DeleteTime()
	case deviceinstallation.FieldUpdaterID:
		return m.UpdaterID()
	case deviceinstallation.FieldUpdateTime:
		return m.UpdateTime()
	case deviceinstallation.FieldDeviceID:
		return m.DeviceID()
	case deviceinstallation.FieldAreaID:
		return m.AreaID()
	case deviceinstallation.FieldAliasName:
		return m.AliasName()
	case deviceinstallation.FieldLongitude:
		return m.Longitude()
	case deviceinstallation.FieldLatitude:
		return m.Latitude()
	case deviceinstallation.FieldLocationData:
		return m.LocationData()
	case deviceinstallation.FieldLocation:
		return m.Location()
	case deviceinstallation.FieldInstaller:
		return m.Installer()
	case deviceinstallation.FieldInstallTime:
		return m.InstallTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInstallationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinstallation.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case deviceinstallation.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case deviceinstallation.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case deviceinstallation.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case deviceinstallation.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case deviceinstallation.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case deviceinstallation.FieldAreaID:
		return m.OldAreaID(ctx)
	case deviceinstallation.FieldAliasName:
		return m.OldAliasName(ctx)
	case deviceinstallation.FieldLongitude:
		return m.OldLongitude(ctx)
	case deviceinstallation.FieldLatitude:
		return m.OldLatitude(ctx)
	case deviceinstallation.FieldLocationData:
		return m.OldLocationData(ctx)
	case deviceinstallation.FieldLocation:
		return m.OldLocation(ctx)
	case deviceinstallation.FieldInstaller:
		return m.OldInstaller(ctx)
	case deviceinstallation.FieldInstallTime:
		return m.OldInstallTime(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInstallation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInstallationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinstallation.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case deviceinstallation.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case deviceinstallation.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case deviceinstallation.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case deviceinstallation.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case deviceinstallation.FieldDeviceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case deviceinstallation.FieldAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	case deviceinstallation.FieldAliasName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasName(v)
		return nil
	case deviceinstallation.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case deviceinstallation.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case deviceinstallation.FieldLocationData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationData(v)
		return nil
	case deviceinstallation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case deviceinstallation.FieldInstaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstaller(v)
		return nil
	case deviceinstallation.FieldInstallTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallTime(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInstallationMutation) AddedFields() []string {
	var fields []string
	if m.addlongitude != nil {
		fields = append(fields, deviceinstallation.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, deviceinstallation.FieldLatitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInstallationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceinstallation.FieldLongitude:
		return m.AddedLongitude()
	case deviceinstallation.FieldLatitude:
		return m.AddedLatitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInstallationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceinstallation.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case deviceinstallation.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInstallationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinstallation.FieldDeleteTime) {
		fields = append(fields, deviceinstallation.FieldDeleteTime)
	}
	if m.FieldCleared(deviceinstallation.FieldAliasName) {
		fields = append(fields, deviceinstallation.FieldAliasName)
	}
	if m.FieldCleared(deviceinstallation.FieldLocationData) {
		fields = append(fields, deviceinstallation.FieldLocationData)
	}
	if m.FieldCleared(deviceinstallation.FieldLocation) {
		fields = append(fields, deviceinstallation.FieldLocation)
	}
	if m.FieldCleared(deviceinstallation.FieldInstaller) {
		fields = append(fields, deviceinstallation.FieldInstaller)
	}
	if m.FieldCleared(deviceinstallation.FieldInstallTime) {
		fields = append(fields, deviceinstallation.FieldInstallTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInstallationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInstallationMutation) ClearField(name string) error {
	switch name {
	case deviceinstallation.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case deviceinstallation.FieldAliasName:
		m.ClearAliasName()
		return nil
	case deviceinstallation.FieldLocationData:
		m.ClearLocationData()
		return nil
	case deviceinstallation.FieldLocation:
		m.ClearLocation()
		return nil
	case deviceinstallation.FieldInstaller:
		m.ClearInstaller()
		return nil
	case deviceinstallation.FieldInstallTime:
		m.ClearInstallTime()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInstallationMutation) ResetField(name string) error {
	switch name {
	case deviceinstallation.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case deviceinstallation.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case deviceinstallation.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case deviceinstallation.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case deviceinstallation.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case deviceinstallation.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case deviceinstallation.FieldAreaID:
		m.ResetAreaID()
		return nil
	case deviceinstallation.FieldAliasName:
		m.ResetAliasName()
		return nil
	case deviceinstallation.FieldLongitude:
		m.ResetLongitude()
		return nil
	case deviceinstallation.FieldLatitude:
		m.ResetLatitude()
		return nil
	case deviceinstallation.FieldLocationData:
		m.ResetLocationData()
		return nil
	case deviceinstallation.FieldLocation:
		m.ResetLocation()
		return nil
	case deviceinstallation.FieldInstaller:
		m.ResetInstaller()
		return nil
	case deviceinstallation.FieldInstallTime:
		m.ResetInstallTime()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInstallationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, deviceinstallation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, deviceinstallation.EdgeUpdater)
	}
	if m.area != nil {
		edges = append(edges, deviceinstallation.EdgeArea)
	}
	if m.device != nil {
		edges = append(edges, deviceinstallation.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInstallationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinstallation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case deviceinstallation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case deviceinstallation.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	case deviceinstallation.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInstallationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInstallationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInstallationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, deviceinstallation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, deviceinstallation.EdgeUpdater)
	}
	if m.clearedarea {
		edges = append(edges, deviceinstallation.EdgeArea)
	}
	if m.cleareddevice {
		edges = append(edges, deviceinstallation.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInstallationMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinstallation.EdgeCreator:
		return m.clearedcreator
	case deviceinstallation.EdgeUpdater:
		return m.clearedupdater
	case deviceinstallation.EdgeArea:
		return m.clearedarea
	case deviceinstallation.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInstallationMutation) ClearEdge(name string) error {
	switch name {
	case deviceinstallation.EdgeCreator:
		m.ClearCreator()
		return nil
	case deviceinstallation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case deviceinstallation.EdgeArea:
		m.ClearArea()
		return nil
	case deviceinstallation.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInstallationMutation) ResetEdge(name string) error {
	switch name {
	case deviceinstallation.EdgeCreator:
		m.ResetCreator()
		return nil
	case deviceinstallation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case deviceinstallation.EdgeArea:
		m.ResetArea()
		return nil
	case deviceinstallation.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	delete_time       *time.Time
	update_time       *time.Time
	clearedFields     map[string]struct{}
	creator           *int
	clearedcreator    bool
	updater           *int
	clearedupdater    bool
	admin             *int
	clearedadmin      bool
	occupation        *int
	clearedoccupation bool
	department        *int
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*Employee, error)
	predicates        []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EmployeeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EmployeeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EmployeeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *EmployeeMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *EmployeeMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *EmployeeMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *EmployeeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *EmployeeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *EmployeeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[employee.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *EmployeeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *EmployeeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, employee.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *EmployeeMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *EmployeeMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *EmployeeMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EmployeeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EmployeeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EmployeeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAdminID sets the "admin_id" field.
func (m *EmployeeMutation) SetAdminID(i int) {
	m.admin = &i
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *EmployeeMutation) AdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *EmployeeMutation) ResetAdminID() {
	m.admin = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *EmployeeMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *EmployeeMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *EmployeeMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[employee.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *EmployeeMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[employee.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *EmployeeMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, employee.FieldDepartmentID)
}

// SetOccupationID sets the "occupation_id" field.
func (m *EmployeeMutation) SetOccupationID(i int) {
	m.occupation = &i
}

// OccupationID returns the value of the "occupation_id" field in the mutation.
func (m *EmployeeMutation) OccupationID() (r int, exists bool) {
	v := m.occupation
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupationID returns the old "occupation_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldOccupationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOccupationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOccupationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupationID: %w", err)
	}
	return oldValue.OccupationID, nil
}

// ClearOccupationID clears the value of the "occupation_id" field.
func (m *EmployeeMutation) ClearOccupationID() {
	m.occupation = nil
	m.clearedFields[employee.FieldOccupationID] = struct{}{}
}

// OccupationIDCleared returns if the "occupation_id" field was cleared in this mutation.
func (m *EmployeeMutation) OccupationIDCleared() bool {
	_, ok := m.clearedFields[employee.FieldOccupationID]
	return ok
}

// ResetOccupationID resets all changes to the "occupation_id" field.
func (m *EmployeeMutation) ResetOccupationID() {
	m.occupation = nil
	delete(m.clearedFields, employee.FieldOccupationID)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EmployeeMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[employee.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EmployeeMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EmployeeMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *EmployeeMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[employee.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *EmployeeMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *EmployeeMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *EmployeeMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[employee.FieldAdminID] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *EmployeeMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *EmployeeMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearOccupation clears the "occupation" edge to the Occupation entity.
func (m *EmployeeMutation) ClearOccupation() {
	m.clearedoccupation = true
	m.clearedFields[employee.FieldOccupationID] = struct{}{}
}

// OccupationCleared reports if the "occupation" edge to the Occupation entity was cleared.
func (m *EmployeeMutation) OccupationCleared() bool {
	return m.OccupationIDCleared() || m.clearedoccupation
}

// OccupationIDs returns the "occupation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OccupationID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) OccupationIDs() (ids []int) {
	if id := m.occupation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOccupation resets all changes to the "occupation" edge.
func (m *EmployeeMutation) ResetOccupation() {
	m.occupation = nil
	m.clearedoccupation = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[employee.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, employee.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, employee.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, employee.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, employee.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, employee.FieldUpdateTime)
	}
	if m.admin != nil {
		fields = append(fields, employee.FieldAdminID)
	}
	if m.department != nil {
		fields = append(fields, employee.FieldDepartmentID)
	}
	if m.occupation != nil {
		fields = append(fields, employee.FieldOccupationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreateTime:
		return m.CreateTime()
	case employee.FieldCreatorID:
		return m.CreatorID()
	case employee.FieldDeleteTime:
		return m.DeleteTime()
	case employee.FieldUpdaterID:
		return m.UpdaterID()
	case employee.FieldUpdateTime:
		return m.UpdateTime()
	case employee.FieldAdminID:
		return m.AdminID()
	case employee.FieldDepartmentID:
		return m.DepartmentID()
	case employee.FieldOccupationID:
		return m.OccupationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case employee.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case employee.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case employee.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case employee.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case employee.FieldAdminID:
		return m.OldAdminID(ctx)
	case employee.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case employee.FieldOccupationID:
		return m.OldOccupationID(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case employee.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case employee.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case employee.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case employee.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case employee.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case employee.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case employee.FieldOccupationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupationID(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeleteTime) {
		fields = append(fields, employee.FieldDeleteTime)
	}
	if m.FieldCleared(employee.FieldDepartmentID) {
		fields = append(fields, employee.FieldDepartmentID)
	}
	if m.FieldCleared(employee.FieldOccupationID) {
		fields = append(fields, employee.FieldOccupationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case employee.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case employee.FieldOccupationID:
		m.ClearOccupationID()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case employee.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case employee.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case employee.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case employee.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case employee.FieldAdminID:
		m.ResetAdminID()
		return nil
	case employee.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case employee.FieldOccupationID:
		m.ResetOccupationID()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, employee.EdgeUpdater)
	}
	if m.admin != nil {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.occupation != nil {
		edges = append(edges, employee.EdgeOccupation)
	}
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeOccupation:
		if id := m.occupation; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, employee.EdgeUpdater)
	}
	if m.clearedadmin {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.clearedoccupation {
		edges = append(edges, employee.EdgeOccupation)
	}
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCreator:
		return m.clearedcreator
	case employee.EdgeUpdater:
		return m.clearedupdater
	case employee.EdgeAdmin:
		return m.clearedadmin
	case employee.EdgeOccupation:
		return m.clearedoccupation
	case employee.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ClearCreator()
		return nil
	case employee.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case employee.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case employee.EdgeOccupation:
		m.ClearOccupation()
		return nil
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ResetCreator()
		return nil
	case employee.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case employee.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case employee.EdgeOccupation:
		m.ResetOccupation()
		return nil
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	delete_time          *time.Time
	update_time          *time.Time
	event_time           *time.Time
	event_type           *enums.EventType
	addevent_type        *enums.EventType
	event_status         *enums.EventStatus
	addevent_status      *enums.EventStatus
	images               *[]*types.UploadedImage
	appendimages         []*types.UploadedImage
	labeled_images       *[]*types.UploadedImage
	appendlabeled_images []*types.UploadedImage
	data_id              *string
	description          *string
	raw_data             *string
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	updater              *int
	clearedupdater       bool
	video                *int
	clearedvideo         bool
	device               *int
	cleareddevice        bool
	fixing               *int
	clearedfixing        bool
	event_log            map[int]struct{}
	removedevent_log     map[int]struct{}
	clearedevent_log     bool
	done                 bool
	oldValue             func(context.Context) (*Event, error)
	predicates           []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EventMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EventMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EventMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *EventMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *EventMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *EventMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *EventMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *EventMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *EventMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[event.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *EventMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[event.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *EventMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, event.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *EventMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *EventMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *EventMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EventMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EventMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EventMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeviceID sets the "device_id" field.
func (m *EventMutation) SetDeviceID(i int) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *EventMutation) DeviceID() (r int, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeviceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *EventMutation) ResetDeviceID() {
	m.device = nil
}

// SetVideoID sets the "video_id" field.
func (m *EventMutation) SetVideoID(i int) {
	m.video = &i
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *EventMutation) VideoID() (r int, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ClearVideoID clears the value of the "video_id" field.
func (m *EventMutation) ClearVideoID() {
	m.video = nil
	m.clearedFields[event.FieldVideoID] = struct{}{}
}

// VideoIDCleared returns if the "video_id" field was cleared in this mutation.
func (m *EventMutation) VideoIDCleared() bool {
	_, ok := m.clearedFields[event.FieldVideoID]
	return ok
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *EventMutation) ResetVideoID() {
	m.video = nil
	delete(m.clearedFields, event.FieldVideoID)
}

// SetEventTime sets the "event_time" field.
func (m *EventMutation) SetEventTime(t time.Time) {
	m.event_time = &t
}

// EventTime returns the value of the "event_time" field in the mutation.
func (m *EventMutation) EventTime() (r time.Time, exists bool) {
	v := m.event_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTime returns the old "event_time" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTime: %w", err)
	}
	return oldValue.EventTime, nil
}

// ResetEventTime resets all changes to the "event_time" field.
func (m *EventMutation) ResetEventTime() {
	m.event_time = nil
}

// SetEventType sets the "event_type" field.
func (m *EventMutation) SetEventType(et enums.EventType) {
	m.event_type = &et
	m.addevent_type = nil
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *EventMutation) EventType() (r enums.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventType(ctx context.Context) (v enums.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// AddEventType adds et to the "event_type" field.
func (m *EventMutation) AddEventType(et enums.EventType) {
	if m.addevent_type != nil {
		*m.addevent_type += et
	} else {
		m.addevent_type = &et
	}
}

// AddedEventType returns the value that was added to the "event_type" field in this mutation.
func (m *EventMutation) AddedEventType() (r enums.EventType, exists bool) {
	v := m.addevent_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventType resets all changes to the "event_type" field.
func (m *EventMutation) ResetEventType() {
	m.event_type = nil
	m.addevent_type = nil
}

// SetEventStatus sets the "event_status" field.
func (m *EventMutation) SetEventStatus(es enums.EventStatus) {
	m.event_status = &es
	m.addevent_status = nil
}

// EventStatus returns the value of the "event_status" field in the mutation.
func (m *EventMutation) EventStatus() (r enums.EventStatus, exists bool) {
	v := m.event_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEventStatus returns the old "event_status" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldEventStatus(ctx context.Context) (v enums.EventStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventStatus: %w", err)
	}
	return oldValue.EventStatus, nil
}

// AddEventStatus adds es to the "event_status" field.
func (m *EventMutation) AddEventStatus(es enums.EventStatus) {
	if m.addevent_status != nil {
		*m.addevent_status += es
	} else {
		m.addevent_status = &es
	}
}

// AddedEventStatus returns the value that was added to the "event_status" field in this mutation.
func (m *EventMutation) AddedEventStatus() (r enums.EventStatus, exists bool) {
	v := m.addevent_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventStatus resets all changes to the "event_status" field.
func (m *EventMutation) ResetEventStatus() {
	m.event_status = nil
	m.addevent_status = nil
}

// SetImages sets the "images" field.
func (m *EventMutation) SetImages(ti []*types.UploadedImage) {
	m.images = &ti
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *EventMutation) Images() (r []*types.UploadedImage, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldImages(ctx context.Context) (v []*types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds ti to the "images" field.
func (m *EventMutation) AppendImages(ti []*types.UploadedImage) {
	m.appendimages = append(m.appendimages, ti...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *EventMutation) AppendedImages() ([]*types.UploadedImage, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *EventMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[event.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *EventMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[event.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *EventMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, event.FieldImages)
}

// SetLabeledImages sets the "labeled_images" field.
func (m *EventMutation) SetLabeledImages(ti []*types.UploadedImage) {
	m.labeled_images = &ti
	m.appendlabeled_images = nil
}

// LabeledImages returns the value of the "labeled_images" field in the mutation.
func (m *EventMutation) LabeledImages() (r []*types.UploadedImage, exists bool) {
	v := m.labeled_images
	if v == nil {
		return
	}
	return *v, true
}

// OldLabeledImages returns the old "labeled_images" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldLabeledImages(ctx context.Context) (v []*types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabeledImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabeledImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabeledImages: %w", err)
	}
	return oldValue.LabeledImages, nil
}

// AppendLabeledImages adds ti to the "labeled_images" field.
func (m *EventMutation) AppendLabeledImages(ti []*types.UploadedImage) {
	m.appendlabeled_images = append(m.appendlabeled_images, ti...)
}

// AppendedLabeledImages returns the list of values that were appended to the "labeled_images" field in this mutation.
func (m *EventMutation) AppendedLabeledImages() ([]*types.UploadedImage, bool) {
	if len(m.appendlabeled_images) == 0 {
		return nil, false
	}
	return m.appendlabeled_images, true
}

// ClearLabeledImages clears the value of the "labeled_images" field.
func (m *EventMutation) ClearLabeledImages() {
	m.labeled_images = nil
	m.appendlabeled_images = nil
	m.clearedFields[event.FieldLabeledImages] = struct{}{}
}

// LabeledImagesCleared returns if the "labeled_images" field was cleared in this mutation.
func (m *EventMutation) LabeledImagesCleared() bool {
	_, ok := m.clearedFields[event.FieldLabeledImages]
	return ok
}

// ResetLabeledImages resets all changes to the "labeled_images" field.
func (m *EventMutation) ResetLabeledImages() {
	m.labeled_images = nil
	m.appendlabeled_images = nil
	delete(m.clearedFields, event.FieldLabeledImages)
}

// SetDataID sets the "data_id" field.
func (m *EventMutation) SetDataID(s string) {
	m.data_id = &s
}

// DataID returns the value of the "data_id" field in the mutation.
func (m *EventMutation) DataID() (r string, exists bool) {
	v := m.data_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDataID returns the old "data_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDataID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataID: %w", err)
	}
	return oldValue.DataID, nil
}

// ResetDataID resets all changes to the "data_id" field.
func (m *EventMutation) ResetDataID() {
	m.data_id = nil
}

// SetDescription sets the "description" field.
func (m *EventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[event.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[event.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, event.FieldDescription)
}

// SetRawData sets the "raw_data" field.
func (m *EventMutation) SetRawData(s string) {
	m.raw_data = &s
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *EventMutation) RawData() (r string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldRawData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ClearRawData clears the value of the "raw_data" field.
func (m *EventMutation) ClearRawData() {
	m.raw_data = nil
	m.clearedFields[event.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *EventMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[event.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *EventMutation) ResetRawData() {
	m.raw_data = nil
	delete(m.clearedFields, event.FieldRawData)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EventMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[event.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EventMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EventMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EventMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *EventMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[event.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *EventMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *EventMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *EventMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *EventMutation) ClearVideo() {
	m.clearedvideo = true
	m.clearedFields[event.FieldVideoID] = struct{}{}
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *EventMutation) VideoCleared() bool {
	return m.VideoIDCleared() || m.clearedvideo
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *EventMutation) VideoIDs() (ids []int) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *EventMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *EventMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[event.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *EventMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *EventMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *EventMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// SetFixingID sets the "fixing" edge to the Fixing entity by id.
func (m *EventMutation) SetFixingID(id int) {
	m.fixing = &id
}

// ClearFixing clears the "fixing" edge to the Fixing entity.
func (m *EventMutation) ClearFixing() {
	m.clearedfixing = true
}

// FixingCleared reports if the "fixing" edge to the Fixing entity was cleared.
func (m *EventMutation) FixingCleared() bool {
	return m.clearedfixing
}

// FixingID returns the "fixing" edge ID in the mutation.
func (m *EventMutation) FixingID() (id int, exists bool) {
	if m.fixing != nil {
		return *m.fixing, true
	}
	return
}

// FixingIDs returns the "fixing" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FixingID instead. It exists only for internal usage by the builders.
func (m *EventMutation) FixingIDs() (ids []int) {
	if id := m.fixing; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFixing resets all changes to the "fixing" edge.
func (m *EventMutation) ResetFixing() {
	m.fixing = nil
	m.clearedfixing = false
}

// AddEventLogIDs adds the "event_log" edge to the EventLog entity by ids.
func (m *EventMutation) AddEventLogIDs(ids ...int) {
	if m.event_log == nil {
		m.event_log = make(map[int]struct{})
	}
	for i := range ids {
		m.event_log[ids[i]] = struct{}{}
	}
}

// ClearEventLog clears the "event_log" edge to the EventLog entity.
func (m *EventMutation) ClearEventLog() {
	m.clearedevent_log = true
}

// EventLogCleared reports if the "event_log" edge to the EventLog entity was cleared.
func (m *EventMutation) EventLogCleared() bool {
	return m.clearedevent_log
}

// RemoveEventLogIDs removes the "event_log" edge to the EventLog entity by IDs.
func (m *EventMutation) RemoveEventLogIDs(ids ...int) {
	if m.removedevent_log == nil {
		m.removedevent_log = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_log, ids[i])
		m.removedevent_log[ids[i]] = struct{}{}
	}
}

// RemovedEventLog returns the removed IDs of the "event_log" edge to the EventLog entity.
func (m *EventMutation) RemovedEventLogIDs() (ids []int) {
	for id := range m.removedevent_log {
		ids = append(ids, id)
	}
	return
}

// EventLogIDs returns the "event_log" edge IDs in the mutation.
func (m *EventMutation) EventLogIDs() (ids []int) {
	for id := range m.event_log {
		ids = append(ids, id)
	}
	return
}

// ResetEventLog resets all changes to the "event_log" edge.
func (m *EventMutation) ResetEventLog() {
	m.event_log = nil
	m.clearedevent_log = false
	m.removedevent_log = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.create_time != nil {
		fields = append(fields, event.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, event.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, event.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, event.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, event.FieldUpdateTime)
	}
	if m.device != nil {
		fields = append(fields, event.FieldDeviceID)
	}
	if m.video != nil {
		fields = append(fields, event.FieldVideoID)
	}
	if m.event_time != nil {
		fields = append(fields, event.FieldEventTime)
	}
	if m.event_type != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.event_status != nil {
		fields = append(fields, event.FieldEventStatus)
	}
	if m.images != nil {
		fields = append(fields, event.FieldImages)
	}
	if m.labeled_images != nil {
		fields = append(fields, event.FieldLabeledImages)
	}
	if m.data_id != nil {
		fields = append(fields, event.FieldDataID)
	}
	if m.description != nil {
		fields = append(fields, event.FieldDescription)
	}
	if m.raw_data != nil {
		fields = append(fields, event.FieldRawData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreateTime:
		return m.CreateTime()
	case event.FieldCreatorID:
		return m.CreatorID()
	case event.FieldDeleteTime:
		return m.DeleteTime()
	case event.FieldUpdaterID:
		return m.UpdaterID()
	case event.FieldUpdateTime:
		return m.UpdateTime()
	case event.FieldDeviceID:
		return m.DeviceID()
	case event.FieldVideoID:
		return m.VideoID()
	case event.FieldEventTime:
		return m.EventTime()
	case event.FieldEventType:
		return m.EventType()
	case event.FieldEventStatus:
		return m.EventStatus()
	case event.FieldImages:
		return m.Images()
	case event.FieldLabeledImages:
		return m.LabeledImages()
	case event.FieldDataID:
		return m.DataID()
	case event.FieldDescription:
		return m.Description()
	case event.FieldRawData:
		return m.RawData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case event.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case event.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case event.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case event.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case event.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case event.FieldVideoID:
		return m.OldVideoID(ctx)
	case event.FieldEventTime:
		return m.OldEventTime(ctx)
	case event.FieldEventType:
		return m.OldEventType(ctx)
	case event.FieldEventStatus:
		return m.OldEventStatus(ctx)
	case event.FieldImages:
		return m.OldImages(ctx)
	case event.FieldLabeledImages:
		return m.OldLabeledImages(ctx)
	case event.FieldDataID:
		return m.OldDataID(ctx)
	case event.FieldDescription:
		return m.OldDescription(ctx)
	case event.FieldRawData:
		return m.OldRawData(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case event.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case event.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case event.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case event.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case event.FieldDeviceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case event.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case event.FieldEventTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTime(v)
		return nil
	case event.FieldEventType:
		v, ok := value.(enums.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case event.FieldEventStatus:
		v, ok := value.(enums.EventStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventStatus(v)
		return nil
	case event.FieldImages:
		v, ok := value.([]*types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case event.FieldLabeledImages:
		v, ok := value.([]*types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabeledImages(v)
		return nil
	case event.FieldDataID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataID(v)
		return nil
	case event.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case event.FieldRawData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addevent_type != nil {
		fields = append(fields, event.FieldEventType)
	}
	if m.addevent_status != nil {
		fields = append(fields, event.FieldEventStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldEventType:
		return m.AddedEventType()
	case event.FieldEventStatus:
		return m.AddedEventStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldEventType:
		v, ok := value.(enums.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventType(v)
		return nil
	case event.FieldEventStatus:
		v, ok := value.(enums.EventStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDeleteTime) {
		fields = append(fields, event.FieldDeleteTime)
	}
	if m.FieldCleared(event.FieldVideoID) {
		fields = append(fields, event.FieldVideoID)
	}
	if m.FieldCleared(event.FieldImages) {
		fields = append(fields, event.FieldImages)
	}
	if m.FieldCleared(event.FieldLabeledImages) {
		fields = append(fields, event.FieldLabeledImages)
	}
	if m.FieldCleared(event.FieldDescription) {
		fields = append(fields, event.FieldDescription)
	}
	if m.FieldCleared(event.FieldRawData) {
		fields = append(fields, event.FieldRawData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case event.FieldVideoID:
		m.ClearVideoID()
		return nil
	case event.FieldImages:
		m.ClearImages()
		return nil
	case event.FieldLabeledImages:
		m.ClearLabeledImages()
		return nil
	case event.FieldDescription:
		m.ClearDescription()
		return nil
	case event.FieldRawData:
		m.ClearRawData()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case event.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case event.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case event.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case event.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case event.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case event.FieldVideoID:
		m.ResetVideoID()
		return nil
	case event.FieldEventTime:
		m.ResetEventTime()
		return nil
	case event.FieldEventType:
		m.ResetEventType()
		return nil
	case event.FieldEventStatus:
		m.ResetEventStatus()
		return nil
	case event.FieldImages:
		m.ResetImages()
		return nil
	case event.FieldLabeledImages:
		m.ResetLabeledImages()
		return nil
	case event.FieldDataID:
		m.ResetDataID()
		return nil
	case event.FieldDescription:
		m.ResetDescription()
		return nil
	case event.FieldRawData:
		m.ResetRawData()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.creator != nil {
		edges = append(edges, event.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, event.EdgeUpdater)
	}
	if m.video != nil {
		edges = append(edges, event.EdgeVideo)
	}
	if m.device != nil {
		edges = append(edges, event.EdgeDevice)
	}
	if m.fixing != nil {
		edges = append(edges, event.EdgeFixing)
	}
	if m.event_log != nil {
		edges = append(edges, event.EdgeEventLog)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeFixing:
		if id := m.fixing; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeEventLog:
		ids := make([]ent.Value, 0, len(m.event_log))
		for id := range m.event_log {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedevent_log != nil {
		edges = append(edges, event.EdgeEventLog)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeEventLog:
		ids := make([]ent.Value, 0, len(m.removedevent_log))
		for id := range m.removedevent_log {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcreator {
		edges = append(edges, event.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, event.EdgeUpdater)
	}
	if m.clearedvideo {
		edges = append(edges, event.EdgeVideo)
	}
	if m.cleareddevice {
		edges = append(edges, event.EdgeDevice)
	}
	if m.clearedfixing {
		edges = append(edges, event.EdgeFixing)
	}
	if m.clearedevent_log {
		edges = append(edges, event.EdgeEventLog)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeCreator:
		return m.clearedcreator
	case event.EdgeUpdater:
		return m.clearedupdater
	case event.EdgeVideo:
		return m.clearedvideo
	case event.EdgeDevice:
		return m.cleareddevice
	case event.EdgeFixing:
		return m.clearedfixing
	case event.EdgeEventLog:
		return m.clearedevent_log
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeCreator:
		m.ClearCreator()
		return nil
	case event.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case event.EdgeVideo:
		m.ClearVideo()
		return nil
	case event.EdgeDevice:
		m.ClearDevice()
		return nil
	case event.EdgeFixing:
		m.ClearFixing()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeCreator:
		m.ResetCreator()
		return nil
	case event.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case event.EdgeVideo:
		m.ResetVideo()
		return nil
	case event.EdgeDevice:
		m.ResetDevice()
		return nil
	case event.EdgeFixing:
		m.ResetFixing()
		return nil
	case event.EdgeEventLog:
		m.ResetEventLog()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// EventLevelMutation represents an operation that mutates the EventLevel nodes in the graph.
type EventLevelMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	create_time        *time.Time
	delete_time        *time.Time
	update_time        *time.Time
	name               *string
	event_types        *[]enums.EventType
	appendevent_types  []enums.EventType
	description        *string
	icon               *string
	notify_types       *[]enums.NotifyType
	appendnotify_types []enums.NotifyType
	clearedFields      map[string]struct{}
	creator            *int
	clearedcreator     bool
	updater            *int
	clearedupdater     bool
	done               bool
	oldValue           func(context.Context) (*EventLevel, error)
	predicates         []predicate.EventLevel
}

var _ ent.Mutation = (*EventLevelMutation)(nil)

// eventlevelOption allows management of the mutation configuration using functional options.
type eventlevelOption func(*EventLevelMutation)

// newEventLevelMutation creates new mutation for the EventLevel entity.
func newEventLevelMutation(c config, op Op, opts ...eventlevelOption) *EventLevelMutation {
	m := &EventLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeEventLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventLevelID sets the ID field of the mutation.
func withEventLevelID(id int) eventlevelOption {
	return func(m *EventLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *EventLevel
		)
		m.oldValue = func(ctx context.Context) (*EventLevel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventLevel sets the old EventLevel of the mutation.
func withEventLevel(node *EventLevel) eventlevelOption {
	return func(m *EventLevelMutation) {
		m.oldValue = func(context.Context) (*EventLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventLevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventLevelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventLevel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EventLevelMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EventLevelMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EventLevelMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *EventLevelMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *EventLevelMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *EventLevelMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *EventLevelMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *EventLevelMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *EventLevelMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[eventlevel.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *EventLevelMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *EventLevelMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, eventlevel.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *EventLevelMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *EventLevelMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *EventLevelMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EventLevelMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EventLevelMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EventLevelMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *EventLevelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventLevelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EventLevelMutation) ClearName() {
	m.name = nil
	m.clearedFields[eventlevel.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EventLevelMutation) NameCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EventLevelMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, eventlevel.FieldName)
}

// SetEventTypes sets the "event_types" field.
func (m *EventLevelMutation) SetEventTypes(et []enums.EventType) {
	m.event_types = &et
	m.appendevent_types = nil
}

// EventTypes returns the value of the "event_types" field in the mutation.
func (m *EventLevelMutation) EventTypes() (r []enums.EventType, exists bool) {
	v := m.event_types
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTypes returns the old "event_types" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldEventTypes(ctx context.Context) (v []enums.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTypes: %w", err)
	}
	return oldValue.EventTypes, nil
}

// AppendEventTypes adds et to the "event_types" field.
func (m *EventLevelMutation) AppendEventTypes(et []enums.EventType) {
	m.appendevent_types = append(m.appendevent_types, et...)
}

// AppendedEventTypes returns the list of values that were appended to the "event_types" field in this mutation.
func (m *EventLevelMutation) AppendedEventTypes() ([]enums.EventType, bool) {
	if len(m.appendevent_types) == 0 {
		return nil, false
	}
	return m.appendevent_types, true
}

// ResetEventTypes resets all changes to the "event_types" field.
func (m *EventLevelMutation) ResetEventTypes() {
	m.event_types = nil
	m.appendevent_types = nil
}

// SetDescription sets the "description" field.
func (m *EventLevelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventLevelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventLevelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[eventlevel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventLevelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventLevelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, eventlevel.FieldDescription)
}

// SetIcon sets the "icon" field.
func (m *EventLevelMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *EventLevelMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *EventLevelMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[eventlevel.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *EventLevelMutation) IconCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *EventLevelMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, eventlevel.FieldIcon)
}

// SetNotifyTypes sets the "notify_types" field.
func (m *EventLevelMutation) SetNotifyTypes(et []enums.NotifyType) {
	m.notify_types = &et
	m.appendnotify_types = nil
}

// NotifyTypes returns the value of the "notify_types" field in the mutation.
func (m *EventLevelMutation) NotifyTypes() (r []enums.NotifyType, exists bool) {
	v := m.notify_types
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTypes returns the old "notify_types" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldNotifyTypes(ctx context.Context) (v []enums.NotifyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTypes: %w", err)
	}
	return oldValue.NotifyTypes, nil
}

// AppendNotifyTypes adds et to the "notify_types" field.
func (m *EventLevelMutation) AppendNotifyTypes(et []enums.NotifyType) {
	m.appendnotify_types = append(m.appendnotify_types, et...)
}

// AppendedNotifyTypes returns the list of values that were appended to the "notify_types" field in this mutation.
func (m *EventLevelMutation) AppendedNotifyTypes() ([]enums.NotifyType, bool) {
	if len(m.appendnotify_types) == 0 {
		return nil, false
	}
	return m.appendnotify_types, true
}

// ResetNotifyTypes resets all changes to the "notify_types" field.
func (m *EventLevelMutation) ResetNotifyTypes() {
	m.notify_types = nil
	m.appendnotify_types = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EventLevelMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[eventlevel.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EventLevelMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EventLevelMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EventLevelMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *EventLevelMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[eventlevel.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *EventLevelMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *EventLevelMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *EventLevelMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// Where appends a list predicates to the EventLevelMutation builder.
func (m *EventLevelMutation) Where(ps ...predicate.EventLevel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventLevelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventLevelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventLevel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventLevelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventLevelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventLevel).
func (m *EventLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventLevelMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, eventlevel.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, eventlevel.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, eventlevel.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, eventlevel.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, eventlevel.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, eventlevel.FieldName)
	}
	if m.event_types != nil {
		fields = append(fields, eventlevel.FieldEventTypes)
	}
	if m.description != nil {
		fields = append(fields, eventlevel.FieldDescription)
	}
	if m.icon != nil {
		fields = append(fields, eventlevel.FieldIcon)
	}
	if m.notify_types != nil {
		fields = append(fields, eventlevel.FieldNotifyTypes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventlevel.FieldCreateTime:
		return m.CreateTime()
	case eventlevel.FieldCreatorID:
		return m.CreatorID()
	case eventlevel.FieldDeleteTime:
		return m.DeleteTime()
	case eventlevel.FieldUpdaterID:
		return m.UpdaterID()
	case eventlevel.FieldUpdateTime:
		return m.UpdateTime()
	case eventlevel.FieldName:
		return m.Name()
	case eventlevel.FieldEventTypes:
		return m.EventTypes()
	case eventlevel.FieldDescription:
		return m.Description()
	case eventlevel.FieldIcon:
		return m.Icon()
	case eventlevel.FieldNotifyTypes:
		return m.NotifyTypes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventlevel.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case eventlevel.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case eventlevel.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case eventlevel.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case eventlevel.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case eventlevel.FieldName:
		return m.OldName(ctx)
	case eventlevel.FieldEventTypes:
		return m.OldEventTypes(ctx)
	case eventlevel.FieldDescription:
		return m.OldDescription(ctx)
	case eventlevel.FieldIcon:
		return m.OldIcon(ctx)
	case eventlevel.FieldNotifyTypes:
		return m.OldNotifyTypes(ctx)
	}
	return nil, fmt.Errorf("unknown EventLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventlevel.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case eventlevel.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case eventlevel.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case eventlevel.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case eventlevel.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case eventlevel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case eventlevel.FieldEventTypes:
		v, ok := value.([]enums.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTypes(v)
		return nil
	case eventlevel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case eventlevel.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case eventlevel.FieldNotifyTypes:
		v, ok := value.([]enums.NotifyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTypes(v)
		return nil
	}
	return fmt.Errorf("unknown EventLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventLevelMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventLevelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventLevelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventlevel.FieldDeleteTime) {
		fields = append(fields, eventlevel.FieldDeleteTime)
	}
	if m.FieldCleared(eventlevel.FieldName) {
		fields = append(fields, eventlevel.FieldName)
	}
	if m.FieldCleared(eventlevel.FieldDescription) {
		fields = append(fields, eventlevel.FieldDescription)
	}
	if m.FieldCleared(eventlevel.FieldIcon) {
		fields = append(fields, eventlevel.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventLevelMutation) ClearField(name string) error {
	switch name {
	case eventlevel.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case eventlevel.FieldName:
		m.ClearName()
		return nil
	case eventlevel.FieldDescription:
		m.ClearDescription()
		return nil
	case eventlevel.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown EventLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventLevelMutation) ResetField(name string) error {
	switch name {
	case eventlevel.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case eventlevel.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case eventlevel.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case eventlevel.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case eventlevel.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case eventlevel.FieldName:
		m.ResetName()
		return nil
	case eventlevel.FieldEventTypes:
		m.ResetEventTypes()
		return nil
	case eventlevel.FieldDescription:
		m.ResetDescription()
		return nil
	case eventlevel.FieldIcon:
		m.ResetIcon()
		return nil
	case eventlevel.FieldNotifyTypes:
		m.ResetNotifyTypes()
		return nil
	}
	return fmt.Errorf("unknown EventLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, eventlevel.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, eventlevel.EdgeUpdater)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventlevel.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case eventlevel.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventLevelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, eventlevel.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, eventlevel.EdgeUpdater)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case eventlevel.EdgeCreator:
		return m.clearedcreator
	case eventlevel.EdgeUpdater:
		return m.clearedupdater
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventLevelMutation) ClearEdge(name string) error {
	switch name {
	case eventlevel.EdgeCreator:
		m.ClearCreator()
		return nil
	case eventlevel.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown EventLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventLevelMutation) ResetEdge(name string) error {
	switch name {
	case eventlevel.EdgeCreator:
		m.ResetCreator()
		return nil
	case eventlevel.EdgeUpdater:
		m.ResetUpdater()
		return nil
	}
	return fmt.Errorf("unknown EventLevel edge %s", name)
}

// EventLogMutation represents an operation that mutates the EventLog nodes in the graph.
type EventLogMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	delete_time    *time.Time
	update_time    *time.Time
	log_type       *enums.EventLogType
	addlog_type    *enums.EventLogType
	notes          *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	event          *int
	clearedevent   bool
	device         *int
	cleareddevice  bool
	actor          *int
	clearedactor   bool
	actor2         *int
	clearedactor2  bool
	done           bool
	oldValue       func(context.Context) (*EventLog, error)
	predicates     []predicate.EventLog
}

var _ ent.Mutation = (*EventLogMutation)(nil)

// eventlogOption allows management of the mutation configuration using functional options.
type eventlogOption func(*EventLogMutation)

// newEventLogMutation creates new mutation for the EventLog entity.
func newEventLogMutation(c config, op Op, opts ...eventlogOption) *EventLogMutation {
	m := &EventLogMutation{
		config:        c,
		op:            op,
		typ:           TypeEventLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventLogID sets the ID field of the mutation.
func withEventLogID(id int) eventlogOption {
	return func(m *EventLogMutation) {
		var (
			err   error
			once  sync.Once
			value *EventLog
		)
		m.oldValue = func(ctx context.Context) (*EventLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventLog sets the old EventLog of the mutation.
func withEventLog(node *EventLog) eventlogOption {
	return func(m *EventLogMutation) {
		m.oldValue = func(context.Context) (*EventLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EventLogMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EventLogMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EventLogMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *EventLogMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *EventLogMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *EventLogMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *EventLogMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *EventLogMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *EventLogMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[eventlog.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *EventLogMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[eventlog.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *EventLogMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, eventlog.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *EventLogMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *EventLogMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *EventLogMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EventLogMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EventLogMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EventLogMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeviceID sets the "device_id" field.
func (m *EventLogMutation) SetDeviceID(i int) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *EventLogMutation) DeviceID() (r int, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldDeviceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *EventLogMutation) ResetDeviceID() {
	m.device = nil
}

// SetEventID sets the "event_id" field.
func (m *EventLogMutation) SetEventID(i int) {
	m.event = &i
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *EventLogMutation) EventID() (r int, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldEventID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *EventLogMutation) ResetEventID() {
	m.event = nil
}

// SetActorID sets the "actor_id" field.
func (m *EventLogMutation) SetActorID(i int) {
	m.actor = &i
}

// ActorID returns the value of the "actor_id" field in the mutation.
func (m *EventLogMutation) ActorID() (r int, exists bool) {
	v := m.actor
	if v == nil {
		return
	}
	return *v, true
}

// OldActorID returns the old "actor_id" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldActorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActorID: %w", err)
	}
	return oldValue.ActorID, nil
}

// ClearActorID clears the value of the "actor_id" field.
func (m *EventLogMutation) ClearActorID() {
	m.actor = nil
	m.clearedFields[eventlog.FieldActorID] = struct{}{}
}

// ActorIDCleared returns if the "actor_id" field was cleared in this mutation.
func (m *EventLogMutation) ActorIDCleared() bool {
	_, ok := m.clearedFields[eventlog.FieldActorID]
	return ok
}

// ResetActorID resets all changes to the "actor_id" field.
func (m *EventLogMutation) ResetActorID() {
	m.actor = nil
	delete(m.clearedFields, eventlog.FieldActorID)
}

// SetActor2ID sets the "actor2_id" field.
func (m *EventLogMutation) SetActor2ID(i int) {
	m.actor2 = &i
}

// Actor2ID returns the value of the "actor2_id" field in the mutation.
func (m *EventLogMutation) Actor2ID() (r int, exists bool) {
	v := m.actor2
	if v == nil {
		return
	}
	return *v, true
}

// OldActor2ID returns the old "actor2_id" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldActor2ID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActor2ID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActor2ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActor2ID: %w", err)
	}
	return oldValue.Actor2ID, nil
}

// ClearActor2ID clears the value of the "actor2_id" field.
func (m *EventLogMutation) ClearActor2ID() {
	m.actor2 = nil
	m.clearedFields[eventlog.FieldActor2ID] = struct{}{}
}

// Actor2IDCleared returns if the "actor2_id" field was cleared in this mutation.
func (m *EventLogMutation) Actor2IDCleared() bool {
	_, ok := m.clearedFields[eventlog.FieldActor2ID]
	return ok
}

// ResetActor2ID resets all changes to the "actor2_id" field.
func (m *EventLogMutation) ResetActor2ID() {
	m.actor2 = nil
	delete(m.clearedFields, eventlog.FieldActor2ID)
}

// SetLogType sets the "log_type" field.
func (m *EventLogMutation) SetLogType(elt enums.EventLogType) {
	m.log_type = &elt
	m.addlog_type = nil
}

// LogType returns the value of the "log_type" field in the mutation.
func (m *EventLogMutation) LogType() (r enums.EventLogType, exists bool) {
	v := m.log_type
	if v == nil {
		return
	}
	return *v, true
}

// OldLogType returns the old "log_type" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldLogType(ctx context.Context) (v enums.EventLogType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogType: %w", err)
	}
	return oldValue.LogType, nil
}

// AddLogType adds elt to the "log_type" field.
func (m *EventLogMutation) AddLogType(elt enums.EventLogType) {
	if m.addlog_type != nil {
		*m.addlog_type += elt
	} else {
		m.addlog_type = &elt
	}
}

// AddedLogType returns the value that was added to the "log_type" field in this mutation.
func (m *EventLogMutation) AddedLogType() (r enums.EventLogType, exists bool) {
	v := m.addlog_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetLogType resets all changes to the "log_type" field.
func (m *EventLogMutation) ResetLogType() {
	m.log_type = nil
	m.addlog_type = nil
}

// SetNotes sets the "notes" field.
func (m *EventLogMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *EventLogMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the EventLog entity.
// If the EventLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLogMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *EventLogMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[eventlog.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *EventLogMutation) NotesCleared() bool {
	_, ok := m.clearedFields[eventlog.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *EventLogMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, eventlog.FieldNotes)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EventLogMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[eventlog.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EventLogMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EventLogMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EventLogMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *EventLogMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[eventlog.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *EventLogMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *EventLogMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *EventLogMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *EventLogMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[eventlog.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *EventLogMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *EventLogMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *EventLogMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *EventLogMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[eventlog.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *EventLogMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *EventLogMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *EventLogMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// ClearActor clears the "actor" edge to the Admin entity.
func (m *EventLogMutation) ClearActor() {
	m.clearedactor = true
	m.clearedFields[eventlog.FieldActorID] = struct{}{}
}

// ActorCleared reports if the "actor" edge to the Admin entity was cleared.
func (m *EventLogMutation) ActorCleared() bool {
	return m.ActorIDCleared() || m.clearedactor
}

// ActorIDs returns the "actor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActorID instead. It exists only for internal usage by the builders.
func (m *EventLogMutation) ActorIDs() (ids []int) {
	if id := m.actor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActor resets all changes to the "actor" edge.
func (m *EventLogMutation) ResetActor() {
	m.actor = nil
	m.clearedactor = false
}

// ClearActor2 clears the "actor2" edge to the Admin entity.
func (m *EventLogMutation) ClearActor2() {
	m.clearedactor2 = true
	m.clearedFields[eventlog.FieldActor2ID] = struct{}{}
}

// Actor2Cleared reports if the "actor2" edge to the Admin entity was cleared.
func (m *EventLogMutation) Actor2Cleared() bool {
	return m.Actor2IDCleared() || m.clearedactor2
}

// Actor2IDs returns the "actor2" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// Actor2ID instead. It exists only for internal usage by the builders.
func (m *EventLogMutation) Actor2IDs() (ids []int) {
	if id := m.actor2; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActor2 resets all changes to the "actor2" edge.
func (m *EventLogMutation) ResetActor2() {
	m.actor2 = nil
	m.clearedactor2 = false
}

// Where appends a list predicates to the EventLogMutation builder.
func (m *EventLogMutation) Where(ps ...predicate.EventLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventLog).
func (m *EventLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, eventlog.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, eventlog.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, eventlog.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, eventlog.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, eventlog.FieldUpdateTime)
	}
	if m.device != nil {
		fields = append(fields, eventlog.FieldDeviceID)
	}
	if m.event != nil {
		fields = append(fields, eventlog.FieldEventID)
	}
	if m.actor != nil {
		fields = append(fields, eventlog.FieldActorID)
	}
	if m.actor2 != nil {
		fields = append(fields, eventlog.FieldActor2ID)
	}
	if m.log_type != nil {
		fields = append(fields, eventlog.FieldLogType)
	}
	if m.notes != nil {
		fields = append(fields, eventlog.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventlog.FieldCreateTime:
		return m.CreateTime()
	case eventlog.FieldCreatorID:
		return m.CreatorID()
	case eventlog.FieldDeleteTime:
		return m.DeleteTime()
	case eventlog.FieldUpdaterID:
		return m.UpdaterID()
	case eventlog.FieldUpdateTime:
		return m.UpdateTime()
	case eventlog.FieldDeviceID:
		return m.DeviceID()
	case eventlog.FieldEventID:
		return m.EventID()
	case eventlog.FieldActorID:
		return m.ActorID()
	case eventlog.FieldActor2ID:
		return m.Actor2ID()
	case eventlog.FieldLogType:
		return m.LogType()
	case eventlog.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventlog.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case eventlog.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case eventlog.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case eventlog.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case eventlog.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case eventlog.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case eventlog.FieldEventID:
		return m.OldEventID(ctx)
	case eventlog.FieldActorID:
		return m.OldActorID(ctx)
	case eventlog.FieldActor2ID:
		return m.OldActor2ID(ctx)
	case eventlog.FieldLogType:
		return m.OldLogType(ctx)
	case eventlog.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown EventLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventlog.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case eventlog.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case eventlog.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case eventlog.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case eventlog.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case eventlog.FieldDeviceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case eventlog.FieldEventID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case eventlog.FieldActorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActorID(v)
		return nil
	case eventlog.FieldActor2ID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActor2ID(v)
		return nil
	case eventlog.FieldLogType:
		v, ok := value.(enums.EventLogType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogType(v)
		return nil
	case eventlog.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown EventLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventLogMutation) AddedFields() []string {
	var fields []string
	if m.addlog_type != nil {
		fields = append(fields, eventlog.FieldLogType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case eventlog.FieldLogType:
		return m.AddedLogType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case eventlog.FieldLogType:
		v, ok := value.(enums.EventLogType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLogType(v)
		return nil
	}
	return fmt.Errorf("unknown EventLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventlog.FieldDeleteTime) {
		fields = append(fields, eventlog.FieldDeleteTime)
	}
	if m.FieldCleared(eventlog.FieldActorID) {
		fields = append(fields, eventlog.FieldActorID)
	}
	if m.FieldCleared(eventlog.FieldActor2ID) {
		fields = append(fields, eventlog.FieldActor2ID)
	}
	if m.FieldCleared(eventlog.FieldNotes) {
		fields = append(fields, eventlog.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventLogMutation) ClearField(name string) error {
	switch name {
	case eventlog.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case eventlog.FieldActorID:
		m.ClearActorID()
		return nil
	case eventlog.FieldActor2ID:
		m.ClearActor2ID()
		return nil
	case eventlog.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown EventLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventLogMutation) ResetField(name string) error {
	switch name {
	case eventlog.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case eventlog.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case eventlog.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case eventlog.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case eventlog.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case eventlog.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case eventlog.FieldEventID:
		m.ResetEventID()
		return nil
	case eventlog.FieldActorID:
		m.ResetActorID()
		return nil
	case eventlog.FieldActor2ID:
		m.ResetActor2ID()
		return nil
	case eventlog.FieldLogType:
		m.ResetLogType()
		return nil
	case eventlog.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown EventLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.creator != nil {
		edges = append(edges, eventlog.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, eventlog.EdgeUpdater)
	}
	if m.event != nil {
		edges = append(edges, eventlog.EdgeEvent)
	}
	if m.device != nil {
		edges = append(edges, eventlog.EdgeDevice)
	}
	if m.actor != nil {
		edges = append(edges, eventlog.EdgeActor)
	}
	if m.actor2 != nil {
		edges = append(edges, eventlog.EdgeActor2)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventlog.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case eventlog.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case eventlog.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case eventlog.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case eventlog.EdgeActor:
		if id := m.actor; id != nil {
			return []ent.Value{*id}
		}
	case eventlog.EdgeActor2:
		if id := m.actor2; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcreator {
		edges = append(edges, eventlog.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, eventlog.EdgeUpdater)
	}
	if m.clearedevent {
		edges = append(edges, eventlog.EdgeEvent)
	}
	if m.cleareddevice {
		edges = append(edges, eventlog.EdgeDevice)
	}
	if m.clearedactor {
		edges = append(edges, eventlog.EdgeActor)
	}
	if m.clearedactor2 {
		edges = append(edges, eventlog.EdgeActor2)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventLogMutation) EdgeCleared(name string) bool {
	switch name {
	case eventlog.EdgeCreator:
		return m.clearedcreator
	case eventlog.EdgeUpdater:
		return m.clearedupdater
	case eventlog.EdgeEvent:
		return m.clearedevent
	case eventlog.EdgeDevice:
		return m.cleareddevice
	case eventlog.EdgeActor:
		return m.clearedactor
	case eventlog.EdgeActor2:
		return m.clearedactor2
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventLogMutation) ClearEdge(name string) error {
	switch name {
	case eventlog.EdgeCreator:
		m.ClearCreator()
		return nil
	case eventlog.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case eventlog.EdgeEvent:
		m.ClearEvent()
		return nil
	case eventlog.EdgeDevice:
		m.ClearDevice()
		return nil
	case eventlog.EdgeActor:
		m.ClearActor()
		return nil
	case eventlog.EdgeActor2:
		m.ClearActor2()
		return nil
	}
	return fmt.Errorf("unknown EventLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventLogMutation) ResetEdge(name string) error {
	switch name {
	case eventlog.EdgeCreator:
		m.ResetCreator()
		return nil
	case eventlog.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case eventlog.EdgeEvent:
		m.ResetEvent()
		return nil
	case eventlog.EdgeDevice:
		m.ResetDevice()
		return nil
	case eventlog.EdgeActor:
		m.ResetActor()
		return nil
	case eventlog.EdgeActor2:
		m.ResetActor2()
		return nil
	}
	return fmt.Errorf("unknown EventLog edge %s", name)
}

// FixingMutation represents an operation that mutates the Fixing nodes in the graph.
type FixingMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	delete_time    *time.Time
	update_time    *time.Time
	assign_notes   *string
	fix_time       *time.Time
	complete_time  *time.Time
	complete_notes *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	fixer          *int
	clearedfixer   bool
	event          *int
	clearedevent   bool
	device         *int
	cleareddevice  bool
	done           bool
	oldValue       func(context.Context) (*Fixing, error)
	predicates     []predicate.Fixing
}

var _ ent.Mutation = (*FixingMutation)(nil)

// fixingOption allows management of the mutation configuration using functional options.
type fixingOption func(*FixingMutation)

// newFixingMutation creates new mutation for the Fixing entity.
func newFixingMutation(c config, op Op, opts ...fixingOption) *FixingMutation {
	m := &FixingMutation{
		config:        c,
		op:            op,
		typ:           TypeFixing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFixingID sets the ID field of the mutation.
func withFixingID(id int) fixingOption {
	return func(m *FixingMutation) {
		var (
			err   error
			once  sync.Once
			value *Fixing
		)
		m.oldValue = func(ctx context.Context) (*Fixing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fixing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFixing sets the old Fixing of the mutation.
func withFixing(node *Fixing) fixingOption {
	return func(m *FixingMutation) {
		m.oldValue = func(context.Context) (*Fixing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FixingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FixingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FixingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FixingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fixing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FixingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FixingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FixingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *FixingMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *FixingMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *FixingMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *FixingMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *FixingMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *FixingMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[fixing.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *FixingMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[fixing.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *FixingMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, fixing.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *FixingMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *FixingMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *FixingMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FixingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FixingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FixingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFixerID sets the "fixer_id" field.
func (m *FixingMutation) SetFixerID(i int) {
	m.fixer = &i
}

// FixerID returns the value of the "fixer_id" field in the mutation.
func (m *FixingMutation) FixerID() (r int, exists bool) {
	v := m.fixer
	if v == nil {
		return
	}
	return *v, true
}

// OldFixerID returns the old "fixer_id" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldFixerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixerID: %w", err)
	}
	return oldValue.FixerID, nil
}

// ResetFixerID resets all changes to the "fixer_id" field.
func (m *FixingMutation) ResetFixerID() {
	m.fixer = nil
}

// SetEventID sets the "event_id" field.
func (m *FixingMutation) SetEventID(i int) {
	m.event = &i
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *FixingMutation) EventID() (r int, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldEventID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *FixingMutation) ResetEventID() {
	m.event = nil
}

// SetDeviceID sets the "device_id" field.
func (m *FixingMutation) SetDeviceID(i int) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *FixingMutation) DeviceID() (r int, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldDeviceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *FixingMutation) ResetDeviceID() {
	m.device = nil
}

// SetAssignNotes sets the "assign_notes" field.
func (m *FixingMutation) SetAssignNotes(s string) {
	m.assign_notes = &s
}

// AssignNotes returns the value of the "assign_notes" field in the mutation.
func (m *FixingMutation) AssignNotes() (r string, exists bool) {
	v := m.assign_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignNotes returns the old "assign_notes" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldAssignNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignNotes: %w", err)
	}
	return oldValue.AssignNotes, nil
}

// ClearAssignNotes clears the value of the "assign_notes" field.
func (m *FixingMutation) ClearAssignNotes() {
	m.assign_notes = nil
	m.clearedFields[fixing.FieldAssignNotes] = struct{}{}
}

// AssignNotesCleared returns if the "assign_notes" field was cleared in this mutation.
func (m *FixingMutation) AssignNotesCleared() bool {
	_, ok := m.clearedFields[fixing.FieldAssignNotes]
	return ok
}

// ResetAssignNotes resets all changes to the "assign_notes" field.
func (m *FixingMutation) ResetAssignNotes() {
	m.assign_notes = nil
	delete(m.clearedFields, fixing.FieldAssignNotes)
}

// SetFixTime sets the "fix_time" field.
func (m *FixingMutation) SetFixTime(t time.Time) {
	m.fix_time = &t
}

// FixTime returns the value of the "fix_time" field in the mutation.
func (m *FixingMutation) FixTime() (r time.Time, exists bool) {
	v := m.fix_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFixTime returns the old "fix_time" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldFixTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixTime: %w", err)
	}
	return oldValue.FixTime, nil
}

// ClearFixTime clears the value of the "fix_time" field.
func (m *FixingMutation) ClearFixTime() {
	m.fix_time = nil
	m.clearedFields[fixing.FieldFixTime] = struct{}{}
}

// FixTimeCleared returns if the "fix_time" field was cleared in this mutation.
func (m *FixingMutation) FixTimeCleared() bool {
	_, ok := m.clearedFields[fixing.FieldFixTime]
	return ok
}

// ResetFixTime resets all changes to the "fix_time" field.
func (m *FixingMutation) ResetFixTime() {
	m.fix_time = nil
	delete(m.clearedFields, fixing.FieldFixTime)
}

// SetCompleteTime sets the "complete_time" field.
func (m *FixingMutation) SetCompleteTime(t time.Time) {
	m.complete_time = &t
}

// CompleteTime returns the value of the "complete_time" field in the mutation.
func (m *FixingMutation) CompleteTime() (r time.Time, exists bool) {
	v := m.complete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleteTime returns the old "complete_time" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldCompleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleteTime: %w", err)
	}
	return oldValue.CompleteTime, nil
}

// ClearCompleteTime clears the value of the "complete_time" field.
func (m *FixingMutation) ClearCompleteTime() {
	m.complete_time = nil
	m.clearedFields[fixing.FieldCompleteTime] = struct{}{}
}

// CompleteTimeCleared returns if the "complete_time" field was cleared in this mutation.
func (m *FixingMutation) CompleteTimeCleared() bool {
	_, ok := m.clearedFields[fixing.FieldCompleteTime]
	return ok
}

// ResetCompleteTime resets all changes to the "complete_time" field.
func (m *FixingMutation) ResetCompleteTime() {
	m.complete_time = nil
	delete(m.clearedFields, fixing.FieldCompleteTime)
}

// SetCompleteNotes sets the "complete_notes" field.
func (m *FixingMutation) SetCompleteNotes(s string) {
	m.complete_notes = &s
}

// CompleteNotes returns the value of the "complete_notes" field in the mutation.
func (m *FixingMutation) CompleteNotes() (r string, exists bool) {
	v := m.complete_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldCompleteNotes returns the old "complete_notes" field's value of the Fixing entity.
// If the Fixing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixingMutation) OldCompleteNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompleteNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompleteNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompleteNotes: %w", err)
	}
	return oldValue.CompleteNotes, nil
}

// ClearCompleteNotes clears the value of the "complete_notes" field.
func (m *FixingMutation) ClearCompleteNotes() {
	m.complete_notes = nil
	m.clearedFields[fixing.FieldCompleteNotes] = struct{}{}
}

// CompleteNotesCleared returns if the "complete_notes" field was cleared in this mutation.
func (m *FixingMutation) CompleteNotesCleared() bool {
	_, ok := m.clearedFields[fixing.FieldCompleteNotes]
	return ok
}

// ResetCompleteNotes resets all changes to the "complete_notes" field.
func (m *FixingMutation) ResetCompleteNotes() {
	m.complete_notes = nil
	delete(m.clearedFields, fixing.FieldCompleteNotes)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *FixingMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[fixing.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *FixingMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *FixingMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *FixingMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *FixingMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[fixing.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *FixingMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *FixingMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *FixingMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearFixer clears the "fixer" edge to the Admin entity.
func (m *FixingMutation) ClearFixer() {
	m.clearedfixer = true
	m.clearedFields[fixing.FieldFixerID] = struct{}{}
}

// FixerCleared reports if the "fixer" edge to the Admin entity was cleared.
func (m *FixingMutation) FixerCleared() bool {
	return m.clearedfixer
}

// FixerIDs returns the "fixer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FixerID instead. It exists only for internal usage by the builders.
func (m *FixingMutation) FixerIDs() (ids []int) {
	if id := m.fixer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFixer resets all changes to the "fixer" edge.
func (m *FixingMutation) ResetFixer() {
	m.fixer = nil
	m.clearedfixer = false
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *FixingMutation) ClearEvent() {
	m.clearedevent = true
	m.clearedFields[fixing.FieldEventID] = struct{}{}
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *FixingMutation) EventCleared() bool {
	return m.clearedevent
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *FixingMutation) EventIDs() (ids []int) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *FixingMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *FixingMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[fixing.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *FixingMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *FixingMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *FixingMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the FixingMutation builder.
func (m *FixingMutation) Where(ps ...predicate.Fixing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FixingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FixingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fixing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FixingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FixingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fixing).
func (m *FixingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FixingMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, fixing.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, fixing.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, fixing.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, fixing.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, fixing.FieldUpdateTime)
	}
	if m.fixer != nil {
		fields = append(fields, fixing.FieldFixerID)
	}
	if m.event != nil {
		fields = append(fields, fixing.FieldEventID)
	}
	if m.device != nil {
		fields = append(fields, fixing.FieldDeviceID)
	}
	if m.assign_notes != nil {
		fields = append(fields, fixing.FieldAssignNotes)
	}
	if m.fix_time != nil {
		fields = append(fields, fixing.FieldFixTime)
	}
	if m.complete_time != nil {
		fields = append(fields, fixing.FieldCompleteTime)
	}
	if m.complete_notes != nil {
		fields = append(fields, fixing.FieldCompleteNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FixingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fixing.FieldCreateTime:
		return m.CreateTime()
	case fixing.FieldCreatorID:
		return m.CreatorID()
	case fixing.FieldDeleteTime:
		return m.DeleteTime()
	case fixing.FieldUpdaterID:
		return m.UpdaterID()
	case fixing.FieldUpdateTime:
		return m.UpdateTime()
	case fixing.FieldFixerID:
		return m.FixerID()
	case fixing.FieldEventID:
		return m.EventID()
	case fixing.FieldDeviceID:
		return m.DeviceID()
	case fixing.FieldAssignNotes:
		return m.AssignNotes()
	case fixing.FieldFixTime:
		return m.FixTime()
	case fixing.FieldCompleteTime:
		return m.CompleteTime()
	case fixing.FieldCompleteNotes:
		return m.CompleteNotes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FixingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fixing.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case fixing.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case fixing.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case fixing.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case fixing.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case fixing.FieldFixerID:
		return m.OldFixerID(ctx)
	case fixing.FieldEventID:
		return m.OldEventID(ctx)
	case fixing.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case fixing.FieldAssignNotes:
		return m.OldAssignNotes(ctx)
	case fixing.FieldFixTime:
		return m.OldFixTime(ctx)
	case fixing.FieldCompleteTime:
		return m.OldCompleteTime(ctx)
	case fixing.FieldCompleteNotes:
		return m.OldCompleteNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Fixing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fixing.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case fixing.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case fixing.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case fixing.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case fixing.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case fixing.FieldFixerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixerID(v)
		return nil
	case fixing.FieldEventID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case fixing.FieldDeviceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case fixing.FieldAssignNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignNotes(v)
		return nil
	case fixing.FieldFixTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixTime(v)
		return nil
	case fixing.FieldCompleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleteTime(v)
		return nil
	case fixing.FieldCompleteNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompleteNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Fixing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FixingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FixingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Fixing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FixingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fixing.FieldDeleteTime) {
		fields = append(fields, fixing.FieldDeleteTime)
	}
	if m.FieldCleared(fixing.FieldAssignNotes) {
		fields = append(fields, fixing.FieldAssignNotes)
	}
	if m.FieldCleared(fixing.FieldFixTime) {
		fields = append(fields, fixing.FieldFixTime)
	}
	if m.FieldCleared(fixing.FieldCompleteTime) {
		fields = append(fields, fixing.FieldCompleteTime)
	}
	if m.FieldCleared(fixing.FieldCompleteNotes) {
		fields = append(fields, fixing.FieldCompleteNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FixingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FixingMutation) ClearField(name string) error {
	switch name {
	case fixing.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case fixing.FieldAssignNotes:
		m.ClearAssignNotes()
		return nil
	case fixing.FieldFixTime:
		m.ClearFixTime()
		return nil
	case fixing.FieldCompleteTime:
		m.ClearCompleteTime()
		return nil
	case fixing.FieldCompleteNotes:
		m.ClearCompleteNotes()
		return nil
	}
	return fmt.Errorf("unknown Fixing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FixingMutation) ResetField(name string) error {
	switch name {
	case fixing.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case fixing.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case fixing.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case fixing.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case fixing.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case fixing.FieldFixerID:
		m.ResetFixerID()
		return nil
	case fixing.FieldEventID:
		m.ResetEventID()
		return nil
	case fixing.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case fixing.FieldAssignNotes:
		m.ResetAssignNotes()
		return nil
	case fixing.FieldFixTime:
		m.ResetFixTime()
		return nil
	case fixing.FieldCompleteTime:
		m.ResetCompleteTime()
		return nil
	case fixing.FieldCompleteNotes:
		m.ResetCompleteNotes()
		return nil
	}
	return fmt.Errorf("unknown Fixing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FixingMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, fixing.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, fixing.EdgeUpdater)
	}
	if m.fixer != nil {
		edges = append(edges, fixing.EdgeFixer)
	}
	if m.event != nil {
		edges = append(edges, fixing.EdgeEvent)
	}
	if m.device != nil {
		edges = append(edges, fixing.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FixingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fixing.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case fixing.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case fixing.EdgeFixer:
		if id := m.fixer; id != nil {
			return []ent.Value{*id}
		}
	case fixing.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case fixing.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FixingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FixingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FixingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, fixing.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, fixing.EdgeUpdater)
	}
	if m.clearedfixer {
		edges = append(edges, fixing.EdgeFixer)
	}
	if m.clearedevent {
		edges = append(edges, fixing.EdgeEvent)
	}
	if m.cleareddevice {
		edges = append(edges, fixing.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FixingMutation) EdgeCleared(name string) bool {
	switch name {
	case fixing.EdgeCreator:
		return m.clearedcreator
	case fixing.EdgeUpdater:
		return m.clearedupdater
	case fixing.EdgeFixer:
		return m.clearedfixer
	case fixing.EdgeEvent:
		return m.clearedevent
	case fixing.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FixingMutation) ClearEdge(name string) error {
	switch name {
	case fixing.EdgeCreator:
		m.ClearCreator()
		return nil
	case fixing.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case fixing.EdgeFixer:
		m.ClearFixer()
		return nil
	case fixing.EdgeEvent:
		m.ClearEvent()
		return nil
	case fixing.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown Fixing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FixingMutation) ResetEdge(name string) error {
	switch name {
	case fixing.EdgeCreator:
		m.ResetCreator()
		return nil
	case fixing.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case fixing.EdgeFixer:
		m.ResetFixer()
		return nil
	case fixing.EdgeEvent:
		m.ResetEvent()
		return nil
	case fixing.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown Fixing edge %s", name)
}

// OccupationMutation represents an operation that mutates the Occupation nodes in the graph.
type OccupationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	delete_time     *time.Time
	update_time     *time.Time
	name            *string
	description     *string
	clearedFields   map[string]struct{}
	creator         *int
	clearedcreator  bool
	updater         *int
	clearedupdater  bool
	employee        map[int]struct{}
	removedemployee map[int]struct{}
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Occupation, error)
	predicates      []predicate.Occupation
}

var _ ent.Mutation = (*OccupationMutation)(nil)

// occupationOption allows management of the mutation configuration using functional options.
type occupationOption func(*OccupationMutation)

// newOccupationMutation creates new mutation for the Occupation entity.
func newOccupationMutation(c config, op Op, opts ...occupationOption) *OccupationMutation {
	m := &OccupationMutation{
		config:        c,
		op:            op,
		typ:           TypeOccupation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccupationID sets the ID field of the mutation.
func withOccupationID(id int) occupationOption {
	return func(m *OccupationMutation) {
		var (
			err   error
			once  sync.Once
			value *Occupation
		)
		m.oldValue = func(ctx context.Context) (*Occupation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occupation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccupation sets the old Occupation of the mutation.
func withOccupation(node *Occupation) occupationOption {
	return func(m *OccupationMutation) {
		m.oldValue = func(context.Context) (*Occupation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccupationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccupationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccupationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccupationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occupation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *OccupationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OccupationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OccupationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *OccupationMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *OccupationMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *OccupationMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *OccupationMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *OccupationMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *OccupationMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[occupation.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *OccupationMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[occupation.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *OccupationMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, occupation.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *OccupationMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *OccupationMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *OccupationMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OccupationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OccupationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OccupationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *OccupationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OccupationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OccupationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OccupationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OccupationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OccupationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[occupation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OccupationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[occupation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OccupationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, occupation.FieldDescription)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *OccupationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[occupation.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *OccupationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *OccupationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *OccupationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *OccupationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[occupation.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *OccupationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *OccupationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *OccupationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddEmployeeIDs adds the "employee" edge to the Employee entity by ids.
func (m *OccupationMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *OccupationMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *OccupationMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// RemoveEmployeeIDs removes the "employee" edge to the Employee entity by IDs.
func (m *OccupationMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee, ids[i])
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed IDs of the "employee" edge to the Employee entity.
func (m *OccupationMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
func (m *OccupationMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *OccupationMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
	m.removedemployee = nil
}

// Where appends a list predicates to the OccupationMutation builder.
func (m *OccupationMutation) Where(ps ...predicate.Occupation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccupationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccupationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occupation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccupationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccupationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occupation).
func (m *OccupationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccupationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, occupation.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, occupation.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, occupation.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, occupation.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, occupation.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, occupation.FieldName)
	}
	if m.description != nil {
		fields = append(fields, occupation.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccupationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occupation.FieldCreateTime:
		return m.CreateTime()
	case occupation.FieldCreatorID:
		return m.CreatorID()
	case occupation.FieldDeleteTime:
		return m.DeleteTime()
	case occupation.FieldUpdaterID:
		return m.UpdaterID()
	case occupation.FieldUpdateTime:
		return m.UpdateTime()
	case occupation.FieldName:
		return m.Name()
	case occupation.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccupationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occupation.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case occupation.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case occupation.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case occupation.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case occupation.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case occupation.FieldName:
		return m.OldName(ctx)
	case occupation.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Occupation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occupation.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case occupation.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case occupation.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case occupation.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case occupation.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case occupation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case occupation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Occupation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccupationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccupationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Occupation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccupationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occupation.FieldDeleteTime) {
		fields = append(fields, occupation.FieldDeleteTime)
	}
	if m.FieldCleared(occupation.FieldDescription) {
		fields = append(fields, occupation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccupationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccupationMutation) ClearField(name string) error {
	switch name {
	case occupation.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case occupation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Occupation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccupationMutation) ResetField(name string) error {
	switch name {
	case occupation.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case occupation.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case occupation.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case occupation.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case occupation.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case occupation.FieldName:
		m.ResetName()
		return nil
	case occupation.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Occupation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccupationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, occupation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, occupation.EdgeUpdater)
	}
	if m.employee != nil {
		edges = append(edges, occupation.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccupationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occupation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case occupation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case occupation.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccupationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedemployee != nil {
		edges = append(edges, occupation.EdgeEmployee)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccupationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case occupation.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccupationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, occupation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, occupation.EdgeUpdater)
	}
	if m.clearedemployee {
		edges = append(edges, occupation.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccupationMutation) EdgeCleared(name string) bool {
	switch name {
	case occupation.EdgeCreator:
		return m.clearedcreator
	case occupation.EdgeUpdater:
		return m.clearedupdater
	case occupation.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccupationMutation) ClearEdge(name string) error {
	switch name {
	case occupation.EdgeCreator:
		m.ClearCreator()
		return nil
	case occupation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Occupation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccupationMutation) ResetEdge(name string) error {
	switch name {
	case occupation.EdgeCreator:
		m.ResetCreator()
		return nil
	case occupation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case occupation.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Occupation edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	delete_time       *time.Time
	update_time       *time.Time
	name              *string
	access_ids        *[]string
	appendaccess_ids  []string
	clearedFields     map[string]struct{}
	creator           *int
	clearedcreator    bool
	updater           *int
	clearedupdater    bool
	admin             map[int]struct{}
	removedadmin      map[int]struct{}
	clearedadmin      bool
	department        map[int]struct{}
	removeddepartment map[int]struct{}
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*Permission, error)
	predicates        []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id int) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PermissionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PermissionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PermissionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *PermissionMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *PermissionMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *PermissionMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *PermissionMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *PermissionMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *PermissionMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[permission.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *PermissionMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[permission.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *PermissionMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, permission.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *PermissionMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *PermissionMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *PermissionMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PermissionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PermissionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PermissionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *PermissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PermissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PermissionMutation) ResetName() {
	m.name = nil
}

// SetAccessIds sets the "access_ids" field.
func (m *PermissionMutation) SetAccessIds(s []string) {
	m.access_ids = &s
	m.appendaccess_ids = nil
}

// AccessIds returns the value of the "access_ids" field in the mutation.
func (m *PermissionMutation) AccessIds() (r []string, exists bool) {
	v := m.access_ids
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessIds returns the old "access_ids" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldAccessIds(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessIds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessIds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessIds: %w", err)
	}
	return oldValue.AccessIds, nil
}

// AppendAccessIds adds s to the "access_ids" field.
func (m *PermissionMutation) AppendAccessIds(s []string) {
	m.appendaccess_ids = append(m.appendaccess_ids, s...)
}

// AppendedAccessIds returns the list of values that were appended to the "access_ids" field in this mutation.
func (m *PermissionMutation) AppendedAccessIds() ([]string, bool) {
	if len(m.appendaccess_ids) == 0 {
		return nil, false
	}
	return m.appendaccess_ids, true
}

// ResetAccessIds resets all changes to the "access_ids" field.
func (m *PermissionMutation) ResetAccessIds() {
	m.access_ids = nil
	m.appendaccess_ids = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *PermissionMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[permission.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *PermissionMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *PermissionMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *PermissionMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[permission.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *PermissionMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *PermissionMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddAdminIDs adds the "admin" edge to the Admin entity by ids.
func (m *PermissionMutation) AddAdminIDs(ids ...int) {
	if m.admin == nil {
		m.admin = make(map[int]struct{})
	}
	for i := range ids {
		m.admin[ids[i]] = struct{}{}
	}
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *PermissionMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *PermissionMutation) AdminCleared() bool {
	return m.clearedadmin
}

// RemoveAdminIDs removes the "admin" edge to the Admin entity by IDs.
func (m *PermissionMutation) RemoveAdminIDs(ids ...int) {
	if m.removedadmin == nil {
		m.removedadmin = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin, ids[i])
		m.removedadmin[ids[i]] = struct{}{}
	}
}

// RemovedAdmin returns the removed IDs of the "admin" edge to the Admin entity.
func (m *PermissionMutation) RemovedAdminIDs() (ids []int) {
	for id := range m.removedadmin {
		ids = append(ids, id)
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
func (m *PermissionMutation) AdminIDs() (ids []int) {
	for id := range m.admin {
		ids = append(ids, id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *PermissionMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
	m.removedadmin = nil
}

// AddDepartmentIDs adds the "department" edge to the Department entity by ids.
func (m *PermissionMutation) AddDepartmentIDs(ids ...int) {
	if m.department == nil {
		m.department = make(map[int]struct{})
	}
	for i := range ids {
		m.department[ids[i]] = struct{}{}
	}
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *PermissionMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *PermissionMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// RemoveDepartmentIDs removes the "department" edge to the Department entity by IDs.
func (m *PermissionMutation) RemoveDepartmentIDs(ids ...int) {
	if m.removeddepartment == nil {
		m.removeddepartment = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department, ids[i])
		m.removeddepartment[ids[i]] = struct{}{}
	}
}

// RemovedDepartment returns the removed IDs of the "department" edge to the Department entity.
func (m *PermissionMutation) RemovedDepartmentIDs() (ids []int) {
	for id := range m.removeddepartment {
		ids = append(ids, id)
	}
	return
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
func (m *PermissionMutation) DepartmentIDs() (ids []int) {
	for id := range m.department {
		ids = append(ids, id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *PermissionMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
	m.removeddepartment = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, permission.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, permission.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, permission.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, permission.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, permission.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, permission.FieldName)
	}
	if m.access_ids != nil {
		fields = append(fields, permission.FieldAccessIds)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldCreateTime:
		return m.CreateTime()
	case permission.FieldCreatorID:
		return m.CreatorID()
	case permission.FieldDeleteTime:
		return m.DeleteTime()
	case permission.FieldUpdaterID:
		return m.UpdaterID()
	case permission.FieldUpdateTime:
		return m.UpdateTime()
	case permission.FieldName:
		return m.Name()
	case permission.FieldAccessIds:
		return m.AccessIds()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case permission.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case permission.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case permission.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case permission.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case permission.FieldName:
		return m.OldName(ctx)
	case permission.FieldAccessIds:
		return m.OldAccessIds(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case permission.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case permission.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case permission.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case permission.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case permission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case permission.FieldAccessIds:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessIds(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldDeleteTime) {
		fields = append(fields, permission.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case permission.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case permission.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case permission.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case permission.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case permission.FieldName:
		m.ResetName()
		return nil
	case permission.FieldAccessIds:
		m.ResetAccessIds()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, permission.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, permission.EdgeUpdater)
	}
	if m.admin != nil {
		edges = append(edges, permission.EdgeAdmin)
	}
	if m.department != nil {
		edges = append(edges, permission.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeAdmin:
		ids := make([]ent.Value, 0, len(m.admin))
		for id := range m.admin {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDepartment:
		ids := make([]ent.Value, 0, len(m.department))
		for id := range m.department {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedadmin != nil {
		edges = append(edges, permission.EdgeAdmin)
	}
	if m.removeddepartment != nil {
		edges = append(edges, permission.EdgeDepartment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeAdmin:
		ids := make([]ent.Value, 0, len(m.removedadmin))
		for id := range m.removedadmin {
			ids = append(ids, id)
		}
		return ids
	case permission.EdgeDepartment:
		ids := make([]ent.Value, 0, len(m.removeddepartment))
		for id := range m.removeddepartment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, permission.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, permission.EdgeUpdater)
	}
	if m.clearedadmin {
		edges = append(edges, permission.EdgeAdmin)
	}
	if m.cleareddepartment {
		edges = append(edges, permission.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeCreator:
		return m.clearedcreator
	case permission.EdgeUpdater:
		return m.clearedupdater
	case permission.EdgeAdmin:
		return m.clearedadmin
	case permission.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeCreator:
		m.ClearCreator()
		return nil
	case permission.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeCreator:
		m.ResetCreator()
		return nil
	case permission.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case permission.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case permission.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// RiskMutation represents an operation that mutates the Risk nodes in the graph.
type RiskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	delete_time          *time.Time
	update_time          *time.Time
	title                *string
	content              *string
	images               *[]types.UploadedImage
	appendimages         []types.UploadedImage
	measures             *string
	maintain_status      *maintain_status.MaintainStatus
	addmaintain_status   *maintain_status.MaintainStatus
	due_time             *time.Time
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	updater              *int
	clearedupdater       bool
	risk_category        *int
	clearedrisk_category bool
	risk_location        *int
	clearedrisk_location bool
	maintainer           *int
	clearedmaintainer    bool
	done                 bool
	oldValue             func(context.Context) (*Risk, error)
	predicates           []predicate.Risk
}

var _ ent.Mutation = (*RiskMutation)(nil)

// riskOption allows management of the mutation configuration using functional options.
type riskOption func(*RiskMutation)

// newRiskMutation creates new mutation for the Risk entity.
func newRiskMutation(c config, op Op, opts ...riskOption) *RiskMutation {
	m := &RiskMutation{
		config:        c,
		op:            op,
		typ:           TypeRisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskID sets the ID field of the mutation.
func withRiskID(id int) riskOption {
	return func(m *RiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Risk
		)
		m.oldValue = func(ctx context.Context) (*Risk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Risk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRisk sets the old Risk of the mutation.
func withRisk(node *Risk) riskOption {
	return func(m *RiskMutation) {
		m.oldValue = func(context.Context) (*Risk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Risk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RiskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RiskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RiskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *RiskMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *RiskMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *RiskMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *RiskMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *RiskMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *RiskMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[risk.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *RiskMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[risk.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *RiskMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, risk.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *RiskMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *RiskMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *RiskMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RiskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RiskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RiskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTitle sets the "title" field.
func (m *RiskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RiskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RiskMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *RiskMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *RiskMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *RiskMutation) ClearContent() {
	m.content = nil
	m.clearedFields[risk.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *RiskMutation) ContentCleared() bool {
	_, ok := m.clearedFields[risk.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *RiskMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, risk.FieldContent)
}

// SetImages sets the "images" field.
func (m *RiskMutation) SetImages(ti []types.UploadedImage) {
	m.images = &ti
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *RiskMutation) Images() (r []types.UploadedImage, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldImages(ctx context.Context) (v []types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds ti to the "images" field.
func (m *RiskMutation) AppendImages(ti []types.UploadedImage) {
	m.appendimages = append(m.appendimages, ti...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *RiskMutation) AppendedImages() ([]types.UploadedImage, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *RiskMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[risk.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *RiskMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[risk.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *RiskMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, risk.FieldImages)
}

// SetRiskCategoryID sets the "risk_category_id" field.
func (m *RiskMutation) SetRiskCategoryID(i int) {
	m.risk_category = &i
}

// RiskCategoryID returns the value of the "risk_category_id" field in the mutation.
func (m *RiskMutation) RiskCategoryID() (r int, exists bool) {
	v := m.risk_category
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskCategoryID returns the old "risk_category_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskCategoryID: %w", err)
	}
	return oldValue.RiskCategoryID, nil
}

// ResetRiskCategoryID resets all changes to the "risk_category_id" field.
func (m *RiskMutation) ResetRiskCategoryID() {
	m.risk_category = nil
}

// SetRiskLocationID sets the "risk_location_id" field.
func (m *RiskMutation) SetRiskLocationID(i int) {
	m.risk_location = &i
}

// RiskLocationID returns the value of the "risk_location_id" field in the mutation.
func (m *RiskMutation) RiskLocationID() (r int, exists bool) {
	v := m.risk_location
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLocationID returns the old "risk_location_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLocationID: %w", err)
	}
	return oldValue.RiskLocationID, nil
}

// ResetRiskLocationID resets all changes to the "risk_location_id" field.
func (m *RiskMutation) ResetRiskLocationID() {
	m.risk_location = nil
}

// SetMaintainerID sets the "maintainer_id" field.
func (m *RiskMutation) SetMaintainerID(i int) {
	m.maintainer = &i
}

// MaintainerID returns the value of the "maintainer_id" field in the mutation.
func (m *RiskMutation) MaintainerID() (r int, exists bool) {
	v := m.maintainer
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainerID returns the old "maintainer_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainerID: %w", err)
	}
	return oldValue.MaintainerID, nil
}

// ResetMaintainerID resets all changes to the "maintainer_id" field.
func (m *RiskMutation) ResetMaintainerID() {
	m.maintainer = nil
}

// SetMeasures sets the "measures" field.
func (m *RiskMutation) SetMeasures(s string) {
	m.measures = &s
}

// Measures returns the value of the "measures" field in the mutation.
func (m *RiskMutation) Measures() (r string, exists bool) {
	v := m.measures
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasures returns the old "measures" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMeasures(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasures: %w", err)
	}
	return oldValue.Measures, nil
}

// ClearMeasures clears the value of the "measures" field.
func (m *RiskMutation) ClearMeasures() {
	m.measures = nil
	m.clearedFields[risk.FieldMeasures] = struct{}{}
}

// MeasuresCleared returns if the "measures" field was cleared in this mutation.
func (m *RiskMutation) MeasuresCleared() bool {
	_, ok := m.clearedFields[risk.FieldMeasures]
	return ok
}

// ResetMeasures resets all changes to the "measures" field.
func (m *RiskMutation) ResetMeasures() {
	m.measures = nil
	delete(m.clearedFields, risk.FieldMeasures)
}

// SetMaintainStatus sets the "maintain_status" field.
func (m *RiskMutation) SetMaintainStatus(mss maintain_status.MaintainStatus) {
	m.maintain_status = &mss
	m.addmaintain_status = nil
}

// MaintainStatus returns the value of the "maintain_status" field in the mutation.
func (m *RiskMutation) MaintainStatus() (r maintain_status.MaintainStatus, exists bool) {
	v := m.maintain_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainStatus returns the old "maintain_status" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainStatus(ctx context.Context) (v maintain_status.MaintainStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainStatus: %w", err)
	}
	return oldValue.MaintainStatus, nil
}

// AddMaintainStatus adds mss to the "maintain_status" field.
func (m *RiskMutation) AddMaintainStatus(mss maintain_status.MaintainStatus) {
	if m.addmaintain_status != nil {
		*m.addmaintain_status += mss
	} else {
		m.addmaintain_status = &mss
	}
}

// AddedMaintainStatus returns the value that was added to the "maintain_status" field in this mutation.
func (m *RiskMutation) AddedMaintainStatus() (r maintain_status.MaintainStatus, exists bool) {
	v := m.addmaintain_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainStatus resets all changes to the "maintain_status" field.
func (m *RiskMutation) ResetMaintainStatus() {
	m.maintain_status = nil
	m.addmaintain_status = nil
}

// SetDueTime sets the "due_time" field.
func (m *RiskMutation) SetDueTime(t time.Time) {
	m.due_time = &t
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *RiskMutation) DueTime() (r time.Time, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *RiskMutation) ResetDueTime() {
	m.due_time = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risk.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[risk.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearRiskCategory clears the "risk_category" edge to the RiskCategory entity.
func (m *RiskMutation) ClearRiskCategory() {
	m.clearedrisk_category = true
	m.clearedFields[risk.FieldRiskCategoryID] = struct{}{}
}

// RiskCategoryCleared reports if the "risk_category" edge to the RiskCategory entity was cleared.
func (m *RiskMutation) RiskCategoryCleared() bool {
	return m.clearedrisk_category
}

// RiskCategoryIDs returns the "risk_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskCategoryID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) RiskCategoryIDs() (ids []int) {
	if id := m.risk_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskCategory resets all changes to the "risk_category" edge.
func (m *RiskMutation) ResetRiskCategory() {
	m.risk_category = nil
	m.clearedrisk_category = false
}

// ClearRiskLocation clears the "risk_location" edge to the RiskLocation entity.
func (m *RiskMutation) ClearRiskLocation() {
	m.clearedrisk_location = true
	m.clearedFields[risk.FieldRiskLocationID] = struct{}{}
}

// RiskLocationCleared reports if the "risk_location" edge to the RiskLocation entity was cleared.
func (m *RiskMutation) RiskLocationCleared() bool {
	return m.clearedrisk_location
}

// RiskLocationIDs returns the "risk_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskLocationID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) RiskLocationIDs() (ids []int) {
	if id := m.risk_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskLocation resets all changes to the "risk_location" edge.
func (m *RiskMutation) ResetRiskLocation() {
	m.risk_location = nil
	m.clearedrisk_location = false
}

// ClearMaintainer clears the "maintainer" edge to the Admin entity.
func (m *RiskMutation) ClearMaintainer() {
	m.clearedmaintainer = true
	m.clearedFields[risk.FieldMaintainerID] = struct{}{}
}

// MaintainerCleared reports if the "maintainer" edge to the Admin entity was cleared.
func (m *RiskMutation) MaintainerCleared() bool {
	return m.clearedmaintainer
}

// MaintainerIDs returns the "maintainer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MaintainerID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) MaintainerIDs() (ids []int) {
	if id := m.maintainer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMaintainer resets all changes to the "maintainer" edge.
func (m *RiskMutation) ResetMaintainer() {
	m.maintainer = nil
	m.clearedmaintainer = false
}

// Where appends a list predicates to the RiskMutation builder.
func (m *RiskMutation) Where(ps ...predicate.Risk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Risk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Risk).
func (m *RiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, risk.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, risk.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, risk.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, risk.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, risk.FieldUpdateTime)
	}
	if m.title != nil {
		fields = append(fields, risk.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, risk.FieldContent)
	}
	if m.images != nil {
		fields = append(fields, risk.FieldImages)
	}
	if m.risk_category != nil {
		fields = append(fields, risk.FieldRiskCategoryID)
	}
	if m.risk_location != nil {
		fields = append(fields, risk.FieldRiskLocationID)
	}
	if m.maintainer != nil {
		fields = append(fields, risk.FieldMaintainerID)
	}
	if m.measures != nil {
		fields = append(fields, risk.FieldMeasures)
	}
	if m.maintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	if m.due_time != nil {
		fields = append(fields, risk.FieldDueTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldCreateTime:
		return m.CreateTime()
	case risk.FieldCreatorID:
		return m.CreatorID()
	case risk.FieldDeleteTime:
		return m.DeleteTime()
	case risk.FieldUpdaterID:
		return m.UpdaterID()
	case risk.FieldUpdateTime:
		return m.UpdateTime()
	case risk.FieldTitle:
		return m.Title()
	case risk.FieldContent:
		return m.Content()
	case risk.FieldImages:
		return m.Images()
	case risk.FieldRiskCategoryID:
		return m.RiskCategoryID()
	case risk.FieldRiskLocationID:
		return m.RiskLocationID()
	case risk.FieldMaintainerID:
		return m.MaintainerID()
	case risk.FieldMeasures:
		return m.Measures()
	case risk.FieldMaintainStatus:
		return m.MaintainStatus()
	case risk.FieldDueTime:
		return m.DueTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risk.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case risk.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case risk.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case risk.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case risk.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case risk.FieldTitle:
		return m.OldTitle(ctx)
	case risk.FieldContent:
		return m.OldContent(ctx)
	case risk.FieldImages:
		return m.OldImages(ctx)
	case risk.FieldRiskCategoryID:
		return m.OldRiskCategoryID(ctx)
	case risk.FieldRiskLocationID:
		return m.OldRiskLocationID(ctx)
	case risk.FieldMaintainerID:
		return m.OldMaintainerID(ctx)
	case risk.FieldMeasures:
		return m.OldMeasures(ctx)
	case risk.FieldMaintainStatus:
		return m.OldMaintainStatus(ctx)
	case risk.FieldDueTime:
		return m.OldDueTime(ctx)
	}
	return nil, fmt.Errorf("unknown Risk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risk.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case risk.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case risk.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case risk.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case risk.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case risk.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case risk.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case risk.FieldImages:
		v, ok := value.([]types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case risk.FieldRiskCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskCategoryID(v)
		return nil
	case risk.FieldRiskLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLocationID(v)
		return nil
	case risk.FieldMaintainerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainerID(v)
		return nil
	case risk.FieldMeasures:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasures(v)
		return nil
	case risk.FieldMaintainStatus:
		v, ok := value.(maintain_status.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainStatus(v)
		return nil
	case risk.FieldDueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskMutation) AddedFields() []string {
	var fields []string
	if m.addmaintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldMaintainStatus:
		return m.AddedMaintainStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case risk.FieldMaintainStatus:
		v, ok := value.(maintain_status.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Risk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risk.FieldDeleteTime) {
		fields = append(fields, risk.FieldDeleteTime)
	}
	if m.FieldCleared(risk.FieldContent) {
		fields = append(fields, risk.FieldContent)
	}
	if m.FieldCleared(risk.FieldImages) {
		fields = append(fields, risk.FieldImages)
	}
	if m.FieldCleared(risk.FieldMeasures) {
		fields = append(fields, risk.FieldMeasures)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskMutation) ClearField(name string) error {
	switch name {
	case risk.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case risk.FieldContent:
		m.ClearContent()
		return nil
	case risk.FieldImages:
		m.ClearImages()
		return nil
	case risk.FieldMeasures:
		m.ClearMeasures()
		return nil
	}
	return fmt.Errorf("unknown Risk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskMutation) ResetField(name string) error {
	switch name {
	case risk.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case risk.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case risk.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case risk.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case risk.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case risk.FieldTitle:
		m.ResetTitle()
		return nil
	case risk.FieldContent:
		m.ResetContent()
		return nil
	case risk.FieldImages:
		m.ResetImages()
		return nil
	case risk.FieldRiskCategoryID:
		m.ResetRiskCategoryID()
		return nil
	case risk.FieldRiskLocationID:
		m.ResetRiskLocationID()
		return nil
	case risk.FieldMaintainerID:
		m.ResetMaintainerID()
		return nil
	case risk.FieldMeasures:
		m.ResetMeasures()
		return nil
	case risk.FieldMaintainStatus:
		m.ResetMaintainStatus()
		return nil
	case risk.FieldDueTime:
		m.ResetDueTime()
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, risk.EdgeUpdater)
	}
	if m.risk_category != nil {
		edges = append(edges, risk.EdgeRiskCategory)
	}
	if m.risk_location != nil {
		edges = append(edges, risk.EdgeRiskLocation)
	}
	if m.maintainer != nil {
		edges = append(edges, risk.EdgeMaintainer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risk.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeRiskCategory:
		if id := m.risk_category; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeRiskLocation:
		if id := m.risk_location; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeMaintainer:
		if id := m.maintainer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, risk.EdgeUpdater)
	}
	if m.clearedrisk_category {
		edges = append(edges, risk.EdgeRiskCategory)
	}
	if m.clearedrisk_location {
		edges = append(edges, risk.EdgeRiskLocation)
	}
	if m.clearedmaintainer {
		edges = append(edges, risk.EdgeMaintainer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskMutation) EdgeCleared(name string) bool {
	switch name {
	case risk.EdgeCreator:
		return m.clearedcreator
	case risk.EdgeUpdater:
		return m.clearedupdater
	case risk.EdgeRiskCategory:
		return m.clearedrisk_category
	case risk.EdgeRiskLocation:
		return m.clearedrisk_location
	case risk.EdgeMaintainer:
		return m.clearedmaintainer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskMutation) ClearEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ClearCreator()
		return nil
	case risk.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case risk.EdgeRiskCategory:
		m.ClearRiskCategory()
		return nil
	case risk.EdgeRiskLocation:
		m.ClearRiskLocation()
		return nil
	case risk.EdgeMaintainer:
		m.ClearMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Risk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskMutation) ResetEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ResetCreator()
		return nil
	case risk.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case risk.EdgeRiskCategory:
		m.ResetRiskCategory()
		return nil
	case risk.EdgeRiskLocation:
		m.ResetRiskLocation()
		return nil
	case risk.EdgeMaintainer:
		m.ResetMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Risk edge %s", name)
}

// RiskCategoryMutation represents an operation that mutates the RiskCategory nodes in the graph.
type RiskCategoryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	delete_time    *time.Time
	update_time    *time.Time
	name           *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	risk           map[int]struct{}
	removedrisk    map[int]struct{}
	clearedrisk    bool
	sweep          map[int]struct{}
	removedsweep   map[int]struct{}
	clearedsweep   bool
	done           bool
	oldValue       func(context.Context) (*RiskCategory, error)
	predicates     []predicate.RiskCategory
}

var _ ent.Mutation = (*RiskCategoryMutation)(nil)

// riskcategoryOption allows management of the mutation configuration using functional options.
type riskcategoryOption func(*RiskCategoryMutation)

// newRiskCategoryMutation creates new mutation for the RiskCategory entity.
func newRiskCategoryMutation(c config, op Op, opts ...riskcategoryOption) *RiskCategoryMutation {
	m := &RiskCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskCategoryID sets the ID field of the mutation.
func withRiskCategoryID(id int) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskCategory
		)
		m.oldValue = func(ctx context.Context) (*RiskCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskCategory sets the old RiskCategory of the mutation.
func withRiskCategory(node *RiskCategory) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		m.oldValue = func(context.Context) (*RiskCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RiskCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RiskCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RiskCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *RiskCategoryMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *RiskCategoryMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *RiskCategoryMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *RiskCategoryMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *RiskCategoryMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *RiskCategoryMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[riskcategory.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *RiskCategoryMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[riskcategory.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *RiskCategoryMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, riskcategory.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *RiskCategoryMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *RiskCategoryMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *RiskCategoryMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RiskCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RiskCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RiskCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *RiskCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskCategoryMutation) ResetName() {
	m.name = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskCategoryMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[riskcategory.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskCategoryMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskCategoryMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskCategoryMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskCategoryMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[riskcategory.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskCategoryMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskCategoryMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskCategoryMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddRiskIDs adds the "risk" edge to the Risk entity by ids.
func (m *RiskCategoryMutation) AddRiskIDs(ids ...int) {
	if m.risk == nil {
		m.risk = make(map[int]struct{})
	}
	for i := range ids {
		m.risk[ids[i]] = struct{}{}
	}
}

// ClearRisk clears the "risk" edge to the Risk entity.
func (m *RiskCategoryMutation) ClearRisk() {
	m.clearedrisk = true
}

// RiskCleared reports if the "risk" edge to the Risk entity was cleared.
func (m *RiskCategoryMutation) RiskCleared() bool {
	return m.clearedrisk
}

// RemoveRiskIDs removes the "risk" edge to the Risk entity by IDs.
func (m *RiskCategoryMutation) RemoveRiskIDs(ids ...int) {
	if m.removedrisk == nil {
		m.removedrisk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk, ids[i])
		m.removedrisk[ids[i]] = struct{}{}
	}
}

// RemovedRisk returns the removed IDs of the "risk" edge to the Risk entity.
func (m *RiskCategoryMutation) RemovedRiskIDs() (ids []int) {
	for id := range m.removedrisk {
		ids = append(ids, id)
	}
	return
}

// RiskIDs returns the "risk" edge IDs in the mutation.
func (m *RiskCategoryMutation) RiskIDs() (ids []int) {
	for id := range m.risk {
		ids = append(ids, id)
	}
	return
}

// ResetRisk resets all changes to the "risk" edge.
func (m *RiskCategoryMutation) ResetRisk() {
	m.risk = nil
	m.clearedrisk = false
	m.removedrisk = nil
}

// AddSweepIDs adds the "sweep" edge to the Sweep entity by ids.
func (m *RiskCategoryMutation) AddSweepIDs(ids ...int) {
	if m.sweep == nil {
		m.sweep = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep[ids[i]] = struct{}{}
	}
}

// ClearSweep clears the "sweep" edge to the Sweep entity.
func (m *RiskCategoryMutation) ClearSweep() {
	m.clearedsweep = true
}

// SweepCleared reports if the "sweep" edge to the Sweep entity was cleared.
func (m *RiskCategoryMutation) SweepCleared() bool {
	return m.clearedsweep
}

// RemoveSweepIDs removes the "sweep" edge to the Sweep entity by IDs.
func (m *RiskCategoryMutation) RemoveSweepIDs(ids ...int) {
	if m.removedsweep == nil {
		m.removedsweep = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep, ids[i])
		m.removedsweep[ids[i]] = struct{}{}
	}
}

// RemovedSweep returns the removed IDs of the "sweep" edge to the Sweep entity.
func (m *RiskCategoryMutation) RemovedSweepIDs() (ids []int) {
	for id := range m.removedsweep {
		ids = append(ids, id)
	}
	return
}

// SweepIDs returns the "sweep" edge IDs in the mutation.
func (m *RiskCategoryMutation) SweepIDs() (ids []int) {
	for id := range m.sweep {
		ids = append(ids, id)
	}
	return
}

// ResetSweep resets all changes to the "sweep" edge.
func (m *RiskCategoryMutation) ResetSweep() {
	m.sweep = nil
	m.clearedsweep = false
	m.removedsweep = nil
}

// Where appends a list predicates to the RiskCategoryMutation builder.
func (m *RiskCategoryMutation) Where(ps ...predicate.RiskCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskCategory).
func (m *RiskCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, riskcategory.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, riskcategory.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, riskcategory.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, riskcategory.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, riskcategory.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, riskcategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case riskcategory.FieldCreateTime:
		return m.CreateTime()
	case riskcategory.FieldCreatorID:
		return m.CreatorID()
	case riskcategory.FieldDeleteTime:
		return m.DeleteTime()
	case riskcategory.FieldUpdaterID:
		return m.UpdaterID()
	case riskcategory.FieldUpdateTime:
		return m.UpdateTime()
	case riskcategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case riskcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case riskcategory.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case riskcategory.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case riskcategory.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case riskcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case riskcategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RiskCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case riskcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case riskcategory.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case riskcategory.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case riskcategory.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case riskcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case riskcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskCategoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiskCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(riskcategory.FieldDeleteTime) {
		fields = append(fields, riskcategory.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ClearField(name string) error {
	switch name {
	case riskcategory.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ResetField(name string) error {
	switch name {
	case riskcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case riskcategory.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case riskcategory.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case riskcategory.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case riskcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case riskcategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, riskcategory.EdgeUpdater)
	}
	if m.risk != nil {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	if m.sweep != nil {
		edges = append(edges, riskcategory.EdgeSweep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case riskcategory.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case riskcategory.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.risk))
		for id := range m.risk {
			ids = append(ids, id)
		}
		return ids
	case riskcategory.EdgeSweep:
		ids := make([]ent.Value, 0, len(m.sweep))
		for id := range m.sweep {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrisk != nil {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	if m.removedsweep != nil {
		edges = append(edges, riskcategory.EdgeSweep)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.removedrisk))
		for id := range m.removedrisk {
			ids = append(ids, id)
		}
		return ids
	case riskcategory.EdgeSweep:
		ids := make([]ent.Value, 0, len(m.removedsweep))
		for id := range m.removedsweep {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, riskcategory.EdgeUpdater)
	}
	if m.clearedrisk {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	if m.clearedsweep {
		edges = append(edges, riskcategory.EdgeSweep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case riskcategory.EdgeCreator:
		return m.clearedcreator
	case riskcategory.EdgeUpdater:
		return m.clearedupdater
	case riskcategory.EdgeRisk:
		return m.clearedrisk
	case riskcategory.EdgeSweep:
		return m.clearedsweep
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskCategoryMutation) ClearEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ClearCreator()
		return nil
	case riskcategory.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskCategoryMutation) ResetEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ResetCreator()
		return nil
	case riskcategory.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case riskcategory.EdgeRisk:
		m.ResetRisk()
		return nil
	case riskcategory.EdgeSweep:
		m.ResetSweep()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory edge %s", name)
}

// RiskLocationMutation represents an operation that mutates the RiskLocation nodes in the graph.
type RiskLocationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	delete_time    *time.Time
	update_time    *time.Time
	name           *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	risk           map[int]struct{}
	removedrisk    map[int]struct{}
	clearedrisk    bool
	sweep          map[int]struct{}
	removedsweep   map[int]struct{}
	clearedsweep   bool
	done           bool
	oldValue       func(context.Context) (*RiskLocation, error)
	predicates     []predicate.RiskLocation
}

var _ ent.Mutation = (*RiskLocationMutation)(nil)

// risklocationOption allows management of the mutation configuration using functional options.
type risklocationOption func(*RiskLocationMutation)

// newRiskLocationMutation creates new mutation for the RiskLocation entity.
func newRiskLocationMutation(c config, op Op, opts ...risklocationOption) *RiskLocationMutation {
	m := &RiskLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskLocationID sets the ID field of the mutation.
func withRiskLocationID(id int) risklocationOption {
	return func(m *RiskLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskLocation
		)
		m.oldValue = func(ctx context.Context) (*RiskLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskLocation sets the old RiskLocation of the mutation.
func withRiskLocation(node *RiskLocation) risklocationOption {
	return func(m *RiskLocationMutation) {
		m.oldValue = func(context.Context) (*RiskLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RiskLocationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RiskLocationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RiskLocationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *RiskLocationMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *RiskLocationMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *RiskLocationMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *RiskLocationMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *RiskLocationMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *RiskLocationMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[risklocation.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *RiskLocationMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[risklocation.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *RiskLocationMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, risklocation.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *RiskLocationMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *RiskLocationMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *RiskLocationMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RiskLocationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RiskLocationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RiskLocationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *RiskLocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskLocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskLocationMutation) ResetName() {
	m.name = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskLocationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risklocation.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskLocationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskLocationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskLocationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskLocationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[risklocation.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskLocationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskLocationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskLocationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddRiskIDs adds the "risk" edge to the Risk entity by ids.
func (m *RiskLocationMutation) AddRiskIDs(ids ...int) {
	if m.risk == nil {
		m.risk = make(map[int]struct{})
	}
	for i := range ids {
		m.risk[ids[i]] = struct{}{}
	}
}

// ClearRisk clears the "risk" edge to the Risk entity.
func (m *RiskLocationMutation) ClearRisk() {
	m.clearedrisk = true
}

// RiskCleared reports if the "risk" edge to the Risk entity was cleared.
func (m *RiskLocationMutation) RiskCleared() bool {
	return m.clearedrisk
}

// RemoveRiskIDs removes the "risk" edge to the Risk entity by IDs.
func (m *RiskLocationMutation) RemoveRiskIDs(ids ...int) {
	if m.removedrisk == nil {
		m.removedrisk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk, ids[i])
		m.removedrisk[ids[i]] = struct{}{}
	}
}

// RemovedRisk returns the removed IDs of the "risk" edge to the Risk entity.
func (m *RiskLocationMutation) RemovedRiskIDs() (ids []int) {
	for id := range m.removedrisk {
		ids = append(ids, id)
	}
	return
}

// RiskIDs returns the "risk" edge IDs in the mutation.
func (m *RiskLocationMutation) RiskIDs() (ids []int) {
	for id := range m.risk {
		ids = append(ids, id)
	}
	return
}

// ResetRisk resets all changes to the "risk" edge.
func (m *RiskLocationMutation) ResetRisk() {
	m.risk = nil
	m.clearedrisk = false
	m.removedrisk = nil
}

// AddSweepIDs adds the "sweep" edge to the Sweep entity by ids.
func (m *RiskLocationMutation) AddSweepIDs(ids ...int) {
	if m.sweep == nil {
		m.sweep = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep[ids[i]] = struct{}{}
	}
}

// ClearSweep clears the "sweep" edge to the Sweep entity.
func (m *RiskLocationMutation) ClearSweep() {
	m.clearedsweep = true
}

// SweepCleared reports if the "sweep" edge to the Sweep entity was cleared.
func (m *RiskLocationMutation) SweepCleared() bool {
	return m.clearedsweep
}

// RemoveSweepIDs removes the "sweep" edge to the Sweep entity by IDs.
func (m *RiskLocationMutation) RemoveSweepIDs(ids ...int) {
	if m.removedsweep == nil {
		m.removedsweep = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep, ids[i])
		m.removedsweep[ids[i]] = struct{}{}
	}
}

// RemovedSweep returns the removed IDs of the "sweep" edge to the Sweep entity.
func (m *RiskLocationMutation) RemovedSweepIDs() (ids []int) {
	for id := range m.removedsweep {
		ids = append(ids, id)
	}
	return
}

// SweepIDs returns the "sweep" edge IDs in the mutation.
func (m *RiskLocationMutation) SweepIDs() (ids []int) {
	for id := range m.sweep {
		ids = append(ids, id)
	}
	return
}

// ResetSweep resets all changes to the "sweep" edge.
func (m *RiskLocationMutation) ResetSweep() {
	m.sweep = nil
	m.clearedsweep = false
	m.removedsweep = nil
}

// Where appends a list predicates to the RiskLocationMutation builder.
func (m *RiskLocationMutation) Where(ps ...predicate.RiskLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskLocation).
func (m *RiskLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskLocationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, risklocation.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, risklocation.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, risklocation.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, risklocation.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, risklocation.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, risklocation.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risklocation.FieldCreateTime:
		return m.CreateTime()
	case risklocation.FieldCreatorID:
		return m.CreatorID()
	case risklocation.FieldDeleteTime:
		return m.DeleteTime()
	case risklocation.FieldUpdaterID:
		return m.UpdaterID()
	case risklocation.FieldUpdateTime:
		return m.UpdateTime()
	case risklocation.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risklocation.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case risklocation.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case risklocation.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case risklocation.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case risklocation.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case risklocation.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RiskLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risklocation.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case risklocation.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case risklocation.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case risklocation.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case risklocation.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case risklocation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskLocationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiskLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risklocation.FieldDeleteTime) {
		fields = append(fields, risklocation.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskLocationMutation) ClearField(name string) error {
	switch name {
	case risklocation.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskLocationMutation) ResetField(name string) error {
	switch name {
	case risklocation.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case risklocation.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case risklocation.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case risklocation.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case risklocation.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case risklocation.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, risklocation.EdgeUpdater)
	}
	if m.risk != nil {
		edges = append(edges, risklocation.EdgeRisk)
	}
	if m.sweep != nil {
		edges = append(edges, risklocation.EdgeSweep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risklocation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case risklocation.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.risk))
		for id := range m.risk {
			ids = append(ids, id)
		}
		return ids
	case risklocation.EdgeSweep:
		ids := make([]ent.Value, 0, len(m.sweep))
		for id := range m.sweep {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrisk != nil {
		edges = append(edges, risklocation.EdgeRisk)
	}
	if m.removedsweep != nil {
		edges = append(edges, risklocation.EdgeSweep)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskLocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.removedrisk))
		for id := range m.removedrisk {
			ids = append(ids, id)
		}
		return ids
	case risklocation.EdgeSweep:
		ids := make([]ent.Value, 0, len(m.removedsweep))
		for id := range m.removedsweep {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, risklocation.EdgeUpdater)
	}
	if m.clearedrisk {
		edges = append(edges, risklocation.EdgeRisk)
	}
	if m.clearedsweep {
		edges = append(edges, risklocation.EdgeSweep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case risklocation.EdgeCreator:
		return m.clearedcreator
	case risklocation.EdgeUpdater:
		return m.clearedupdater
	case risklocation.EdgeRisk:
		return m.clearedrisk
	case risklocation.EdgeSweep:
		return m.clearedsweep
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskLocationMutation) ClearEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ClearCreator()
		return nil
	case risklocation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskLocationMutation) ResetEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ResetCreator()
		return nil
	case risklocation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case risklocation.EdgeRisk:
		m.ResetRisk()
		return nil
	case risklocation.EdgeSweep:
		m.ResetSweep()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation edge %s", name)
}

// SweepMutation represents an operation that mutates the Sweep nodes in the graph.
type SweepMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	delete_time                 *time.Time
	update_time                 *time.Time
	name                        *string
	sweep_jobs                  *[]*types.SweepJob
	appendsweep_jobs            []*types.SweepJob
	clearedFields               map[string]struct{}
	creator                     *int
	clearedcreator              bool
	updater                     *int
	clearedupdater              bool
	risk_category               *int
	clearedrisk_category        bool
	risk_location               *int
	clearedrisk_location        bool
	sweep_schedule              map[int]struct{}
	removedsweep_schedule       map[int]struct{}
	clearedsweep_schedule       bool
	sweep_result                map[int]struct{}
	removedsweep_result         map[int]struct{}
	clearedsweep_result         bool
	sweep_result_details        map[int]struct{}
	removedsweep_result_details map[int]struct{}
	clearedsweep_result_details bool
	done                        bool
	oldValue                    func(context.Context) (*Sweep, error)
	predicates                  []predicate.Sweep
}

var _ ent.Mutation = (*SweepMutation)(nil)

// sweepOption allows management of the mutation configuration using functional options.
type sweepOption func(*SweepMutation)

// newSweepMutation creates new mutation for the Sweep entity.
func newSweepMutation(c config, op Op, opts ...sweepOption) *SweepMutation {
	m := &SweepMutation{
		config:        c,
		op:            op,
		typ:           TypeSweep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSweepID sets the ID field of the mutation.
func withSweepID(id int) sweepOption {
	return func(m *SweepMutation) {
		var (
			err   error
			once  sync.Once
			value *Sweep
		)
		m.oldValue = func(ctx context.Context) (*Sweep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sweep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSweep sets the old Sweep of the mutation.
func withSweep(node *Sweep) sweepOption {
	return func(m *SweepMutation) {
		m.oldValue = func(context.Context) (*Sweep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SweepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SweepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SweepMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SweepMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sweep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SweepMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SweepMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SweepMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *SweepMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *SweepMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *SweepMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SweepMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SweepMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SweepMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[sweep.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SweepMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[sweep.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SweepMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, sweep.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *SweepMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *SweepMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *SweepMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SweepMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SweepMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SweepMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *SweepMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SweepMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SweepMutation) ResetName() {
	m.name = nil
}

// SetRiskCategoryID sets the "risk_category_id" field.
func (m *SweepMutation) SetRiskCategoryID(i int) {
	m.risk_category = &i
}

// RiskCategoryID returns the value of the "risk_category_id" field in the mutation.
func (m *SweepMutation) RiskCategoryID() (r int, exists bool) {
	v := m.risk_category
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskCategoryID returns the old "risk_category_id" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldRiskCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskCategoryID: %w", err)
	}
	return oldValue.RiskCategoryID, nil
}

// ResetRiskCategoryID resets all changes to the "risk_category_id" field.
func (m *SweepMutation) ResetRiskCategoryID() {
	m.risk_category = nil
}

// SetRiskLocationID sets the "risk_location_id" field.
func (m *SweepMutation) SetRiskLocationID(i int) {
	m.risk_location = &i
}

// RiskLocationID returns the value of the "risk_location_id" field in the mutation.
func (m *SweepMutation) RiskLocationID() (r int, exists bool) {
	v := m.risk_location
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLocationID returns the old "risk_location_id" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldRiskLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLocationID: %w", err)
	}
	return oldValue.RiskLocationID, nil
}

// ResetRiskLocationID resets all changes to the "risk_location_id" field.
func (m *SweepMutation) ResetRiskLocationID() {
	m.risk_location = nil
}

// SetSweepJobs sets the "sweep_jobs" field.
func (m *SweepMutation) SetSweepJobs(tj []*types.SweepJob) {
	m.sweep_jobs = &tj
	m.appendsweep_jobs = nil
}

// SweepJobs returns the value of the "sweep_jobs" field in the mutation.
func (m *SweepMutation) SweepJobs() (r []*types.SweepJob, exists bool) {
	v := m.sweep_jobs
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepJobs returns the old "sweep_jobs" field's value of the Sweep entity.
// If the Sweep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepMutation) OldSweepJobs(ctx context.Context) (v []*types.SweepJob, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepJobs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepJobs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepJobs: %w", err)
	}
	return oldValue.SweepJobs, nil
}

// AppendSweepJobs adds tj to the "sweep_jobs" field.
func (m *SweepMutation) AppendSweepJobs(tj []*types.SweepJob) {
	m.appendsweep_jobs = append(m.appendsweep_jobs, tj...)
}

// AppendedSweepJobs returns the list of values that were appended to the "sweep_jobs" field in this mutation.
func (m *SweepMutation) AppendedSweepJobs() ([]*types.SweepJob, bool) {
	if len(m.appendsweep_jobs) == 0 {
		return nil, false
	}
	return m.appendsweep_jobs, true
}

// ClearSweepJobs clears the value of the "sweep_jobs" field.
func (m *SweepMutation) ClearSweepJobs() {
	m.sweep_jobs = nil
	m.appendsweep_jobs = nil
	m.clearedFields[sweep.FieldSweepJobs] = struct{}{}
}

// SweepJobsCleared returns if the "sweep_jobs" field was cleared in this mutation.
func (m *SweepMutation) SweepJobsCleared() bool {
	_, ok := m.clearedFields[sweep.FieldSweepJobs]
	return ok
}

// ResetSweepJobs resets all changes to the "sweep_jobs" field.
func (m *SweepMutation) ResetSweepJobs() {
	m.sweep_jobs = nil
	m.appendsweep_jobs = nil
	delete(m.clearedFields, sweep.FieldSweepJobs)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *SweepMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[sweep.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *SweepMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *SweepMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *SweepMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *SweepMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[sweep.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *SweepMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *SweepMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *SweepMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearRiskCategory clears the "risk_category" edge to the RiskCategory entity.
func (m *SweepMutation) ClearRiskCategory() {
	m.clearedrisk_category = true
	m.clearedFields[sweep.FieldRiskCategoryID] = struct{}{}
}

// RiskCategoryCleared reports if the "risk_category" edge to the RiskCategory entity was cleared.
func (m *SweepMutation) RiskCategoryCleared() bool {
	return m.clearedrisk_category
}

// RiskCategoryIDs returns the "risk_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskCategoryID instead. It exists only for internal usage by the builders.
func (m *SweepMutation) RiskCategoryIDs() (ids []int) {
	if id := m.risk_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskCategory resets all changes to the "risk_category" edge.
func (m *SweepMutation) ResetRiskCategory() {
	m.risk_category = nil
	m.clearedrisk_category = false
}

// ClearRiskLocation clears the "risk_location" edge to the RiskLocation entity.
func (m *SweepMutation) ClearRiskLocation() {
	m.clearedrisk_location = true
	m.clearedFields[sweep.FieldRiskLocationID] = struct{}{}
}

// RiskLocationCleared reports if the "risk_location" edge to the RiskLocation entity was cleared.
func (m *SweepMutation) RiskLocationCleared() bool {
	return m.clearedrisk_location
}

// RiskLocationIDs returns the "risk_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskLocationID instead. It exists only for internal usage by the builders.
func (m *SweepMutation) RiskLocationIDs() (ids []int) {
	if id := m.risk_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskLocation resets all changes to the "risk_location" edge.
func (m *SweepMutation) ResetRiskLocation() {
	m.risk_location = nil
	m.clearedrisk_location = false
}

// AddSweepScheduleIDs adds the "sweep_schedule" edge to the SweepSchedule entity by ids.
func (m *SweepMutation) AddSweepScheduleIDs(ids ...int) {
	if m.sweep_schedule == nil {
		m.sweep_schedule = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_schedule[ids[i]] = struct{}{}
	}
}

// ClearSweepSchedule clears the "sweep_schedule" edge to the SweepSchedule entity.
func (m *SweepMutation) ClearSweepSchedule() {
	m.clearedsweep_schedule = true
}

// SweepScheduleCleared reports if the "sweep_schedule" edge to the SweepSchedule entity was cleared.
func (m *SweepMutation) SweepScheduleCleared() bool {
	return m.clearedsweep_schedule
}

// RemoveSweepScheduleIDs removes the "sweep_schedule" edge to the SweepSchedule entity by IDs.
func (m *SweepMutation) RemoveSweepScheduleIDs(ids ...int) {
	if m.removedsweep_schedule == nil {
		m.removedsweep_schedule = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_schedule, ids[i])
		m.removedsweep_schedule[ids[i]] = struct{}{}
	}
}

// RemovedSweepSchedule returns the removed IDs of the "sweep_schedule" edge to the SweepSchedule entity.
func (m *SweepMutation) RemovedSweepScheduleIDs() (ids []int) {
	for id := range m.removedsweep_schedule {
		ids = append(ids, id)
	}
	return
}

// SweepScheduleIDs returns the "sweep_schedule" edge IDs in the mutation.
func (m *SweepMutation) SweepScheduleIDs() (ids []int) {
	for id := range m.sweep_schedule {
		ids = append(ids, id)
	}
	return
}

// ResetSweepSchedule resets all changes to the "sweep_schedule" edge.
func (m *SweepMutation) ResetSweepSchedule() {
	m.sweep_schedule = nil
	m.clearedsweep_schedule = false
	m.removedsweep_schedule = nil
}

// AddSweepResultIDs adds the "sweep_result" edge to the SweepResult entity by ids.
func (m *SweepMutation) AddSweepResultIDs(ids ...int) {
	if m.sweep_result == nil {
		m.sweep_result = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result[ids[i]] = struct{}{}
	}
}

// ClearSweepResult clears the "sweep_result" edge to the SweepResult entity.
func (m *SweepMutation) ClearSweepResult() {
	m.clearedsweep_result = true
}

// SweepResultCleared reports if the "sweep_result" edge to the SweepResult entity was cleared.
func (m *SweepMutation) SweepResultCleared() bool {
	return m.clearedsweep_result
}

// RemoveSweepResultIDs removes the "sweep_result" edge to the SweepResult entity by IDs.
func (m *SweepMutation) RemoveSweepResultIDs(ids ...int) {
	if m.removedsweep_result == nil {
		m.removedsweep_result = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result, ids[i])
		m.removedsweep_result[ids[i]] = struct{}{}
	}
}

// RemovedSweepResult returns the removed IDs of the "sweep_result" edge to the SweepResult entity.
func (m *SweepMutation) RemovedSweepResultIDs() (ids []int) {
	for id := range m.removedsweep_result {
		ids = append(ids, id)
	}
	return
}

// SweepResultIDs returns the "sweep_result" edge IDs in the mutation.
func (m *SweepMutation) SweepResultIDs() (ids []int) {
	for id := range m.sweep_result {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResult resets all changes to the "sweep_result" edge.
func (m *SweepMutation) ResetSweepResult() {
	m.sweep_result = nil
	m.clearedsweep_result = false
	m.removedsweep_result = nil
}

// AddSweepResultDetailIDs adds the "sweep_result_details" edge to the SweepResultDetails entity by ids.
func (m *SweepMutation) AddSweepResultDetailIDs(ids ...int) {
	if m.sweep_result_details == nil {
		m.sweep_result_details = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result_details[ids[i]] = struct{}{}
	}
}

// ClearSweepResultDetails clears the "sweep_result_details" edge to the SweepResultDetails entity.
func (m *SweepMutation) ClearSweepResultDetails() {
	m.clearedsweep_result_details = true
}

// SweepResultDetailsCleared reports if the "sweep_result_details" edge to the SweepResultDetails entity was cleared.
func (m *SweepMutation) SweepResultDetailsCleared() bool {
	return m.clearedsweep_result_details
}

// RemoveSweepResultDetailIDs removes the "sweep_result_details" edge to the SweepResultDetails entity by IDs.
func (m *SweepMutation) RemoveSweepResultDetailIDs(ids ...int) {
	if m.removedsweep_result_details == nil {
		m.removedsweep_result_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result_details, ids[i])
		m.removedsweep_result_details[ids[i]] = struct{}{}
	}
}

// RemovedSweepResultDetails returns the removed IDs of the "sweep_result_details" edge to the SweepResultDetails entity.
func (m *SweepMutation) RemovedSweepResultDetailsIDs() (ids []int) {
	for id := range m.removedsweep_result_details {
		ids = append(ids, id)
	}
	return
}

// SweepResultDetailsIDs returns the "sweep_result_details" edge IDs in the mutation.
func (m *SweepMutation) SweepResultDetailsIDs() (ids []int) {
	for id := range m.sweep_result_details {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResultDetails resets all changes to the "sweep_result_details" edge.
func (m *SweepMutation) ResetSweepResultDetails() {
	m.sweep_result_details = nil
	m.clearedsweep_result_details = false
	m.removedsweep_result_details = nil
}

// Where appends a list predicates to the SweepMutation builder.
func (m *SweepMutation) Where(ps ...predicate.Sweep) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SweepMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SweepMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sweep, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SweepMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SweepMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sweep).
func (m *SweepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SweepMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, sweep.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, sweep.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, sweep.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, sweep.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, sweep.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, sweep.FieldName)
	}
	if m.risk_category != nil {
		fields = append(fields, sweep.FieldRiskCategoryID)
	}
	if m.risk_location != nil {
		fields = append(fields, sweep.FieldRiskLocationID)
	}
	if m.sweep_jobs != nil {
		fields = append(fields, sweep.FieldSweepJobs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SweepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sweep.FieldCreateTime:
		return m.CreateTime()
	case sweep.FieldCreatorID:
		return m.CreatorID()
	case sweep.FieldDeleteTime:
		return m.DeleteTime()
	case sweep.FieldUpdaterID:
		return m.UpdaterID()
	case sweep.FieldUpdateTime:
		return m.UpdateTime()
	case sweep.FieldName:
		return m.Name()
	case sweep.FieldRiskCategoryID:
		return m.RiskCategoryID()
	case sweep.FieldRiskLocationID:
		return m.RiskLocationID()
	case sweep.FieldSweepJobs:
		return m.SweepJobs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SweepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sweep.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sweep.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case sweep.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case sweep.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case sweep.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sweep.FieldName:
		return m.OldName(ctx)
	case sweep.FieldRiskCategoryID:
		return m.OldRiskCategoryID(ctx)
	case sweep.FieldRiskLocationID:
		return m.OldRiskLocationID(ctx)
	case sweep.FieldSweepJobs:
		return m.OldSweepJobs(ctx)
	}
	return nil, fmt.Errorf("unknown Sweep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sweep.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sweep.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case sweep.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case sweep.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case sweep.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sweep.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sweep.FieldRiskCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskCategoryID(v)
		return nil
	case sweep.FieldRiskLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLocationID(v)
		return nil
	case sweep.FieldSweepJobs:
		v, ok := value.([]*types.SweepJob)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepJobs(v)
		return nil
	}
	return fmt.Errorf("unknown Sweep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SweepMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SweepMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Sweep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SweepMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sweep.FieldDeleteTime) {
		fields = append(fields, sweep.FieldDeleteTime)
	}
	if m.FieldCleared(sweep.FieldSweepJobs) {
		fields = append(fields, sweep.FieldSweepJobs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SweepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SweepMutation) ClearField(name string) error {
	switch name {
	case sweep.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case sweep.FieldSweepJobs:
		m.ClearSweepJobs()
		return nil
	}
	return fmt.Errorf("unknown Sweep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SweepMutation) ResetField(name string) error {
	switch name {
	case sweep.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sweep.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case sweep.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case sweep.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case sweep.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sweep.FieldName:
		m.ResetName()
		return nil
	case sweep.FieldRiskCategoryID:
		m.ResetRiskCategoryID()
		return nil
	case sweep.FieldRiskLocationID:
		m.ResetRiskLocationID()
		return nil
	case sweep.FieldSweepJobs:
		m.ResetSweepJobs()
		return nil
	}
	return fmt.Errorf("unknown Sweep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SweepMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.creator != nil {
		edges = append(edges, sweep.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, sweep.EdgeUpdater)
	}
	if m.risk_category != nil {
		edges = append(edges, sweep.EdgeRiskCategory)
	}
	if m.risk_location != nil {
		edges = append(edges, sweep.EdgeRiskLocation)
	}
	if m.sweep_schedule != nil {
		edges = append(edges, sweep.EdgeSweepSchedule)
	}
	if m.sweep_result != nil {
		edges = append(edges, sweep.EdgeSweepResult)
	}
	if m.sweep_result_details != nil {
		edges = append(edges, sweep.EdgeSweepResultDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SweepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sweep.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case sweep.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case sweep.EdgeRiskCategory:
		if id := m.risk_category; id != nil {
			return []ent.Value{*id}
		}
	case sweep.EdgeRiskLocation:
		if id := m.risk_location; id != nil {
			return []ent.Value{*id}
		}
	case sweep.EdgeSweepSchedule:
		ids := make([]ent.Value, 0, len(m.sweep_schedule))
		for id := range m.sweep_schedule {
			ids = append(ids, id)
		}
		return ids
	case sweep.EdgeSweepResult:
		ids := make([]ent.Value, 0, len(m.sweep_result))
		for id := range m.sweep_result {
			ids = append(ids, id)
		}
		return ids
	case sweep.EdgeSweepResultDetails:
		ids := make([]ent.Value, 0, len(m.sweep_result_details))
		for id := range m.sweep_result_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SweepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedsweep_schedule != nil {
		edges = append(edges, sweep.EdgeSweepSchedule)
	}
	if m.removedsweep_result != nil {
		edges = append(edges, sweep.EdgeSweepResult)
	}
	if m.removedsweep_result_details != nil {
		edges = append(edges, sweep.EdgeSweepResultDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SweepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sweep.EdgeSweepSchedule:
		ids := make([]ent.Value, 0, len(m.removedsweep_schedule))
		for id := range m.removedsweep_schedule {
			ids = append(ids, id)
		}
		return ids
	case sweep.EdgeSweepResult:
		ids := make([]ent.Value, 0, len(m.removedsweep_result))
		for id := range m.removedsweep_result {
			ids = append(ids, id)
		}
		return ids
	case sweep.EdgeSweepResultDetails:
		ids := make([]ent.Value, 0, len(m.removedsweep_result_details))
		for id := range m.removedsweep_result_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SweepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcreator {
		edges = append(edges, sweep.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, sweep.EdgeUpdater)
	}
	if m.clearedrisk_category {
		edges = append(edges, sweep.EdgeRiskCategory)
	}
	if m.clearedrisk_location {
		edges = append(edges, sweep.EdgeRiskLocation)
	}
	if m.clearedsweep_schedule {
		edges = append(edges, sweep.EdgeSweepSchedule)
	}
	if m.clearedsweep_result {
		edges = append(edges, sweep.EdgeSweepResult)
	}
	if m.clearedsweep_result_details {
		edges = append(edges, sweep.EdgeSweepResultDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SweepMutation) EdgeCleared(name string) bool {
	switch name {
	case sweep.EdgeCreator:
		return m.clearedcreator
	case sweep.EdgeUpdater:
		return m.clearedupdater
	case sweep.EdgeRiskCategory:
		return m.clearedrisk_category
	case sweep.EdgeRiskLocation:
		return m.clearedrisk_location
	case sweep.EdgeSweepSchedule:
		return m.clearedsweep_schedule
	case sweep.EdgeSweepResult:
		return m.clearedsweep_result
	case sweep.EdgeSweepResultDetails:
		return m.clearedsweep_result_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SweepMutation) ClearEdge(name string) error {
	switch name {
	case sweep.EdgeCreator:
		m.ClearCreator()
		return nil
	case sweep.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case sweep.EdgeRiskCategory:
		m.ClearRiskCategory()
		return nil
	case sweep.EdgeRiskLocation:
		m.ClearRiskLocation()
		return nil
	}
	return fmt.Errorf("unknown Sweep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SweepMutation) ResetEdge(name string) error {
	switch name {
	case sweep.EdgeCreator:
		m.ResetCreator()
		return nil
	case sweep.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case sweep.EdgeRiskCategory:
		m.ResetRiskCategory()
		return nil
	case sweep.EdgeRiskLocation:
		m.ResetRiskLocation()
		return nil
	case sweep.EdgeSweepSchedule:
		m.ResetSweepSchedule()
		return nil
	case sweep.EdgeSweepResult:
		m.ResetSweepResult()
		return nil
	case sweep.EdgeSweepResultDetails:
		m.ResetSweepResultDetails()
		return nil
	}
	return fmt.Errorf("unknown Sweep edge %s", name)
}

// SweepResultMutation represents an operation that mutates the SweepResult nodes in the graph.
type SweepResultMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	delete_time                 *time.Time
	update_time                 *time.Time
	check_in_time               *time.Time
	check_in_image              *types.UploadedImage
	sweep_jobs                  *[]*types.SweepJob
	appendsweep_jobs            []*types.SweepJob
	clearedFields               map[string]struct{}
	creator                     *int
	clearedcreator              bool
	updater                     *int
	clearedupdater              bool
	sweep                       *int
	clearedsweep                bool
	sweep_schedule              *int
	clearedsweep_schedule       bool
	sweep_result_details        map[int]struct{}
	removedsweep_result_details map[int]struct{}
	clearedsweep_result_details bool
	done                        bool
	oldValue                    func(context.Context) (*SweepResult, error)
	predicates                  []predicate.SweepResult
}

var _ ent.Mutation = (*SweepResultMutation)(nil)

// sweepresultOption allows management of the mutation configuration using functional options.
type sweepresultOption func(*SweepResultMutation)

// newSweepResultMutation creates new mutation for the SweepResult entity.
func newSweepResultMutation(c config, op Op, opts ...sweepresultOption) *SweepResultMutation {
	m := &SweepResultMutation{
		config:        c,
		op:            op,
		typ:           TypeSweepResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSweepResultID sets the ID field of the mutation.
func withSweepResultID(id int) sweepresultOption {
	return func(m *SweepResultMutation) {
		var (
			err   error
			once  sync.Once
			value *SweepResult
		)
		m.oldValue = func(ctx context.Context) (*SweepResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SweepResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSweepResult sets the old SweepResult of the mutation.
func withSweepResult(node *SweepResult) sweepresultOption {
	return func(m *SweepResultMutation) {
		m.oldValue = func(context.Context) (*SweepResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SweepResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SweepResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SweepResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SweepResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SweepResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SweepResultMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SweepResultMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SweepResultMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *SweepResultMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *SweepResultMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *SweepResultMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SweepResultMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SweepResultMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SweepResultMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[sweepresult.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SweepResultMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[sweepresult.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SweepResultMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, sweepresult.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *SweepResultMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *SweepResultMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *SweepResultMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SweepResultMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SweepResultMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SweepResultMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSweepID sets the "sweep_id" field.
func (m *SweepResultMutation) SetSweepID(i int) {
	m.sweep = &i
}

// SweepID returns the value of the "sweep_id" field in the mutation.
func (m *SweepResultMutation) SweepID() (r int, exists bool) {
	v := m.sweep
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepID returns the old "sweep_id" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldSweepID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepID: %w", err)
	}
	return oldValue.SweepID, nil
}

// ResetSweepID resets all changes to the "sweep_id" field.
func (m *SweepResultMutation) ResetSweepID() {
	m.sweep = nil
}

// SetSweepScheduleID sets the "sweep_schedule_id" field.
func (m *SweepResultMutation) SetSweepScheduleID(i int) {
	m.sweep_schedule = &i
}

// SweepScheduleID returns the value of the "sweep_schedule_id" field in the mutation.
func (m *SweepResultMutation) SweepScheduleID() (r int, exists bool) {
	v := m.sweep_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepScheduleID returns the old "sweep_schedule_id" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldSweepScheduleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepScheduleID: %w", err)
	}
	return oldValue.SweepScheduleID, nil
}

// ResetSweepScheduleID resets all changes to the "sweep_schedule_id" field.
func (m *SweepResultMutation) ResetSweepScheduleID() {
	m.sweep_schedule = nil
}

// SetCheckInTime sets the "check_in_time" field.
func (m *SweepResultMutation) SetCheckInTime(t time.Time) {
	m.check_in_time = &t
}

// CheckInTime returns the value of the "check_in_time" field in the mutation.
func (m *SweepResultMutation) CheckInTime() (r time.Time, exists bool) {
	v := m.check_in_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInTime returns the old "check_in_time" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldCheckInTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInTime: %w", err)
	}
	return oldValue.CheckInTime, nil
}

// ClearCheckInTime clears the value of the "check_in_time" field.
func (m *SweepResultMutation) ClearCheckInTime() {
	m.check_in_time = nil
	m.clearedFields[sweepresult.FieldCheckInTime] = struct{}{}
}

// CheckInTimeCleared returns if the "check_in_time" field was cleared in this mutation.
func (m *SweepResultMutation) CheckInTimeCleared() bool {
	_, ok := m.clearedFields[sweepresult.FieldCheckInTime]
	return ok
}

// ResetCheckInTime resets all changes to the "check_in_time" field.
func (m *SweepResultMutation) ResetCheckInTime() {
	m.check_in_time = nil
	delete(m.clearedFields, sweepresult.FieldCheckInTime)
}

// SetCheckInImage sets the "check_in_image" field.
func (m *SweepResultMutation) SetCheckInImage(ti types.UploadedImage) {
	m.check_in_image = &ti
}

// CheckInImage returns the value of the "check_in_image" field in the mutation.
func (m *SweepResultMutation) CheckInImage() (r types.UploadedImage, exists bool) {
	v := m.check_in_image
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInImage returns the old "check_in_image" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldCheckInImage(ctx context.Context) (v types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInImage: %w", err)
	}
	return oldValue.CheckInImage, nil
}

// ClearCheckInImage clears the value of the "check_in_image" field.
func (m *SweepResultMutation) ClearCheckInImage() {
	m.check_in_image = nil
	m.clearedFields[sweepresult.FieldCheckInImage] = struct{}{}
}

// CheckInImageCleared returns if the "check_in_image" field was cleared in this mutation.
func (m *SweepResultMutation) CheckInImageCleared() bool {
	_, ok := m.clearedFields[sweepresult.FieldCheckInImage]
	return ok
}

// ResetCheckInImage resets all changes to the "check_in_image" field.
func (m *SweepResultMutation) ResetCheckInImage() {
	m.check_in_image = nil
	delete(m.clearedFields, sweepresult.FieldCheckInImage)
}

// SetSweepJobs sets the "sweep_jobs" field.
func (m *SweepResultMutation) SetSweepJobs(tj []*types.SweepJob) {
	m.sweep_jobs = &tj
	m.appendsweep_jobs = nil
}

// SweepJobs returns the value of the "sweep_jobs" field in the mutation.
func (m *SweepResultMutation) SweepJobs() (r []*types.SweepJob, exists bool) {
	v := m.sweep_jobs
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepJobs returns the old "sweep_jobs" field's value of the SweepResult entity.
// If the SweepResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultMutation) OldSweepJobs(ctx context.Context) (v []*types.SweepJob, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepJobs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepJobs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepJobs: %w", err)
	}
	return oldValue.SweepJobs, nil
}

// AppendSweepJobs adds tj to the "sweep_jobs" field.
func (m *SweepResultMutation) AppendSweepJobs(tj []*types.SweepJob) {
	m.appendsweep_jobs = append(m.appendsweep_jobs, tj...)
}

// AppendedSweepJobs returns the list of values that were appended to the "sweep_jobs" field in this mutation.
func (m *SweepResultMutation) AppendedSweepJobs() ([]*types.SweepJob, bool) {
	if len(m.appendsweep_jobs) == 0 {
		return nil, false
	}
	return m.appendsweep_jobs, true
}

// ClearSweepJobs clears the value of the "sweep_jobs" field.
func (m *SweepResultMutation) ClearSweepJobs() {
	m.sweep_jobs = nil
	m.appendsweep_jobs = nil
	m.clearedFields[sweepresult.FieldSweepJobs] = struct{}{}
}

// SweepJobsCleared returns if the "sweep_jobs" field was cleared in this mutation.
func (m *SweepResultMutation) SweepJobsCleared() bool {
	_, ok := m.clearedFields[sweepresult.FieldSweepJobs]
	return ok
}

// ResetSweepJobs resets all changes to the "sweep_jobs" field.
func (m *SweepResultMutation) ResetSweepJobs() {
	m.sweep_jobs = nil
	m.appendsweep_jobs = nil
	delete(m.clearedFields, sweepresult.FieldSweepJobs)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *SweepResultMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[sweepresult.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *SweepResultMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *SweepResultMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *SweepResultMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *SweepResultMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[sweepresult.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *SweepResultMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *SweepResultMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *SweepResultMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearSweep clears the "sweep" edge to the Sweep entity.
func (m *SweepResultMutation) ClearSweep() {
	m.clearedsweep = true
	m.clearedFields[sweepresult.FieldSweepID] = struct{}{}
}

// SweepCleared reports if the "sweep" edge to the Sweep entity was cleared.
func (m *SweepResultMutation) SweepCleared() bool {
	return m.clearedsweep
}

// SweepIDs returns the "sweep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SweepID instead. It exists only for internal usage by the builders.
func (m *SweepResultMutation) SweepIDs() (ids []int) {
	if id := m.sweep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSweep resets all changes to the "sweep" edge.
func (m *SweepResultMutation) ResetSweep() {
	m.sweep = nil
	m.clearedsweep = false
}

// ClearSweepSchedule clears the "sweep_schedule" edge to the SweepSchedule entity.
func (m *SweepResultMutation) ClearSweepSchedule() {
	m.clearedsweep_schedule = true
	m.clearedFields[sweepresult.FieldSweepScheduleID] = struct{}{}
}

// SweepScheduleCleared reports if the "sweep_schedule" edge to the SweepSchedule entity was cleared.
func (m *SweepResultMutation) SweepScheduleCleared() bool {
	return m.clearedsweep_schedule
}

// SweepScheduleIDs returns the "sweep_schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SweepScheduleID instead. It exists only for internal usage by the builders.
func (m *SweepResultMutation) SweepScheduleIDs() (ids []int) {
	if id := m.sweep_schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSweepSchedule resets all changes to the "sweep_schedule" edge.
func (m *SweepResultMutation) ResetSweepSchedule() {
	m.sweep_schedule = nil
	m.clearedsweep_schedule = false
}

// AddSweepResultDetailIDs adds the "sweep_result_details" edge to the SweepResultDetails entity by ids.
func (m *SweepResultMutation) AddSweepResultDetailIDs(ids ...int) {
	if m.sweep_result_details == nil {
		m.sweep_result_details = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result_details[ids[i]] = struct{}{}
	}
}

// ClearSweepResultDetails clears the "sweep_result_details" edge to the SweepResultDetails entity.
func (m *SweepResultMutation) ClearSweepResultDetails() {
	m.clearedsweep_result_details = true
}

// SweepResultDetailsCleared reports if the "sweep_result_details" edge to the SweepResultDetails entity was cleared.
func (m *SweepResultMutation) SweepResultDetailsCleared() bool {
	return m.clearedsweep_result_details
}

// RemoveSweepResultDetailIDs removes the "sweep_result_details" edge to the SweepResultDetails entity by IDs.
func (m *SweepResultMutation) RemoveSweepResultDetailIDs(ids ...int) {
	if m.removedsweep_result_details == nil {
		m.removedsweep_result_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result_details, ids[i])
		m.removedsweep_result_details[ids[i]] = struct{}{}
	}
}

// RemovedSweepResultDetails returns the removed IDs of the "sweep_result_details" edge to the SweepResultDetails entity.
func (m *SweepResultMutation) RemovedSweepResultDetailsIDs() (ids []int) {
	for id := range m.removedsweep_result_details {
		ids = append(ids, id)
	}
	return
}

// SweepResultDetailsIDs returns the "sweep_result_details" edge IDs in the mutation.
func (m *SweepResultMutation) SweepResultDetailsIDs() (ids []int) {
	for id := range m.sweep_result_details {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResultDetails resets all changes to the "sweep_result_details" edge.
func (m *SweepResultMutation) ResetSweepResultDetails() {
	m.sweep_result_details = nil
	m.clearedsweep_result_details = false
	m.removedsweep_result_details = nil
}

// Where appends a list predicates to the SweepResultMutation builder.
func (m *SweepResultMutation) Where(ps ...predicate.SweepResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SweepResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SweepResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SweepResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SweepResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SweepResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SweepResult).
func (m *SweepResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SweepResultMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, sweepresult.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, sweepresult.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, sweepresult.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, sweepresult.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, sweepresult.FieldUpdateTime)
	}
	if m.sweep != nil {
		fields = append(fields, sweepresult.FieldSweepID)
	}
	if m.sweep_schedule != nil {
		fields = append(fields, sweepresult.FieldSweepScheduleID)
	}
	if m.check_in_time != nil {
		fields = append(fields, sweepresult.FieldCheckInTime)
	}
	if m.check_in_image != nil {
		fields = append(fields, sweepresult.FieldCheckInImage)
	}
	if m.sweep_jobs != nil {
		fields = append(fields, sweepresult.FieldSweepJobs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SweepResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sweepresult.FieldCreateTime:
		return m.CreateTime()
	case sweepresult.FieldCreatorID:
		return m.CreatorID()
	case sweepresult.FieldDeleteTime:
		return m.DeleteTime()
	case sweepresult.FieldUpdaterID:
		return m.UpdaterID()
	case sweepresult.FieldUpdateTime:
		return m.UpdateTime()
	case sweepresult.FieldSweepID:
		return m.SweepID()
	case sweepresult.FieldSweepScheduleID:
		return m.SweepScheduleID()
	case sweepresult.FieldCheckInTime:
		return m.CheckInTime()
	case sweepresult.FieldCheckInImage:
		return m.CheckInImage()
	case sweepresult.FieldSweepJobs:
		return m.SweepJobs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SweepResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sweepresult.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sweepresult.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case sweepresult.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case sweepresult.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case sweepresult.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sweepresult.FieldSweepID:
		return m.OldSweepID(ctx)
	case sweepresult.FieldSweepScheduleID:
		return m.OldSweepScheduleID(ctx)
	case sweepresult.FieldCheckInTime:
		return m.OldCheckInTime(ctx)
	case sweepresult.FieldCheckInImage:
		return m.OldCheckInImage(ctx)
	case sweepresult.FieldSweepJobs:
		return m.OldSweepJobs(ctx)
	}
	return nil, fmt.Errorf("unknown SweepResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sweepresult.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sweepresult.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case sweepresult.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case sweepresult.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case sweepresult.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sweepresult.FieldSweepID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepID(v)
		return nil
	case sweepresult.FieldSweepScheduleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepScheduleID(v)
		return nil
	case sweepresult.FieldCheckInTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInTime(v)
		return nil
	case sweepresult.FieldCheckInImage:
		v, ok := value.(types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInImage(v)
		return nil
	case sweepresult.FieldSweepJobs:
		v, ok := value.([]*types.SweepJob)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepJobs(v)
		return nil
	}
	return fmt.Errorf("unknown SweepResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SweepResultMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SweepResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SweepResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SweepResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sweepresult.FieldDeleteTime) {
		fields = append(fields, sweepresult.FieldDeleteTime)
	}
	if m.FieldCleared(sweepresult.FieldCheckInTime) {
		fields = append(fields, sweepresult.FieldCheckInTime)
	}
	if m.FieldCleared(sweepresult.FieldCheckInImage) {
		fields = append(fields, sweepresult.FieldCheckInImage)
	}
	if m.FieldCleared(sweepresult.FieldSweepJobs) {
		fields = append(fields, sweepresult.FieldSweepJobs)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SweepResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SweepResultMutation) ClearField(name string) error {
	switch name {
	case sweepresult.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case sweepresult.FieldCheckInTime:
		m.ClearCheckInTime()
		return nil
	case sweepresult.FieldCheckInImage:
		m.ClearCheckInImage()
		return nil
	case sweepresult.FieldSweepJobs:
		m.ClearSweepJobs()
		return nil
	}
	return fmt.Errorf("unknown SweepResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SweepResultMutation) ResetField(name string) error {
	switch name {
	case sweepresult.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sweepresult.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case sweepresult.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case sweepresult.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case sweepresult.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sweepresult.FieldSweepID:
		m.ResetSweepID()
		return nil
	case sweepresult.FieldSweepScheduleID:
		m.ResetSweepScheduleID()
		return nil
	case sweepresult.FieldCheckInTime:
		m.ResetCheckInTime()
		return nil
	case sweepresult.FieldCheckInImage:
		m.ResetCheckInImage()
		return nil
	case sweepresult.FieldSweepJobs:
		m.ResetSweepJobs()
		return nil
	}
	return fmt.Errorf("unknown SweepResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SweepResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, sweepresult.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, sweepresult.EdgeUpdater)
	}
	if m.sweep != nil {
		edges = append(edges, sweepresult.EdgeSweep)
	}
	if m.sweep_schedule != nil {
		edges = append(edges, sweepresult.EdgeSweepSchedule)
	}
	if m.sweep_result_details != nil {
		edges = append(edges, sweepresult.EdgeSweepResultDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SweepResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sweepresult.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case sweepresult.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case sweepresult.EdgeSweep:
		if id := m.sweep; id != nil {
			return []ent.Value{*id}
		}
	case sweepresult.EdgeSweepSchedule:
		if id := m.sweep_schedule; id != nil {
			return []ent.Value{*id}
		}
	case sweepresult.EdgeSweepResultDetails:
		ids := make([]ent.Value, 0, len(m.sweep_result_details))
		for id := range m.sweep_result_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SweepResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedsweep_result_details != nil {
		edges = append(edges, sweepresult.EdgeSweepResultDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SweepResultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sweepresult.EdgeSweepResultDetails:
		ids := make([]ent.Value, 0, len(m.removedsweep_result_details))
		for id := range m.removedsweep_result_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SweepResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, sweepresult.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, sweepresult.EdgeUpdater)
	}
	if m.clearedsweep {
		edges = append(edges, sweepresult.EdgeSweep)
	}
	if m.clearedsweep_schedule {
		edges = append(edges, sweepresult.EdgeSweepSchedule)
	}
	if m.clearedsweep_result_details {
		edges = append(edges, sweepresult.EdgeSweepResultDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SweepResultMutation) EdgeCleared(name string) bool {
	switch name {
	case sweepresult.EdgeCreator:
		return m.clearedcreator
	case sweepresult.EdgeUpdater:
		return m.clearedupdater
	case sweepresult.EdgeSweep:
		return m.clearedsweep
	case sweepresult.EdgeSweepSchedule:
		return m.clearedsweep_schedule
	case sweepresult.EdgeSweepResultDetails:
		return m.clearedsweep_result_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SweepResultMutation) ClearEdge(name string) error {
	switch name {
	case sweepresult.EdgeCreator:
		m.ClearCreator()
		return nil
	case sweepresult.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case sweepresult.EdgeSweep:
		m.ClearSweep()
		return nil
	case sweepresult.EdgeSweepSchedule:
		m.ClearSweepSchedule()
		return nil
	}
	return fmt.Errorf("unknown SweepResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SweepResultMutation) ResetEdge(name string) error {
	switch name {
	case sweepresult.EdgeCreator:
		m.ResetCreator()
		return nil
	case sweepresult.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case sweepresult.EdgeSweep:
		m.ResetSweep()
		return nil
	case sweepresult.EdgeSweepSchedule:
		m.ResetSweepSchedule()
		return nil
	case sweepresult.EdgeSweepResultDetails:
		m.ResetSweepResultDetails()
		return nil
	}
	return fmt.Errorf("unknown SweepResult edge %s", name)
}

// SweepResultDetailsMutation represents an operation that mutates the SweepResultDetails nodes in the graph.
type SweepResultDetailsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	create_time           *time.Time
	delete_time           *time.Time
	update_time           *time.Time
	title                 *string
	result                *int
	addresult             *int
	clearedFields         map[string]struct{}
	creator               *int
	clearedcreator        bool
	updater               *int
	clearedupdater        bool
	sweep                 *int
	clearedsweep          bool
	sweep_schedule        *int
	clearedsweep_schedule bool
	sweep_result          *int
	clearedsweep_result   bool
	done                  bool
	oldValue              func(context.Context) (*SweepResultDetails, error)
	predicates            []predicate.SweepResultDetails
}

var _ ent.Mutation = (*SweepResultDetailsMutation)(nil)

// sweepresultdetailsOption allows management of the mutation configuration using functional options.
type sweepresultdetailsOption func(*SweepResultDetailsMutation)

// newSweepResultDetailsMutation creates new mutation for the SweepResultDetails entity.
func newSweepResultDetailsMutation(c config, op Op, opts ...sweepresultdetailsOption) *SweepResultDetailsMutation {
	m := &SweepResultDetailsMutation{
		config:        c,
		op:            op,
		typ:           TypeSweepResultDetails,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSweepResultDetailsID sets the ID field of the mutation.
func withSweepResultDetailsID(id int) sweepresultdetailsOption {
	return func(m *SweepResultDetailsMutation) {
		var (
			err   error
			once  sync.Once
			value *SweepResultDetails
		)
		m.oldValue = func(ctx context.Context) (*SweepResultDetails, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SweepResultDetails.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSweepResultDetails sets the old SweepResultDetails of the mutation.
func withSweepResultDetails(node *SweepResultDetails) sweepresultdetailsOption {
	return func(m *SweepResultDetailsMutation) {
		m.oldValue = func(context.Context) (*SweepResultDetails, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SweepResultDetailsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SweepResultDetailsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SweepResultDetailsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SweepResultDetailsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SweepResultDetails.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SweepResultDetailsMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SweepResultDetailsMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SweepResultDetailsMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *SweepResultDetailsMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *SweepResultDetailsMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *SweepResultDetailsMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SweepResultDetailsMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SweepResultDetailsMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SweepResultDetailsMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[sweepresultdetails.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SweepResultDetailsMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[sweepresultdetails.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SweepResultDetailsMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, sweepresultdetails.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *SweepResultDetailsMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *SweepResultDetailsMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *SweepResultDetailsMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SweepResultDetailsMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SweepResultDetailsMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SweepResultDetailsMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSweepID sets the "sweep_id" field.
func (m *SweepResultDetailsMutation) SetSweepID(i int) {
	m.sweep = &i
}

// SweepID returns the value of the "sweep_id" field in the mutation.
func (m *SweepResultDetailsMutation) SweepID() (r int, exists bool) {
	v := m.sweep
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepID returns the old "sweep_id" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldSweepID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepID: %w", err)
	}
	return oldValue.SweepID, nil
}

// ResetSweepID resets all changes to the "sweep_id" field.
func (m *SweepResultDetailsMutation) ResetSweepID() {
	m.sweep = nil
}

// SetSweepScheduleID sets the "sweep_schedule_id" field.
func (m *SweepResultDetailsMutation) SetSweepScheduleID(i int) {
	m.sweep_schedule = &i
}

// SweepScheduleID returns the value of the "sweep_schedule_id" field in the mutation.
func (m *SweepResultDetailsMutation) SweepScheduleID() (r int, exists bool) {
	v := m.sweep_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepScheduleID returns the old "sweep_schedule_id" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldSweepScheduleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepScheduleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepScheduleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepScheduleID: %w", err)
	}
	return oldValue.SweepScheduleID, nil
}

// ResetSweepScheduleID resets all changes to the "sweep_schedule_id" field.
func (m *SweepResultDetailsMutation) ResetSweepScheduleID() {
	m.sweep_schedule = nil
}

// SetSweepResultID sets the "sweep_result_id" field.
func (m *SweepResultDetailsMutation) SetSweepResultID(i int) {
	m.sweep_result = &i
}

// SweepResultID returns the value of the "sweep_result_id" field in the mutation.
func (m *SweepResultDetailsMutation) SweepResultID() (r int, exists bool) {
	v := m.sweep_result
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepResultID returns the old "sweep_result_id" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldSweepResultID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepResultID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepResultID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepResultID: %w", err)
	}
	return oldValue.SweepResultID, nil
}

// ResetSweepResultID resets all changes to the "sweep_result_id" field.
func (m *SweepResultDetailsMutation) ResetSweepResultID() {
	m.sweep_result = nil
}

// SetTitle sets the "title" field.
func (m *SweepResultDetailsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SweepResultDetailsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SweepResultDetailsMutation) ResetTitle() {
	m.title = nil
}

// SetResult sets the "result" field.
func (m *SweepResultDetailsMutation) SetResult(i int) {
	m.result = &i
	m.addresult = nil
}

// Result returns the value of the "result" field in the mutation.
func (m *SweepResultDetailsMutation) Result() (r int, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the SweepResultDetails entity.
// If the SweepResultDetails object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepResultDetailsMutation) OldResult(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// AddResult adds i to the "result" field.
func (m *SweepResultDetailsMutation) AddResult(i int) {
	if m.addresult != nil {
		*m.addresult += i
	} else {
		m.addresult = &i
	}
}

// AddedResult returns the value that was added to the "result" field in this mutation.
func (m *SweepResultDetailsMutation) AddedResult() (r int, exists bool) {
	v := m.addresult
	if v == nil {
		return
	}
	return *v, true
}

// ResetResult resets all changes to the "result" field.
func (m *SweepResultDetailsMutation) ResetResult() {
	m.result = nil
	m.addresult = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *SweepResultDetailsMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[sweepresultdetails.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *SweepResultDetailsMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *SweepResultDetailsMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *SweepResultDetailsMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *SweepResultDetailsMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[sweepresultdetails.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *SweepResultDetailsMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *SweepResultDetailsMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *SweepResultDetailsMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearSweep clears the "sweep" edge to the Sweep entity.
func (m *SweepResultDetailsMutation) ClearSweep() {
	m.clearedsweep = true
	m.clearedFields[sweepresultdetails.FieldSweepID] = struct{}{}
}

// SweepCleared reports if the "sweep" edge to the Sweep entity was cleared.
func (m *SweepResultDetailsMutation) SweepCleared() bool {
	return m.clearedsweep
}

// SweepIDs returns the "sweep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SweepID instead. It exists only for internal usage by the builders.
func (m *SweepResultDetailsMutation) SweepIDs() (ids []int) {
	if id := m.sweep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSweep resets all changes to the "sweep" edge.
func (m *SweepResultDetailsMutation) ResetSweep() {
	m.sweep = nil
	m.clearedsweep = false
}

// ClearSweepSchedule clears the "sweep_schedule" edge to the SweepSchedule entity.
func (m *SweepResultDetailsMutation) ClearSweepSchedule() {
	m.clearedsweep_schedule = true
	m.clearedFields[sweepresultdetails.FieldSweepScheduleID] = struct{}{}
}

// SweepScheduleCleared reports if the "sweep_schedule" edge to the SweepSchedule entity was cleared.
func (m *SweepResultDetailsMutation) SweepScheduleCleared() bool {
	return m.clearedsweep_schedule
}

// SweepScheduleIDs returns the "sweep_schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SweepScheduleID instead. It exists only for internal usage by the builders.
func (m *SweepResultDetailsMutation) SweepScheduleIDs() (ids []int) {
	if id := m.sweep_schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSweepSchedule resets all changes to the "sweep_schedule" edge.
func (m *SweepResultDetailsMutation) ResetSweepSchedule() {
	m.sweep_schedule = nil
	m.clearedsweep_schedule = false
}

// ClearSweepResult clears the "sweep_result" edge to the SweepResult entity.
func (m *SweepResultDetailsMutation) ClearSweepResult() {
	m.clearedsweep_result = true
	m.clearedFields[sweepresultdetails.FieldSweepResultID] = struct{}{}
}

// SweepResultCleared reports if the "sweep_result" edge to the SweepResult entity was cleared.
func (m *SweepResultDetailsMutation) SweepResultCleared() bool {
	return m.clearedsweep_result
}

// SweepResultIDs returns the "sweep_result" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SweepResultID instead. It exists only for internal usage by the builders.
func (m *SweepResultDetailsMutation) SweepResultIDs() (ids []int) {
	if id := m.sweep_result; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSweepResult resets all changes to the "sweep_result" edge.
func (m *SweepResultDetailsMutation) ResetSweepResult() {
	m.sweep_result = nil
	m.clearedsweep_result = false
}

// Where appends a list predicates to the SweepResultDetailsMutation builder.
func (m *SweepResultDetailsMutation) Where(ps ...predicate.SweepResultDetails) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SweepResultDetailsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SweepResultDetailsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SweepResultDetails, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SweepResultDetailsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SweepResultDetailsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SweepResultDetails).
func (m *SweepResultDetailsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SweepResultDetailsMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, sweepresultdetails.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, sweepresultdetails.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, sweepresultdetails.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, sweepresultdetails.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, sweepresultdetails.FieldUpdateTime)
	}
	if m.sweep != nil {
		fields = append(fields, sweepresultdetails.FieldSweepID)
	}
	if m.sweep_schedule != nil {
		fields = append(fields, sweepresultdetails.FieldSweepScheduleID)
	}
	if m.sweep_result != nil {
		fields = append(fields, sweepresultdetails.FieldSweepResultID)
	}
	if m.title != nil {
		fields = append(fields, sweepresultdetails.FieldTitle)
	}
	if m.result != nil {
		fields = append(fields, sweepresultdetails.FieldResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SweepResultDetailsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sweepresultdetails.FieldCreateTime:
		return m.CreateTime()
	case sweepresultdetails.FieldCreatorID:
		return m.CreatorID()
	case sweepresultdetails.FieldDeleteTime:
		return m.DeleteTime()
	case sweepresultdetails.FieldUpdaterID:
		return m.UpdaterID()
	case sweepresultdetails.FieldUpdateTime:
		return m.UpdateTime()
	case sweepresultdetails.FieldSweepID:
		return m.SweepID()
	case sweepresultdetails.FieldSweepScheduleID:
		return m.SweepScheduleID()
	case sweepresultdetails.FieldSweepResultID:
		return m.SweepResultID()
	case sweepresultdetails.FieldTitle:
		return m.Title()
	case sweepresultdetails.FieldResult:
		return m.Result()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SweepResultDetailsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sweepresultdetails.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sweepresultdetails.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case sweepresultdetails.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case sweepresultdetails.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case sweepresultdetails.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sweepresultdetails.FieldSweepID:
		return m.OldSweepID(ctx)
	case sweepresultdetails.FieldSweepScheduleID:
		return m.OldSweepScheduleID(ctx)
	case sweepresultdetails.FieldSweepResultID:
		return m.OldSweepResultID(ctx)
	case sweepresultdetails.FieldTitle:
		return m.OldTitle(ctx)
	case sweepresultdetails.FieldResult:
		return m.OldResult(ctx)
	}
	return nil, fmt.Errorf("unknown SweepResultDetails field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepResultDetailsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sweepresultdetails.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sweepresultdetails.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case sweepresultdetails.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case sweepresultdetails.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case sweepresultdetails.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sweepresultdetails.FieldSweepID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepID(v)
		return nil
	case sweepresultdetails.FieldSweepScheduleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepScheduleID(v)
		return nil
	case sweepresultdetails.FieldSweepResultID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepResultID(v)
		return nil
	case sweepresultdetails.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case sweepresultdetails.FieldResult:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	}
	return fmt.Errorf("unknown SweepResultDetails field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SweepResultDetailsMutation) AddedFields() []string {
	var fields []string
	if m.addresult != nil {
		fields = append(fields, sweepresultdetails.FieldResult)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SweepResultDetailsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sweepresultdetails.FieldResult:
		return m.AddedResult()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepResultDetailsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sweepresultdetails.FieldResult:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResult(v)
		return nil
	}
	return fmt.Errorf("unknown SweepResultDetails numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SweepResultDetailsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sweepresultdetails.FieldDeleteTime) {
		fields = append(fields, sweepresultdetails.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SweepResultDetailsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SweepResultDetailsMutation) ClearField(name string) error {
	switch name {
	case sweepresultdetails.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown SweepResultDetails nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SweepResultDetailsMutation) ResetField(name string) error {
	switch name {
	case sweepresultdetails.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sweepresultdetails.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case sweepresultdetails.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case sweepresultdetails.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case sweepresultdetails.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sweepresultdetails.FieldSweepID:
		m.ResetSweepID()
		return nil
	case sweepresultdetails.FieldSweepScheduleID:
		m.ResetSweepScheduleID()
		return nil
	case sweepresultdetails.FieldSweepResultID:
		m.ResetSweepResultID()
		return nil
	case sweepresultdetails.FieldTitle:
		m.ResetTitle()
		return nil
	case sweepresultdetails.FieldResult:
		m.ResetResult()
		return nil
	}
	return fmt.Errorf("unknown SweepResultDetails field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SweepResultDetailsMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, sweepresultdetails.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, sweepresultdetails.EdgeUpdater)
	}
	if m.sweep != nil {
		edges = append(edges, sweepresultdetails.EdgeSweep)
	}
	if m.sweep_schedule != nil {
		edges = append(edges, sweepresultdetails.EdgeSweepSchedule)
	}
	if m.sweep_result != nil {
		edges = append(edges, sweepresultdetails.EdgeSweepResult)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SweepResultDetailsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sweepresultdetails.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case sweepresultdetails.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case sweepresultdetails.EdgeSweep:
		if id := m.sweep; id != nil {
			return []ent.Value{*id}
		}
	case sweepresultdetails.EdgeSweepSchedule:
		if id := m.sweep_schedule; id != nil {
			return []ent.Value{*id}
		}
	case sweepresultdetails.EdgeSweepResult:
		if id := m.sweep_result; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SweepResultDetailsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SweepResultDetailsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SweepResultDetailsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, sweepresultdetails.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, sweepresultdetails.EdgeUpdater)
	}
	if m.clearedsweep {
		edges = append(edges, sweepresultdetails.EdgeSweep)
	}
	if m.clearedsweep_schedule {
		edges = append(edges, sweepresultdetails.EdgeSweepSchedule)
	}
	if m.clearedsweep_result {
		edges = append(edges, sweepresultdetails.EdgeSweepResult)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SweepResultDetailsMutation) EdgeCleared(name string) bool {
	switch name {
	case sweepresultdetails.EdgeCreator:
		return m.clearedcreator
	case sweepresultdetails.EdgeUpdater:
		return m.clearedupdater
	case sweepresultdetails.EdgeSweep:
		return m.clearedsweep
	case sweepresultdetails.EdgeSweepSchedule:
		return m.clearedsweep_schedule
	case sweepresultdetails.EdgeSweepResult:
		return m.clearedsweep_result
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SweepResultDetailsMutation) ClearEdge(name string) error {
	switch name {
	case sweepresultdetails.EdgeCreator:
		m.ClearCreator()
		return nil
	case sweepresultdetails.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case sweepresultdetails.EdgeSweep:
		m.ClearSweep()
		return nil
	case sweepresultdetails.EdgeSweepSchedule:
		m.ClearSweepSchedule()
		return nil
	case sweepresultdetails.EdgeSweepResult:
		m.ClearSweepResult()
		return nil
	}
	return fmt.Errorf("unknown SweepResultDetails unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SweepResultDetailsMutation) ResetEdge(name string) error {
	switch name {
	case sweepresultdetails.EdgeCreator:
		m.ResetCreator()
		return nil
	case sweepresultdetails.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case sweepresultdetails.EdgeSweep:
		m.ResetSweep()
		return nil
	case sweepresultdetails.EdgeSweepSchedule:
		m.ResetSweepSchedule()
		return nil
	case sweepresultdetails.EdgeSweepResult:
		m.ResetSweepResult()
		return nil
	}
	return fmt.Errorf("unknown SweepResultDetails edge %s", name)
}

// SweepScheduleMutation represents an operation that mutates the SweepSchedule nodes in the graph.
type SweepScheduleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	delete_time                 *time.Time
	update_time                 *time.Time
	name                        *string
	schedule_status             *enums.AdminStatus
	addschedule_status          *enums.AdminStatus
	action_time                 *time.Time
	remind                      *types.ScheduleRemind
	repeat                      *types.ScheduleRepeat
	clearedFields               map[string]struct{}
	creator                     *int
	clearedcreator              bool
	updater                     *int
	clearedupdater              bool
	sweep                       *int
	clearedsweep                bool
	workers                     map[int]struct{}
	removedworkers              map[int]struct{}
	clearedworkers              bool
	sweep_result                map[int]struct{}
	removedsweep_result         map[int]struct{}
	clearedsweep_result         bool
	sweep_result_details        map[int]struct{}
	removedsweep_result_details map[int]struct{}
	clearedsweep_result_details bool
	done                        bool
	oldValue                    func(context.Context) (*SweepSchedule, error)
	predicates                  []predicate.SweepSchedule
}

var _ ent.Mutation = (*SweepScheduleMutation)(nil)

// sweepscheduleOption allows management of the mutation configuration using functional options.
type sweepscheduleOption func(*SweepScheduleMutation)

// newSweepScheduleMutation creates new mutation for the SweepSchedule entity.
func newSweepScheduleMutation(c config, op Op, opts ...sweepscheduleOption) *SweepScheduleMutation {
	m := &SweepScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSweepSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSweepScheduleID sets the ID field of the mutation.
func withSweepScheduleID(id int) sweepscheduleOption {
	return func(m *SweepScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *SweepSchedule
		)
		m.oldValue = func(ctx context.Context) (*SweepSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SweepSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSweepSchedule sets the old SweepSchedule of the mutation.
func withSweepSchedule(node *SweepSchedule) sweepscheduleOption {
	return func(m *SweepScheduleMutation) {
		m.oldValue = func(context.Context) (*SweepSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SweepScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SweepScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SweepScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SweepScheduleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SweepSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SweepScheduleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SweepScheduleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SweepScheduleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *SweepScheduleMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *SweepScheduleMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *SweepScheduleMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SweepScheduleMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SweepScheduleMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SweepScheduleMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[sweepschedule.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SweepScheduleMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[sweepschedule.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SweepScheduleMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, sweepschedule.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *SweepScheduleMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *SweepScheduleMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *SweepScheduleMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SweepScheduleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SweepScheduleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SweepScheduleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *SweepScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SweepScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SweepScheduleMutation) ResetName() {
	m.name = nil
}

// SetSweepID sets the "sweep_id" field.
func (m *SweepScheduleMutation) SetSweepID(i int) {
	m.sweep = &i
}

// SweepID returns the value of the "sweep_id" field in the mutation.
func (m *SweepScheduleMutation) SweepID() (r int, exists bool) {
	v := m.sweep
	if v == nil {
		return
	}
	return *v, true
}

// OldSweepID returns the old "sweep_id" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldSweepID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSweepID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSweepID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSweepID: %w", err)
	}
	return oldValue.SweepID, nil
}

// ResetSweepID resets all changes to the "sweep_id" field.
func (m *SweepScheduleMutation) ResetSweepID() {
	m.sweep = nil
}

// SetScheduleStatus sets the "schedule_status" field.
func (m *SweepScheduleMutation) SetScheduleStatus(es enums.AdminStatus) {
	m.schedule_status = &es
	m.addschedule_status = nil
}

// ScheduleStatus returns the value of the "schedule_status" field in the mutation.
func (m *SweepScheduleMutation) ScheduleStatus() (r enums.AdminStatus, exists bool) {
	v := m.schedule_status
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleStatus returns the old "schedule_status" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldScheduleStatus(ctx context.Context) (v enums.AdminStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleStatus: %w", err)
	}
	return oldValue.ScheduleStatus, nil
}

// AddScheduleStatus adds es to the "schedule_status" field.
func (m *SweepScheduleMutation) AddScheduleStatus(es enums.AdminStatus) {
	if m.addschedule_status != nil {
		*m.addschedule_status += es
	} else {
		m.addschedule_status = &es
	}
}

// AddedScheduleStatus returns the value that was added to the "schedule_status" field in this mutation.
func (m *SweepScheduleMutation) AddedScheduleStatus() (r enums.AdminStatus, exists bool) {
	v := m.addschedule_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearScheduleStatus clears the value of the "schedule_status" field.
func (m *SweepScheduleMutation) ClearScheduleStatus() {
	m.schedule_status = nil
	m.addschedule_status = nil
	m.clearedFields[sweepschedule.FieldScheduleStatus] = struct{}{}
}

// ScheduleStatusCleared returns if the "schedule_status" field was cleared in this mutation.
func (m *SweepScheduleMutation) ScheduleStatusCleared() bool {
	_, ok := m.clearedFields[sweepschedule.FieldScheduleStatus]
	return ok
}

// ResetScheduleStatus resets all changes to the "schedule_status" field.
func (m *SweepScheduleMutation) ResetScheduleStatus() {
	m.schedule_status = nil
	m.addschedule_status = nil
	delete(m.clearedFields, sweepschedule.FieldScheduleStatus)
}

// SetActionTime sets the "action_time" field.
func (m *SweepScheduleMutation) SetActionTime(t time.Time) {
	m.action_time = &t
}

// ActionTime returns the value of the "action_time" field in the mutation.
func (m *SweepScheduleMutation) ActionTime() (r time.Time, exists bool) {
	v := m.action_time
	if v == nil {
		return
	}
	return *v, true
}

// OldActionTime returns the old "action_time" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldActionTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionTime: %w", err)
	}
	return oldValue.ActionTime, nil
}

// ResetActionTime resets all changes to the "action_time" field.
func (m *SweepScheduleMutation) ResetActionTime() {
	m.action_time = nil
}

// SetRemind sets the "remind" field.
func (m *SweepScheduleMutation) SetRemind(tr types.ScheduleRemind) {
	m.remind = &tr
}

// Remind returns the value of the "remind" field in the mutation.
func (m *SweepScheduleMutation) Remind() (r types.ScheduleRemind, exists bool) {
	v := m.remind
	if v == nil {
		return
	}
	return *v, true
}

// OldRemind returns the old "remind" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldRemind(ctx context.Context) (v types.ScheduleRemind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemind: %w", err)
	}
	return oldValue.Remind, nil
}

// ResetRemind resets all changes to the "remind" field.
func (m *SweepScheduleMutation) ResetRemind() {
	m.remind = nil
}

// SetRepeat sets the "repeat" field.
func (m *SweepScheduleMutation) SetRepeat(tr types.ScheduleRepeat) {
	m.repeat = &tr
}

// Repeat returns the value of the "repeat" field in the mutation.
func (m *SweepScheduleMutation) Repeat() (r types.ScheduleRepeat, exists bool) {
	v := m.repeat
	if v == nil {
		return
	}
	return *v, true
}

// OldRepeat returns the old "repeat" field's value of the SweepSchedule entity.
// If the SweepSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SweepScheduleMutation) OldRepeat(ctx context.Context) (v types.ScheduleRepeat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepeat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepeat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepeat: %w", err)
	}
	return oldValue.Repeat, nil
}

// ResetRepeat resets all changes to the "repeat" field.
func (m *SweepScheduleMutation) ResetRepeat() {
	m.repeat = nil
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *SweepScheduleMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[sweepschedule.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *SweepScheduleMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *SweepScheduleMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *SweepScheduleMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *SweepScheduleMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[sweepschedule.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *SweepScheduleMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *SweepScheduleMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *SweepScheduleMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearSweep clears the "sweep" edge to the Sweep entity.
func (m *SweepScheduleMutation) ClearSweep() {
	m.clearedsweep = true
	m.clearedFields[sweepschedule.FieldSweepID] = struct{}{}
}

// SweepCleared reports if the "sweep" edge to the Sweep entity was cleared.
func (m *SweepScheduleMutation) SweepCleared() bool {
	return m.clearedsweep
}

// SweepIDs returns the "sweep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SweepID instead. It exists only for internal usage by the builders.
func (m *SweepScheduleMutation) SweepIDs() (ids []int) {
	if id := m.sweep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSweep resets all changes to the "sweep" edge.
func (m *SweepScheduleMutation) ResetSweep() {
	m.sweep = nil
	m.clearedsweep = false
}

// AddWorkerIDs adds the "workers" edge to the Admin entity by ids.
func (m *SweepScheduleMutation) AddWorkerIDs(ids ...int) {
	if m.workers == nil {
		m.workers = make(map[int]struct{})
	}
	for i := range ids {
		m.workers[ids[i]] = struct{}{}
	}
}

// ClearWorkers clears the "workers" edge to the Admin entity.
func (m *SweepScheduleMutation) ClearWorkers() {
	m.clearedworkers = true
}

// WorkersCleared reports if the "workers" edge to the Admin entity was cleared.
func (m *SweepScheduleMutation) WorkersCleared() bool {
	return m.clearedworkers
}

// RemoveWorkerIDs removes the "workers" edge to the Admin entity by IDs.
func (m *SweepScheduleMutation) RemoveWorkerIDs(ids ...int) {
	if m.removedworkers == nil {
		m.removedworkers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.workers, ids[i])
		m.removedworkers[ids[i]] = struct{}{}
	}
}

// RemovedWorkers returns the removed IDs of the "workers" edge to the Admin entity.
func (m *SweepScheduleMutation) RemovedWorkersIDs() (ids []int) {
	for id := range m.removedworkers {
		ids = append(ids, id)
	}
	return
}

// WorkersIDs returns the "workers" edge IDs in the mutation.
func (m *SweepScheduleMutation) WorkersIDs() (ids []int) {
	for id := range m.workers {
		ids = append(ids, id)
	}
	return
}

// ResetWorkers resets all changes to the "workers" edge.
func (m *SweepScheduleMutation) ResetWorkers() {
	m.workers = nil
	m.clearedworkers = false
	m.removedworkers = nil
}

// AddSweepResultIDs adds the "sweep_result" edge to the SweepResult entity by ids.
func (m *SweepScheduleMutation) AddSweepResultIDs(ids ...int) {
	if m.sweep_result == nil {
		m.sweep_result = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result[ids[i]] = struct{}{}
	}
}

// ClearSweepResult clears the "sweep_result" edge to the SweepResult entity.
func (m *SweepScheduleMutation) ClearSweepResult() {
	m.clearedsweep_result = true
}

// SweepResultCleared reports if the "sweep_result" edge to the SweepResult entity was cleared.
func (m *SweepScheduleMutation) SweepResultCleared() bool {
	return m.clearedsweep_result
}

// RemoveSweepResultIDs removes the "sweep_result" edge to the SweepResult entity by IDs.
func (m *SweepScheduleMutation) RemoveSweepResultIDs(ids ...int) {
	if m.removedsweep_result == nil {
		m.removedsweep_result = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result, ids[i])
		m.removedsweep_result[ids[i]] = struct{}{}
	}
}

// RemovedSweepResult returns the removed IDs of the "sweep_result" edge to the SweepResult entity.
func (m *SweepScheduleMutation) RemovedSweepResultIDs() (ids []int) {
	for id := range m.removedsweep_result {
		ids = append(ids, id)
	}
	return
}

// SweepResultIDs returns the "sweep_result" edge IDs in the mutation.
func (m *SweepScheduleMutation) SweepResultIDs() (ids []int) {
	for id := range m.sweep_result {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResult resets all changes to the "sweep_result" edge.
func (m *SweepScheduleMutation) ResetSweepResult() {
	m.sweep_result = nil
	m.clearedsweep_result = false
	m.removedsweep_result = nil
}

// AddSweepResultDetailIDs adds the "sweep_result_details" edge to the SweepResultDetails entity by ids.
func (m *SweepScheduleMutation) AddSweepResultDetailIDs(ids ...int) {
	if m.sweep_result_details == nil {
		m.sweep_result_details = make(map[int]struct{})
	}
	for i := range ids {
		m.sweep_result_details[ids[i]] = struct{}{}
	}
}

// ClearSweepResultDetails clears the "sweep_result_details" edge to the SweepResultDetails entity.
func (m *SweepScheduleMutation) ClearSweepResultDetails() {
	m.clearedsweep_result_details = true
}

// SweepResultDetailsCleared reports if the "sweep_result_details" edge to the SweepResultDetails entity was cleared.
func (m *SweepScheduleMutation) SweepResultDetailsCleared() bool {
	return m.clearedsweep_result_details
}

// RemoveSweepResultDetailIDs removes the "sweep_result_details" edge to the SweepResultDetails entity by IDs.
func (m *SweepScheduleMutation) RemoveSweepResultDetailIDs(ids ...int) {
	if m.removedsweep_result_details == nil {
		m.removedsweep_result_details = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sweep_result_details, ids[i])
		m.removedsweep_result_details[ids[i]] = struct{}{}
	}
}

// RemovedSweepResultDetails returns the removed IDs of the "sweep_result_details" edge to the SweepResultDetails entity.
func (m *SweepScheduleMutation) RemovedSweepResultDetailsIDs() (ids []int) {
	for id := range m.removedsweep_result_details {
		ids = append(ids, id)
	}
	return
}

// SweepResultDetailsIDs returns the "sweep_result_details" edge IDs in the mutation.
func (m *SweepScheduleMutation) SweepResultDetailsIDs() (ids []int) {
	for id := range m.sweep_result_details {
		ids = append(ids, id)
	}
	return
}

// ResetSweepResultDetails resets all changes to the "sweep_result_details" edge.
func (m *SweepScheduleMutation) ResetSweepResultDetails() {
	m.sweep_result_details = nil
	m.clearedsweep_result_details = false
	m.removedsweep_result_details = nil
}

// Where appends a list predicates to the SweepScheduleMutation builder.
func (m *SweepScheduleMutation) Where(ps ...predicate.SweepSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SweepScheduleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SweepScheduleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SweepSchedule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SweepScheduleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SweepScheduleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SweepSchedule).
func (m *SweepScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SweepScheduleMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, sweepschedule.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, sweepschedule.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, sweepschedule.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, sweepschedule.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, sweepschedule.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, sweepschedule.FieldName)
	}
	if m.sweep != nil {
		fields = append(fields, sweepschedule.FieldSweepID)
	}
	if m.schedule_status != nil {
		fields = append(fields, sweepschedule.FieldScheduleStatus)
	}
	if m.action_time != nil {
		fields = append(fields, sweepschedule.FieldActionTime)
	}
	if m.remind != nil {
		fields = append(fields, sweepschedule.FieldRemind)
	}
	if m.repeat != nil {
		fields = append(fields, sweepschedule.FieldRepeat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SweepScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sweepschedule.FieldCreateTime:
		return m.CreateTime()
	case sweepschedule.FieldCreatorID:
		return m.CreatorID()
	case sweepschedule.FieldDeleteTime:
		return m.DeleteTime()
	case sweepschedule.FieldUpdaterID:
		return m.UpdaterID()
	case sweepschedule.FieldUpdateTime:
		return m.UpdateTime()
	case sweepschedule.FieldName:
		return m.Name()
	case sweepschedule.FieldSweepID:
		return m.SweepID()
	case sweepschedule.FieldScheduleStatus:
		return m.ScheduleStatus()
	case sweepschedule.FieldActionTime:
		return m.ActionTime()
	case sweepschedule.FieldRemind:
		return m.Remind()
	case sweepschedule.FieldRepeat:
		return m.Repeat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SweepScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sweepschedule.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sweepschedule.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case sweepschedule.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case sweepschedule.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case sweepschedule.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sweepschedule.FieldName:
		return m.OldName(ctx)
	case sweepschedule.FieldSweepID:
		return m.OldSweepID(ctx)
	case sweepschedule.FieldScheduleStatus:
		return m.OldScheduleStatus(ctx)
	case sweepschedule.FieldActionTime:
		return m.OldActionTime(ctx)
	case sweepschedule.FieldRemind:
		return m.OldRemind(ctx)
	case sweepschedule.FieldRepeat:
		return m.OldRepeat(ctx)
	}
	return nil, fmt.Errorf("unknown SweepSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sweepschedule.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sweepschedule.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case sweepschedule.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case sweepschedule.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case sweepschedule.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sweepschedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sweepschedule.FieldSweepID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSweepID(v)
		return nil
	case sweepschedule.FieldScheduleStatus:
		v, ok := value.(enums.AdminStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleStatus(v)
		return nil
	case sweepschedule.FieldActionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionTime(v)
		return nil
	case sweepschedule.FieldRemind:
		v, ok := value.(types.ScheduleRemind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemind(v)
		return nil
	case sweepschedule.FieldRepeat:
		v, ok := value.(types.ScheduleRepeat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepeat(v)
		return nil
	}
	return fmt.Errorf("unknown SweepSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SweepScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addschedule_status != nil {
		fields = append(fields, sweepschedule.FieldScheduleStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SweepScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sweepschedule.FieldScheduleStatus:
		return m.AddedScheduleStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SweepScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sweepschedule.FieldScheduleStatus:
		v, ok := value.(enums.AdminStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScheduleStatus(v)
		return nil
	}
	return fmt.Errorf("unknown SweepSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SweepScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sweepschedule.FieldDeleteTime) {
		fields = append(fields, sweepschedule.FieldDeleteTime)
	}
	if m.FieldCleared(sweepschedule.FieldScheduleStatus) {
		fields = append(fields, sweepschedule.FieldScheduleStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SweepScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SweepScheduleMutation) ClearField(name string) error {
	switch name {
	case sweepschedule.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case sweepschedule.FieldScheduleStatus:
		m.ClearScheduleStatus()
		return nil
	}
	return fmt.Errorf("unknown SweepSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SweepScheduleMutation) ResetField(name string) error {
	switch name {
	case sweepschedule.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sweepschedule.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case sweepschedule.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case sweepschedule.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case sweepschedule.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sweepschedule.FieldName:
		m.ResetName()
		return nil
	case sweepschedule.FieldSweepID:
		m.ResetSweepID()
		return nil
	case sweepschedule.FieldScheduleStatus:
		m.ResetScheduleStatus()
		return nil
	case sweepschedule.FieldActionTime:
		m.ResetActionTime()
		return nil
	case sweepschedule.FieldRemind:
		m.ResetRemind()
		return nil
	case sweepschedule.FieldRepeat:
		m.ResetRepeat()
		return nil
	}
	return fmt.Errorf("unknown SweepSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SweepScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.creator != nil {
		edges = append(edges, sweepschedule.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, sweepschedule.EdgeUpdater)
	}
	if m.sweep != nil {
		edges = append(edges, sweepschedule.EdgeSweep)
	}
	if m.workers != nil {
		edges = append(edges, sweepschedule.EdgeWorkers)
	}
	if m.sweep_result != nil {
		edges = append(edges, sweepschedule.EdgeSweepResult)
	}
	if m.sweep_result_details != nil {
		edges = append(edges, sweepschedule.EdgeSweepResultDetails)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SweepScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sweepschedule.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case sweepschedule.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case sweepschedule.EdgeSweep:
		if id := m.sweep; id != nil {
			return []ent.Value{*id}
		}
	case sweepschedule.EdgeWorkers:
		ids := make([]ent.Value, 0, len(m.workers))
		for id := range m.workers {
			ids = append(ids, id)
		}
		return ids
	case sweepschedule.EdgeSweepResult:
		ids := make([]ent.Value, 0, len(m.sweep_result))
		for id := range m.sweep_result {
			ids = append(ids, id)
		}
		return ids
	case sweepschedule.EdgeSweepResultDetails:
		ids := make([]ent.Value, 0, len(m.sweep_result_details))
		for id := range m.sweep_result_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SweepScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedworkers != nil {
		edges = append(edges, sweepschedule.EdgeWorkers)
	}
	if m.removedsweep_result != nil {
		edges = append(edges, sweepschedule.EdgeSweepResult)
	}
	if m.removedsweep_result_details != nil {
		edges = append(edges, sweepschedule.EdgeSweepResultDetails)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SweepScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sweepschedule.EdgeWorkers:
		ids := make([]ent.Value, 0, len(m.removedworkers))
		for id := range m.removedworkers {
			ids = append(ids, id)
		}
		return ids
	case sweepschedule.EdgeSweepResult:
		ids := make([]ent.Value, 0, len(m.removedsweep_result))
		for id := range m.removedsweep_result {
			ids = append(ids, id)
		}
		return ids
	case sweepschedule.EdgeSweepResultDetails:
		ids := make([]ent.Value, 0, len(m.removedsweep_result_details))
		for id := range m.removedsweep_result_details {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SweepScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcreator {
		edges = append(edges, sweepschedule.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, sweepschedule.EdgeUpdater)
	}
	if m.clearedsweep {
		edges = append(edges, sweepschedule.EdgeSweep)
	}
	if m.clearedworkers {
		edges = append(edges, sweepschedule.EdgeWorkers)
	}
	if m.clearedsweep_result {
		edges = append(edges, sweepschedule.EdgeSweepResult)
	}
	if m.clearedsweep_result_details {
		edges = append(edges, sweepschedule.EdgeSweepResultDetails)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SweepScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case sweepschedule.EdgeCreator:
		return m.clearedcreator
	case sweepschedule.EdgeUpdater:
		return m.clearedupdater
	case sweepschedule.EdgeSweep:
		return m.clearedsweep
	case sweepschedule.EdgeWorkers:
		return m.clearedworkers
	case sweepschedule.EdgeSweepResult:
		return m.clearedsweep_result
	case sweepschedule.EdgeSweepResultDetails:
		return m.clearedsweep_result_details
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SweepScheduleMutation) ClearEdge(name string) error {
	switch name {
	case sweepschedule.EdgeCreator:
		m.ClearCreator()
		return nil
	case sweepschedule.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case sweepschedule.EdgeSweep:
		m.ClearSweep()
		return nil
	}
	return fmt.Errorf("unknown SweepSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SweepScheduleMutation) ResetEdge(name string) error {
	switch name {
	case sweepschedule.EdgeCreator:
		m.ResetCreator()
		return nil
	case sweepschedule.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case sweepschedule.EdgeSweep:
		m.ResetSweep()
		return nil
	case sweepschedule.EdgeWorkers:
		m.ResetWorkers()
		return nil
	case sweepschedule.EdgeSweepResult:
		m.ResetSweepResult()
		return nil
	case sweepschedule.EdgeSweepResultDetails:
		m.ResetSweepResultDetails()
		return nil
	}
	return fmt.Errorf("unknown SweepSchedule edge %s", name)
}

// VideoMutation represents an operation that mutates the Video nodes in the graph.
type VideoMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	delete_time    *time.Time
	update_time    *time.Time
	name           *string
	url            *string
	size           *int64
	addsize        *int64
	duration       *string
	uploaded_at    *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	event          map[int]struct{}
	removedevent   map[int]struct{}
	clearedevent   bool
	done           bool
	oldValue       func(context.Context) (*Video, error)
	predicates     []predicate.Video
}

var _ ent.Mutation = (*VideoMutation)(nil)

// videoOption allows management of the mutation configuration using functional options.
type videoOption func(*VideoMutation)

// newVideoMutation creates new mutation for the Video entity.
func newVideoMutation(c config, op Op, opts ...videoOption) *VideoMutation {
	m := &VideoMutation{
		config:        c,
		op:            op,
		typ:           TypeVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoID sets the ID field of the mutation.
func withVideoID(id int) videoOption {
	return func(m *VideoMutation) {
		var (
			err   error
			once  sync.Once
			value *Video
		)
		m.oldValue = func(ctx context.Context) (*Video, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Video.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideo sets the old Video of the mutation.
func withVideo(node *Video) videoOption {
	return func(m *VideoMutation) {
		m.oldValue = func(context.Context) (*Video, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Video.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *VideoMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VideoMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VideoMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *VideoMutation) SetCreatorID(i int) {
	m.creator = &i
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *VideoMutation) CreatorID() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *VideoMutation) ResetCreatorID() {
	m.creator = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *VideoMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *VideoMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDeleteTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *VideoMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[video.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *VideoMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[video.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *VideoMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, video.FieldDeleteTime)
}

// SetUpdaterID sets the "updater_id" field.
func (m *VideoMutation) SetUpdaterID(i int) {
	m.updater = &i
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *VideoMutation) UpdaterID() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdaterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *VideoMutation) ResetUpdaterID() {
	m.updater = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *VideoMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *VideoMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *VideoMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *VideoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VideoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VideoMutation) ClearName() {
	m.name = nil
	m.clearedFields[video.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VideoMutation) NameCleared() bool {
	_, ok := m.clearedFields[video.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VideoMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, video.FieldName)
}

// SetURL sets the "url" field.
func (m *VideoMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *VideoMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *VideoMutation) ClearURL() {
	m.url = nil
	m.clearedFields[video.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *VideoMutation) URLCleared() bool {
	_, ok := m.clearedFields[video.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *VideoMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, video.FieldURL)
}

// SetSize sets the "size" field.
func (m *VideoMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VideoMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VideoMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VideoMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VideoMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDuration sets the "duration" field.
func (m *VideoMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VideoMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *VideoMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[video.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *VideoMutation) DurationCleared() bool {
	_, ok := m.clearedFields[video.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *VideoMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, video.FieldDuration)
}

// SetUploadedAt sets the "uploaded_at" field.
func (m *VideoMutation) SetUploadedAt(t time.Time) {
	m.uploaded_at = &t
}

// UploadedAt returns the value of the "uploaded_at" field in the mutation.
func (m *VideoMutation) UploadedAt() (r time.Time, exists bool) {
	v := m.uploaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedAt returns the old "uploaded_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUploadedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedAt: %w", err)
	}
	return oldValue.UploadedAt, nil
}

// ClearUploadedAt clears the value of the "uploaded_at" field.
func (m *VideoMutation) ClearUploadedAt() {
	m.uploaded_at = nil
	m.clearedFields[video.FieldUploadedAt] = struct{}{}
}

// UploadedAtCleared returns if the "uploaded_at" field was cleared in this mutation.
func (m *VideoMutation) UploadedAtCleared() bool {
	_, ok := m.clearedFields[video.FieldUploadedAt]
	return ok
}

// ResetUploadedAt resets all changes to the "uploaded_at" field.
func (m *VideoMutation) ResetUploadedAt() {
	m.uploaded_at = nil
	delete(m.clearedFields, video.FieldUploadedAt)
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *VideoMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[video.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *VideoMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *VideoMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *VideoMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[video.FieldUpdaterID] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *VideoMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *VideoMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddEventIDs adds the "event" edge to the Event entity by ids.
func (m *VideoMutation) AddEventIDs(ids ...int) {
	if m.event == nil {
		m.event = make(map[int]struct{})
	}
	for i := range ids {
		m.event[ids[i]] = struct{}{}
	}
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *VideoMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *VideoMutation) EventCleared() bool {
	return m.clearedevent
}

// RemoveEventIDs removes the "event" edge to the Event entity by IDs.
func (m *VideoMutation) RemoveEventIDs(ids ...int) {
	if m.removedevent == nil {
		m.removedevent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event, ids[i])
		m.removedevent[ids[i]] = struct{}{}
	}
}

// RemovedEvent returns the removed IDs of the "event" edge to the Event entity.
func (m *VideoMutation) RemovedEventIDs() (ids []int) {
	for id := range m.removedevent {
		ids = append(ids, id)
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
func (m *VideoMutation) EventIDs() (ids []int) {
	for id := range m.event {
		ids = append(ids, id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *VideoMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
	m.removedevent = nil
}

// Where appends a list predicates to the VideoMutation builder.
func (m *VideoMutation) Where(ps ...predicate.Video) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Video, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Video).
func (m *VideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, video.FieldCreateTime)
	}
	if m.creator != nil {
		fields = append(fields, video.FieldCreatorID)
	}
	if m.delete_time != nil {
		fields = append(fields, video.FieldDeleteTime)
	}
	if m.updater != nil {
		fields = append(fields, video.FieldUpdaterID)
	}
	if m.update_time != nil {
		fields = append(fields, video.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, video.FieldName)
	}
	if m.url != nil {
		fields = append(fields, video.FieldURL)
	}
	if m.size != nil {
		fields = append(fields, video.FieldSize)
	}
	if m.duration != nil {
		fields = append(fields, video.FieldDuration)
	}
	if m.uploaded_at != nil {
		fields = append(fields, video.FieldUploadedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case video.FieldCreateTime:
		return m.CreateTime()
	case video.FieldCreatorID:
		return m.CreatorID()
	case video.FieldDeleteTime:
		return m.DeleteTime()
	case video.FieldUpdaterID:
		return m.UpdaterID()
	case video.FieldUpdateTime:
		return m.UpdateTime()
	case video.FieldName:
		return m.Name()
	case video.FieldURL:
		return m.URL()
	case video.FieldSize:
		return m.Size()
	case video.FieldDuration:
		return m.Duration()
	case video.FieldUploadedAt:
		return m.UploadedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case video.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case video.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case video.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case video.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	case video.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case video.FieldName:
		return m.OldName(ctx)
	case video.FieldURL:
		return m.OldURL(ctx)
	case video.FieldSize:
		return m.OldSize(ctx)
	case video.FieldDuration:
		return m.OldDuration(ctx)
	case video.FieldUploadedAt:
		return m.OldUploadedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Video field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case video.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case video.FieldCreatorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case video.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case video.FieldUpdaterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	case video.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case video.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case video.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case video.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case video.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case video.FieldUploadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, video.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case video.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case video.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Video numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(video.FieldDeleteTime) {
		fields = append(fields, video.FieldDeleteTime)
	}
	if m.FieldCleared(video.FieldName) {
		fields = append(fields, video.FieldName)
	}
	if m.FieldCleared(video.FieldURL) {
		fields = append(fields, video.FieldURL)
	}
	if m.FieldCleared(video.FieldDuration) {
		fields = append(fields, video.FieldDuration)
	}
	if m.FieldCleared(video.FieldUploadedAt) {
		fields = append(fields, video.FieldUploadedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMutation) ClearField(name string) error {
	switch name {
	case video.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case video.FieldName:
		m.ClearName()
		return nil
	case video.FieldURL:
		m.ClearURL()
		return nil
	case video.FieldDuration:
		m.ClearDuration()
		return nil
	case video.FieldUploadedAt:
		m.ClearUploadedAt()
		return nil
	}
	return fmt.Errorf("unknown Video nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMutation) ResetField(name string) error {
	switch name {
	case video.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case video.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case video.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case video.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	case video.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case video.FieldName:
		m.ResetName()
		return nil
	case video.FieldURL:
		m.ResetURL()
		return nil
	case video.FieldSize:
		m.ResetSize()
		return nil
	case video.FieldDuration:
		m.ResetDuration()
		return nil
	case video.FieldUploadedAt:
		m.ResetUploadedAt()
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, video.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, video.EdgeUpdater)
	}
	if m.event != nil {
		edges = append(edges, video.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.event))
		for id := range m.event {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedevent != nil {
		edges = append(edges, video.EdgeEvent)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeEvent:
		ids := make([]ent.Value, 0, len(m.removedevent))
		for id := range m.removedevent {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, video.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, video.EdgeUpdater)
	}
	if m.clearedevent {
		edges = append(edges, video.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMutation) EdgeCleared(name string) bool {
	switch name {
	case video.EdgeCreator:
		return m.clearedcreator
	case video.EdgeUpdater:
		return m.clearedupdater
	case video.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMutation) ClearEdge(name string) error {
	switch name {
	case video.EdgeCreator:
		m.ClearCreator()
		return nil
	case video.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Video unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMutation) ResetEdge(name string) error {
	switch name {
	case video.EdgeCreator:
		m.ResetCreator()
		return nil
	case video.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case video.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Video edge %s", name)
}
