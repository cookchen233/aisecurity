// Code generated by ent, DO NOT EDIT.

package dao

import (
	"aisecurity/ent/dao/admin"
	"aisecurity/ent/dao/adminrole"
	"aisecurity/ent/dao/area"
	"aisecurity/ent/dao/department"
	"aisecurity/ent/dao/device"
	"aisecurity/ent/dao/deviceinstallation"
	"aisecurity/ent/dao/employee"
	"aisecurity/ent/dao/eventlevel"
	"aisecurity/ent/dao/ipcevent"
	"aisecurity/ent/dao/occupation"
	"aisecurity/ent/dao/predicate"
	"aisecurity/ent/dao/risk"
	"aisecurity/ent/dao/riskcategory"
	"aisecurity/ent/dao/risklocation"
	"aisecurity/ent/dao/video"
	"aisecurity/enums"
	"aisecurity/properties/maintain_status"
	"aisecurity/structs/types"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdmin              = "Admin"
	TypeAdminRole          = "AdminRole"
	TypeArea               = "Area"
	TypeDepartment         = "Department"
	TypeDevice             = "Device"
	TypeDeviceInstallation = "DeviceInstallation"
	TypeEmployee           = "Employee"
	TypeEventLevel         = "EventLevel"
	TypeIPCEvent           = "IPCEvent"
	TypeOccupation         = "Occupation"
	TypeRisk               = "Risk"
	TypeRiskCategory       = "RiskCategory"
	TypeRiskLocation       = "RiskLocation"
	TypeVideo              = "Video"
)

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	created_at                         *time.Time
	deleted_at                         *time.Time
	updated_at                         *time.Time
	username                           *string
	password                           *string
	nickname                           *string
	real_name                          *string
	avatar                             *string
	clearedFields                      map[string]struct{}
	creator                            *int
	clearedcreator                     bool
	updater                            *int
	clearedupdater                     bool
	admin_roles                        map[int]struct{}
	removedadmin_roles                 map[int]struct{}
	clearedadmin_roles                 bool
	admin_creator                      map[int]struct{}
	removedadmin_creator               map[int]struct{}
	clearedadmin_creator               bool
	admin_updater                      map[int]struct{}
	removedadmin_updater               map[int]struct{}
	clearedadmin_updater               bool
	admin_role_creator                 map[int]struct{}
	removedadmin_role_creator          map[int]struct{}
	clearedadmin_role_creator          bool
	admin_role_updater                 map[int]struct{}
	removedadmin_role_updater          map[int]struct{}
	clearedadmin_role_updater          bool
	risk_creator                       map[int]struct{}
	removedrisk_creator                map[int]struct{}
	clearedrisk_creator                bool
	risk_updater                       map[int]struct{}
	removedrisk_updater                map[int]struct{}
	clearedrisk_updater                bool
	risk_location_creator              map[int]struct{}
	removedrisk_location_creator       map[int]struct{}
	clearedrisk_location_creator       bool
	risk_location_updater              map[int]struct{}
	removedrisk_location_updater       map[int]struct{}
	clearedrisk_location_updater       bool
	risk_category_creator              map[int]struct{}
	removedrisk_category_creator       map[int]struct{}
	clearedrisk_category_creator       bool
	risk_category_updater              map[int]struct{}
	removedrisk_category_updater       map[int]struct{}
	clearedrisk_category_updater       bool
	department_creator                 map[int]struct{}
	removeddepartment_creator          map[int]struct{}
	cleareddepartment_creator          bool
	department_updater                 map[int]struct{}
	removeddepartment_updater          map[int]struct{}
	cleareddepartment_updater          bool
	employee_creator                   map[int]struct{}
	removedemployee_creator            map[int]struct{}
	clearedemployee_creator            bool
	employee_updater                   map[int]struct{}
	removedemployee_updater            map[int]struct{}
	clearedemployee_updater            bool
	employee                           map[int]struct{}
	removedemployee                    map[int]struct{}
	clearedemployee                    bool
	occupation_creator                 map[int]struct{}
	removedoccupation_creator          map[int]struct{}
	clearedoccupation_creator          bool
	occupation_updater                 map[int]struct{}
	removedoccupation_updater          map[int]struct{}
	clearedoccupation_updater          bool
	ipc_event_creator                  map[int]struct{}
	removedipc_event_creator           map[int]struct{}
	clearedipc_event_creator           bool
	ipc_event_updater                  map[int]struct{}
	removedipc_event_updater           map[int]struct{}
	clearedipc_event_updater           bool
	video_creator                      map[int]struct{}
	removedvideo_creator               map[int]struct{}
	clearedvideo_creator               bool
	video_updater                      map[int]struct{}
	removedvideo_updater               map[int]struct{}
	clearedvideo_updater               bool
	area_creator                       map[int]struct{}
	removedarea_creator                map[int]struct{}
	clearedarea_creator                bool
	area_updater                       map[int]struct{}
	removedarea_updater                map[int]struct{}
	clearedarea_updater                bool
	device_creator                     map[int]struct{}
	removeddevice_creator              map[int]struct{}
	cleareddevice_creator              bool
	device_updater                     map[int]struct{}
	removeddevice_updater              map[int]struct{}
	cleareddevice_updater              bool
	device_installation_creator        map[int]struct{}
	removeddevice_installation_creator map[int]struct{}
	cleareddevice_installation_creator bool
	device_installation_updater        map[int]struct{}
	removeddevice_installation_updater map[int]struct{}
	cleareddevice_installation_updater bool
	event_level_creator                map[int]struct{}
	removedevent_level_creator         map[int]struct{}
	clearedevent_level_creator         bool
	event_level_updater                map[int]struct{}
	removedevent_level_updater         map[int]struct{}
	clearedevent_level_updater         bool
	done                               bool
	oldValue                           func(context.Context) (*Admin, error)
	predicates                         []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id int) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AdminMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AdminMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AdminMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[admin.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[admin.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, admin.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AdminMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AdminMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AdminMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *AdminMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *AdminMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *AdminMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *AdminMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminMutation) ResetPassword() {
	m.password = nil
}

// SetNickname sets the "nickname" field.
func (m *AdminMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AdminMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AdminMutation) ResetNickname() {
	m.nickname = nil
}

// SetRealName sets the "real_name" field.
func (m *AdminMutation) SetRealName(s string) {
	m.real_name = &s
}

// RealName returns the value of the "real_name" field in the mutation.
func (m *AdminMutation) RealName() (r string, exists bool) {
	v := m.real_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "real_name" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "real_name" field.
func (m *AdminMutation) ResetRealName() {
	m.real_name = nil
}

// SetAvatar sets the "avatar" field.
func (m *AdminMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *AdminMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *AdminMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[admin.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *AdminMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[admin.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *AdminMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, admin.FieldAvatar)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *AdminMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AdminMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[admin.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AdminMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *AdminMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AdminMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *AdminMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *AdminMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[admin.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *AdminMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *AdminMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *AdminMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddAdminRoleIDs adds the "admin_roles" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleIDs(ids ...int) {
	if m.admin_roles == nil {
		m.admin_roles = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_roles[ids[i]] = struct{}{}
	}
}

// ClearAdminRoles clears the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoles() {
	m.clearedadmin_roles = true
}

// AdminRolesCleared reports if the "admin_roles" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRolesCleared() bool {
	return m.clearedadmin_roles
}

// RemoveAdminRoleIDs removes the "admin_roles" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleIDs(ids ...int) {
	if m.removedadmin_roles == nil {
		m.removedadmin_roles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_roles, ids[i])
		m.removedadmin_roles[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoles returns the removed IDs of the "admin_roles" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRolesIDs() (ids []int) {
	for id := range m.removedadmin_roles {
		ids = append(ids, id)
	}
	return
}

// AdminRolesIDs returns the "admin_roles" edge IDs in the mutation.
func (m *AdminMutation) AdminRolesIDs() (ids []int) {
	for id := range m.admin_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoles resets all changes to the "admin_roles" edge.
func (m *AdminMutation) ResetAdminRoles() {
	m.admin_roles = nil
	m.clearedadmin_roles = false
	m.removedadmin_roles = nil
}

// AddAdminCreatorIDs adds the "admin_creator" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminCreatorIDs(ids ...int) {
	if m.admin_creator == nil {
		m.admin_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_creator[ids[i]] = struct{}{}
	}
}

// ClearAdminCreator clears the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) ClearAdminCreator() {
	m.clearedadmin_creator = true
}

// AdminCreatorCleared reports if the "admin_creator" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminCreatorCleared() bool {
	return m.clearedadmin_creator
}

// RemoveAdminCreatorIDs removes the "admin_creator" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminCreatorIDs(ids ...int) {
	if m.removedadmin_creator == nil {
		m.removedadmin_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_creator, ids[i])
		m.removedadmin_creator[ids[i]] = struct{}{}
	}
}

// RemovedAdminCreator returns the removed IDs of the "admin_creator" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminCreatorIDs() (ids []int) {
	for id := range m.removedadmin_creator {
		ids = append(ids, id)
	}
	return
}

// AdminCreatorIDs returns the "admin_creator" edge IDs in the mutation.
func (m *AdminMutation) AdminCreatorIDs() (ids []int) {
	for id := range m.admin_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminCreator resets all changes to the "admin_creator" edge.
func (m *AdminMutation) ResetAdminCreator() {
	m.admin_creator = nil
	m.clearedadmin_creator = false
	m.removedadmin_creator = nil
}

// AddAdminUpdaterIDs adds the "admin_updater" edge to the Admin entity by ids.
func (m *AdminMutation) AddAdminUpdaterIDs(ids ...int) {
	if m.admin_updater == nil {
		m.admin_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_updater[ids[i]] = struct{}{}
	}
}

// ClearAdminUpdater clears the "admin_updater" edge to the Admin entity.
func (m *AdminMutation) ClearAdminUpdater() {
	m.clearedadmin_updater = true
}

// AdminUpdaterCleared reports if the "admin_updater" edge to the Admin entity was cleared.
func (m *AdminMutation) AdminUpdaterCleared() bool {
	return m.clearedadmin_updater
}

// RemoveAdminUpdaterIDs removes the "admin_updater" edge to the Admin entity by IDs.
func (m *AdminMutation) RemoveAdminUpdaterIDs(ids ...int) {
	if m.removedadmin_updater == nil {
		m.removedadmin_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_updater, ids[i])
		m.removedadmin_updater[ids[i]] = struct{}{}
	}
}

// RemovedAdminUpdater returns the removed IDs of the "admin_updater" edge to the Admin entity.
func (m *AdminMutation) RemovedAdminUpdaterIDs() (ids []int) {
	for id := range m.removedadmin_updater {
		ids = append(ids, id)
	}
	return
}

// AdminUpdaterIDs returns the "admin_updater" edge IDs in the mutation.
func (m *AdminMutation) AdminUpdaterIDs() (ids []int) {
	for id := range m.admin_updater {
		ids = append(ids, id)
	}
	return
}

// ResetAdminUpdater resets all changes to the "admin_updater" edge.
func (m *AdminMutation) ResetAdminUpdater() {
	m.admin_updater = nil
	m.clearedadmin_updater = false
	m.removedadmin_updater = nil
}

// AddAdminRoleCreatorIDs adds the "admin_role_creator" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleCreatorIDs(ids ...int) {
	if m.admin_role_creator == nil {
		m.admin_role_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_role_creator[ids[i]] = struct{}{}
	}
}

// ClearAdminRoleCreator clears the "admin_role_creator" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoleCreator() {
	m.clearedadmin_role_creator = true
}

// AdminRoleCreatorCleared reports if the "admin_role_creator" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRoleCreatorCleared() bool {
	return m.clearedadmin_role_creator
}

// RemoveAdminRoleCreatorIDs removes the "admin_role_creator" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleCreatorIDs(ids ...int) {
	if m.removedadmin_role_creator == nil {
		m.removedadmin_role_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_role_creator, ids[i])
		m.removedadmin_role_creator[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoleCreator returns the removed IDs of the "admin_role_creator" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRoleCreatorIDs() (ids []int) {
	for id := range m.removedadmin_role_creator {
		ids = append(ids, id)
	}
	return
}

// AdminRoleCreatorIDs returns the "admin_role_creator" edge IDs in the mutation.
func (m *AdminMutation) AdminRoleCreatorIDs() (ids []int) {
	for id := range m.admin_role_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoleCreator resets all changes to the "admin_role_creator" edge.
func (m *AdminMutation) ResetAdminRoleCreator() {
	m.admin_role_creator = nil
	m.clearedadmin_role_creator = false
	m.removedadmin_role_creator = nil
}

// AddAdminRoleUpdaterIDs adds the "admin_role_updater" edge to the AdminRole entity by ids.
func (m *AdminMutation) AddAdminRoleUpdaterIDs(ids ...int) {
	if m.admin_role_updater == nil {
		m.admin_role_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.admin_role_updater[ids[i]] = struct{}{}
	}
}

// ClearAdminRoleUpdater clears the "admin_role_updater" edge to the AdminRole entity.
func (m *AdminMutation) ClearAdminRoleUpdater() {
	m.clearedadmin_role_updater = true
}

// AdminRoleUpdaterCleared reports if the "admin_role_updater" edge to the AdminRole entity was cleared.
func (m *AdminMutation) AdminRoleUpdaterCleared() bool {
	return m.clearedadmin_role_updater
}

// RemoveAdminRoleUpdaterIDs removes the "admin_role_updater" edge to the AdminRole entity by IDs.
func (m *AdminMutation) RemoveAdminRoleUpdaterIDs(ids ...int) {
	if m.removedadmin_role_updater == nil {
		m.removedadmin_role_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admin_role_updater, ids[i])
		m.removedadmin_role_updater[ids[i]] = struct{}{}
	}
}

// RemovedAdminRoleUpdater returns the removed IDs of the "admin_role_updater" edge to the AdminRole entity.
func (m *AdminMutation) RemovedAdminRoleUpdaterIDs() (ids []int) {
	for id := range m.removedadmin_role_updater {
		ids = append(ids, id)
	}
	return
}

// AdminRoleUpdaterIDs returns the "admin_role_updater" edge IDs in the mutation.
func (m *AdminMutation) AdminRoleUpdaterIDs() (ids []int) {
	for id := range m.admin_role_updater {
		ids = append(ids, id)
	}
	return
}

// ResetAdminRoleUpdater resets all changes to the "admin_role_updater" edge.
func (m *AdminMutation) ResetAdminRoleUpdater() {
	m.admin_role_updater = nil
	m.clearedadmin_role_updater = false
	m.removedadmin_role_updater = nil
}

// AddRiskCreatorIDs adds the "risk_creator" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskCreatorIDs(ids ...int) {
	if m.risk_creator == nil {
		m.risk_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCreator clears the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) ClearRiskCreator() {
	m.clearedrisk_creator = true
}

// RiskCreatorCleared reports if the "risk_creator" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskCreatorCleared() bool {
	return m.clearedrisk_creator
}

// RemoveRiskCreatorIDs removes the "risk_creator" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskCreatorIDs(ids ...int) {
	if m.removedrisk_creator == nil {
		m.removedrisk_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_creator, ids[i])
		m.removedrisk_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCreator returns the removed IDs of the "risk_creator" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskCreatorIDs() (ids []int) {
	for id := range m.removedrisk_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCreatorIDs returns the "risk_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCreatorIDs() (ids []int) {
	for id := range m.risk_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCreator resets all changes to the "risk_creator" edge.
func (m *AdminMutation) ResetRiskCreator() {
	m.risk_creator = nil
	m.clearedrisk_creator = false
	m.removedrisk_creator = nil
}

// AddRiskUpdaterIDs adds the "risk_updater" edge to the Risk entity by ids.
func (m *AdminMutation) AddRiskUpdaterIDs(ids ...int) {
	if m.risk_updater == nil {
		m.risk_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskUpdater clears the "risk_updater" edge to the Risk entity.
func (m *AdminMutation) ClearRiskUpdater() {
	m.clearedrisk_updater = true
}

// RiskUpdaterCleared reports if the "risk_updater" edge to the Risk entity was cleared.
func (m *AdminMutation) RiskUpdaterCleared() bool {
	return m.clearedrisk_updater
}

// RemoveRiskUpdaterIDs removes the "risk_updater" edge to the Risk entity by IDs.
func (m *AdminMutation) RemoveRiskUpdaterIDs(ids ...int) {
	if m.removedrisk_updater == nil {
		m.removedrisk_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_updater, ids[i])
		m.removedrisk_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskUpdater returns the removed IDs of the "risk_updater" edge to the Risk entity.
func (m *AdminMutation) RemovedRiskUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_updater {
		ids = append(ids, id)
	}
	return
}

// RiskUpdaterIDs returns the "risk_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskUpdaterIDs() (ids []int) {
	for id := range m.risk_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskUpdater resets all changes to the "risk_updater" edge.
func (m *AdminMutation) ResetRiskUpdater() {
	m.risk_updater = nil
	m.clearedrisk_updater = false
	m.removedrisk_updater = nil
}

// AddRiskLocationCreatorIDs adds the "risk_location_creator" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationCreatorIDs(ids ...int) {
	if m.risk_location_creator == nil {
		m.risk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationCreator clears the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationCreator() {
	m.clearedrisk_location_creator = true
}

// RiskLocationCreatorCleared reports if the "risk_location_creator" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationCreatorCleared() bool {
	return m.clearedrisk_location_creator
}

// RemoveRiskLocationCreatorIDs removes the "risk_location_creator" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationCreatorIDs(ids ...int) {
	if m.removedrisk_location_creator == nil {
		m.removedrisk_location_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_creator, ids[i])
		m.removedrisk_location_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationCreator returns the removed IDs of the "risk_location_creator" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationCreatorIDs() (ids []int) {
	for id := range m.removedrisk_location_creator {
		ids = append(ids, id)
	}
	return
}

// RiskLocationCreatorIDs returns the "risk_location_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationCreatorIDs() (ids []int) {
	for id := range m.risk_location_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationCreator resets all changes to the "risk_location_creator" edge.
func (m *AdminMutation) ResetRiskLocationCreator() {
	m.risk_location_creator = nil
	m.clearedrisk_location_creator = false
	m.removedrisk_location_creator = nil
}

// AddRiskLocationUpdaterIDs adds the "risk_location_updater" edge to the RiskLocation entity by ids.
func (m *AdminMutation) AddRiskLocationUpdaterIDs(ids ...int) {
	if m.risk_location_updater == nil {
		m.risk_location_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_location_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskLocationUpdater clears the "risk_location_updater" edge to the RiskLocation entity.
func (m *AdminMutation) ClearRiskLocationUpdater() {
	m.clearedrisk_location_updater = true
}

// RiskLocationUpdaterCleared reports if the "risk_location_updater" edge to the RiskLocation entity was cleared.
func (m *AdminMutation) RiskLocationUpdaterCleared() bool {
	return m.clearedrisk_location_updater
}

// RemoveRiskLocationUpdaterIDs removes the "risk_location_updater" edge to the RiskLocation entity by IDs.
func (m *AdminMutation) RemoveRiskLocationUpdaterIDs(ids ...int) {
	if m.removedrisk_location_updater == nil {
		m.removedrisk_location_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_location_updater, ids[i])
		m.removedrisk_location_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskLocationUpdater returns the removed IDs of the "risk_location_updater" edge to the RiskLocation entity.
func (m *AdminMutation) RemovedRiskLocationUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_location_updater {
		ids = append(ids, id)
	}
	return
}

// RiskLocationUpdaterIDs returns the "risk_location_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskLocationUpdaterIDs() (ids []int) {
	for id := range m.risk_location_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskLocationUpdater resets all changes to the "risk_location_updater" edge.
func (m *AdminMutation) ResetRiskLocationUpdater() {
	m.risk_location_updater = nil
	m.clearedrisk_location_updater = false
	m.removedrisk_location_updater = nil
}

// AddRiskCategoryCreatorIDs adds the "risk_category_creator" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryCreatorIDs(ids ...int) {
	if m.risk_category_creator == nil {
		m.risk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_creator[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryCreator clears the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryCreator() {
	m.clearedrisk_category_creator = true
}

// RiskCategoryCreatorCleared reports if the "risk_category_creator" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryCreatorCleared() bool {
	return m.clearedrisk_category_creator
}

// RemoveRiskCategoryCreatorIDs removes the "risk_category_creator" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryCreatorIDs(ids ...int) {
	if m.removedrisk_category_creator == nil {
		m.removedrisk_category_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_creator, ids[i])
		m.removedrisk_category_creator[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryCreator returns the removed IDs of the "risk_category_creator" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryCreatorIDs() (ids []int) {
	for id := range m.removedrisk_category_creator {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryCreatorIDs returns the "risk_category_creator" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryCreatorIDs() (ids []int) {
	for id := range m.risk_category_creator {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryCreator resets all changes to the "risk_category_creator" edge.
func (m *AdminMutation) ResetRiskCategoryCreator() {
	m.risk_category_creator = nil
	m.clearedrisk_category_creator = false
	m.removedrisk_category_creator = nil
}

// AddRiskCategoryUpdaterIDs adds the "risk_category_updater" edge to the RiskCategory entity by ids.
func (m *AdminMutation) AddRiskCategoryUpdaterIDs(ids ...int) {
	if m.risk_category_updater == nil {
		m.risk_category_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_category_updater[ids[i]] = struct{}{}
	}
}

// ClearRiskCategoryUpdater clears the "risk_category_updater" edge to the RiskCategory entity.
func (m *AdminMutation) ClearRiskCategoryUpdater() {
	m.clearedrisk_category_updater = true
}

// RiskCategoryUpdaterCleared reports if the "risk_category_updater" edge to the RiskCategory entity was cleared.
func (m *AdminMutation) RiskCategoryUpdaterCleared() bool {
	return m.clearedrisk_category_updater
}

// RemoveRiskCategoryUpdaterIDs removes the "risk_category_updater" edge to the RiskCategory entity by IDs.
func (m *AdminMutation) RemoveRiskCategoryUpdaterIDs(ids ...int) {
	if m.removedrisk_category_updater == nil {
		m.removedrisk_category_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_category_updater, ids[i])
		m.removedrisk_category_updater[ids[i]] = struct{}{}
	}
}

// RemovedRiskCategoryUpdater returns the removed IDs of the "risk_category_updater" edge to the RiskCategory entity.
func (m *AdminMutation) RemovedRiskCategoryUpdaterIDs() (ids []int) {
	for id := range m.removedrisk_category_updater {
		ids = append(ids, id)
	}
	return
}

// RiskCategoryUpdaterIDs returns the "risk_category_updater" edge IDs in the mutation.
func (m *AdminMutation) RiskCategoryUpdaterIDs() (ids []int) {
	for id := range m.risk_category_updater {
		ids = append(ids, id)
	}
	return
}

// ResetRiskCategoryUpdater resets all changes to the "risk_category_updater" edge.
func (m *AdminMutation) ResetRiskCategoryUpdater() {
	m.risk_category_updater = nil
	m.clearedrisk_category_updater = false
	m.removedrisk_category_updater = nil
}

// AddDepartmentCreatorIDs adds the "department_creator" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentCreatorIDs(ids ...int) {
	if m.department_creator == nil {
		m.department_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.department_creator[ids[i]] = struct{}{}
	}
}

// ClearDepartmentCreator clears the "department_creator" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentCreator() {
	m.cleareddepartment_creator = true
}

// DepartmentCreatorCleared reports if the "department_creator" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentCreatorCleared() bool {
	return m.cleareddepartment_creator
}

// RemoveDepartmentCreatorIDs removes the "department_creator" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentCreatorIDs(ids ...int) {
	if m.removeddepartment_creator == nil {
		m.removeddepartment_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_creator, ids[i])
		m.removeddepartment_creator[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentCreator returns the removed IDs of the "department_creator" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentCreatorIDs() (ids []int) {
	for id := range m.removeddepartment_creator {
		ids = append(ids, id)
	}
	return
}

// DepartmentCreatorIDs returns the "department_creator" edge IDs in the mutation.
func (m *AdminMutation) DepartmentCreatorIDs() (ids []int) {
	for id := range m.department_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentCreator resets all changes to the "department_creator" edge.
func (m *AdminMutation) ResetDepartmentCreator() {
	m.department_creator = nil
	m.cleareddepartment_creator = false
	m.removeddepartment_creator = nil
}

// AddDepartmentUpdaterIDs adds the "department_updater" edge to the Department entity by ids.
func (m *AdminMutation) AddDepartmentUpdaterIDs(ids ...int) {
	if m.department_updater == nil {
		m.department_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.department_updater[ids[i]] = struct{}{}
	}
}

// ClearDepartmentUpdater clears the "department_updater" edge to the Department entity.
func (m *AdminMutation) ClearDepartmentUpdater() {
	m.cleareddepartment_updater = true
}

// DepartmentUpdaterCleared reports if the "department_updater" edge to the Department entity was cleared.
func (m *AdminMutation) DepartmentUpdaterCleared() bool {
	return m.cleareddepartment_updater
}

// RemoveDepartmentUpdaterIDs removes the "department_updater" edge to the Department entity by IDs.
func (m *AdminMutation) RemoveDepartmentUpdaterIDs(ids ...int) {
	if m.removeddepartment_updater == nil {
		m.removeddepartment_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.department_updater, ids[i])
		m.removeddepartment_updater[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentUpdater returns the removed IDs of the "department_updater" edge to the Department entity.
func (m *AdminMutation) RemovedDepartmentUpdaterIDs() (ids []int) {
	for id := range m.removeddepartment_updater {
		ids = append(ids, id)
	}
	return
}

// DepartmentUpdaterIDs returns the "department_updater" edge IDs in the mutation.
func (m *AdminMutation) DepartmentUpdaterIDs() (ids []int) {
	for id := range m.department_updater {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentUpdater resets all changes to the "department_updater" edge.
func (m *AdminMutation) ResetDepartmentUpdater() {
	m.department_updater = nil
	m.cleareddepartment_updater = false
	m.removeddepartment_updater = nil
}

// AddEmployeeCreatorIDs adds the "employee_creator" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeCreatorIDs(ids ...int) {
	if m.employee_creator == nil {
		m.employee_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_creator[ids[i]] = struct{}{}
	}
}

// ClearEmployeeCreator clears the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeCreator() {
	m.clearedemployee_creator = true
}

// EmployeeCreatorCleared reports if the "employee_creator" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeCreatorCleared() bool {
	return m.clearedemployee_creator
}

// RemoveEmployeeCreatorIDs removes the "employee_creator" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeCreatorIDs(ids ...int) {
	if m.removedemployee_creator == nil {
		m.removedemployee_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_creator, ids[i])
		m.removedemployee_creator[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeCreator returns the removed IDs of the "employee_creator" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeCreatorIDs() (ids []int) {
	for id := range m.removedemployee_creator {
		ids = append(ids, id)
	}
	return
}

// EmployeeCreatorIDs returns the "employee_creator" edge IDs in the mutation.
func (m *AdminMutation) EmployeeCreatorIDs() (ids []int) {
	for id := range m.employee_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeCreator resets all changes to the "employee_creator" edge.
func (m *AdminMutation) ResetEmployeeCreator() {
	m.employee_creator = nil
	m.clearedemployee_creator = false
	m.removedemployee_creator = nil
}

// AddEmployeeUpdaterIDs adds the "employee_updater" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeUpdaterIDs(ids ...int) {
	if m.employee_updater == nil {
		m.employee_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.employee_updater[ids[i]] = struct{}{}
	}
}

// ClearEmployeeUpdater clears the "employee_updater" edge to the Employee entity.
func (m *AdminMutation) ClearEmployeeUpdater() {
	m.clearedemployee_updater = true
}

// EmployeeUpdaterCleared reports if the "employee_updater" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeUpdaterCleared() bool {
	return m.clearedemployee_updater
}

// RemoveEmployeeUpdaterIDs removes the "employee_updater" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeUpdaterIDs(ids ...int) {
	if m.removedemployee_updater == nil {
		m.removedemployee_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee_updater, ids[i])
		m.removedemployee_updater[ids[i]] = struct{}{}
	}
}

// RemovedEmployeeUpdater returns the removed IDs of the "employee_updater" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeUpdaterIDs() (ids []int) {
	for id := range m.removedemployee_updater {
		ids = append(ids, id)
	}
	return
}

// EmployeeUpdaterIDs returns the "employee_updater" edge IDs in the mutation.
func (m *AdminMutation) EmployeeUpdaterIDs() (ids []int) {
	for id := range m.employee_updater {
		ids = append(ids, id)
	}
	return
}

// ResetEmployeeUpdater resets all changes to the "employee_updater" edge.
func (m *AdminMutation) ResetEmployeeUpdater() {
	m.employee_updater = nil
	m.clearedemployee_updater = false
	m.removedemployee_updater = nil
}

// AddEmployeeIDs adds the "employee" edge to the Employee entity by ids.
func (m *AdminMutation) AddEmployeeIDs(ids ...int) {
	if m.employee == nil {
		m.employee = make(map[int]struct{})
	}
	for i := range ids {
		m.employee[ids[i]] = struct{}{}
	}
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AdminMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AdminMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// RemoveEmployeeIDs removes the "employee" edge to the Employee entity by IDs.
func (m *AdminMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployee == nil {
		m.removedemployee = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employee, ids[i])
		m.removedemployee[ids[i]] = struct{}{}
	}
}

// RemovedEmployee returns the removed IDs of the "employee" edge to the Employee entity.
func (m *AdminMutation) RemovedEmployeeIDs() (ids []int) {
	for id := range m.removedemployee {
		ids = append(ids, id)
	}
	return
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
func (m *AdminMutation) EmployeeIDs() (ids []int) {
	for id := range m.employee {
		ids = append(ids, id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AdminMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
	m.removedemployee = nil
}

// AddOccupationCreatorIDs adds the "occupation_creator" edge to the Occupation entity by ids.
func (m *AdminMutation) AddOccupationCreatorIDs(ids ...int) {
	if m.occupation_creator == nil {
		m.occupation_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.occupation_creator[ids[i]] = struct{}{}
	}
}

// ClearOccupationCreator clears the "occupation_creator" edge to the Occupation entity.
func (m *AdminMutation) ClearOccupationCreator() {
	m.clearedoccupation_creator = true
}

// OccupationCreatorCleared reports if the "occupation_creator" edge to the Occupation entity was cleared.
func (m *AdminMutation) OccupationCreatorCleared() bool {
	return m.clearedoccupation_creator
}

// RemoveOccupationCreatorIDs removes the "occupation_creator" edge to the Occupation entity by IDs.
func (m *AdminMutation) RemoveOccupationCreatorIDs(ids ...int) {
	if m.removedoccupation_creator == nil {
		m.removedoccupation_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupation_creator, ids[i])
		m.removedoccupation_creator[ids[i]] = struct{}{}
	}
}

// RemovedOccupationCreator returns the removed IDs of the "occupation_creator" edge to the Occupation entity.
func (m *AdminMutation) RemovedOccupationCreatorIDs() (ids []int) {
	for id := range m.removedoccupation_creator {
		ids = append(ids, id)
	}
	return
}

// OccupationCreatorIDs returns the "occupation_creator" edge IDs in the mutation.
func (m *AdminMutation) OccupationCreatorIDs() (ids []int) {
	for id := range m.occupation_creator {
		ids = append(ids, id)
	}
	return
}

// ResetOccupationCreator resets all changes to the "occupation_creator" edge.
func (m *AdminMutation) ResetOccupationCreator() {
	m.occupation_creator = nil
	m.clearedoccupation_creator = false
	m.removedoccupation_creator = nil
}

// AddOccupationUpdaterIDs adds the "occupation_updater" edge to the Occupation entity by ids.
func (m *AdminMutation) AddOccupationUpdaterIDs(ids ...int) {
	if m.occupation_updater == nil {
		m.occupation_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.occupation_updater[ids[i]] = struct{}{}
	}
}

// ClearOccupationUpdater clears the "occupation_updater" edge to the Occupation entity.
func (m *AdminMutation) ClearOccupationUpdater() {
	m.clearedoccupation_updater = true
}

// OccupationUpdaterCleared reports if the "occupation_updater" edge to the Occupation entity was cleared.
func (m *AdminMutation) OccupationUpdaterCleared() bool {
	return m.clearedoccupation_updater
}

// RemoveOccupationUpdaterIDs removes the "occupation_updater" edge to the Occupation entity by IDs.
func (m *AdminMutation) RemoveOccupationUpdaterIDs(ids ...int) {
	if m.removedoccupation_updater == nil {
		m.removedoccupation_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupation_updater, ids[i])
		m.removedoccupation_updater[ids[i]] = struct{}{}
	}
}

// RemovedOccupationUpdater returns the removed IDs of the "occupation_updater" edge to the Occupation entity.
func (m *AdminMutation) RemovedOccupationUpdaterIDs() (ids []int) {
	for id := range m.removedoccupation_updater {
		ids = append(ids, id)
	}
	return
}

// OccupationUpdaterIDs returns the "occupation_updater" edge IDs in the mutation.
func (m *AdminMutation) OccupationUpdaterIDs() (ids []int) {
	for id := range m.occupation_updater {
		ids = append(ids, id)
	}
	return
}

// ResetOccupationUpdater resets all changes to the "occupation_updater" edge.
func (m *AdminMutation) ResetOccupationUpdater() {
	m.occupation_updater = nil
	m.clearedoccupation_updater = false
	m.removedoccupation_updater = nil
}

// AddIpcEventCreatorIDs adds the "ipc_event_creator" edge to the IPCEvent entity by ids.
func (m *AdminMutation) AddIpcEventCreatorIDs(ids ...int) {
	if m.ipc_event_creator == nil {
		m.ipc_event_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_event_creator[ids[i]] = struct{}{}
	}
}

// ClearIpcEventCreator clears the "ipc_event_creator" edge to the IPCEvent entity.
func (m *AdminMutation) ClearIpcEventCreator() {
	m.clearedipc_event_creator = true
}

// IpcEventCreatorCleared reports if the "ipc_event_creator" edge to the IPCEvent entity was cleared.
func (m *AdminMutation) IpcEventCreatorCleared() bool {
	return m.clearedipc_event_creator
}

// RemoveIpcEventCreatorIDs removes the "ipc_event_creator" edge to the IPCEvent entity by IDs.
func (m *AdminMutation) RemoveIpcEventCreatorIDs(ids ...int) {
	if m.removedipc_event_creator == nil {
		m.removedipc_event_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_event_creator, ids[i])
		m.removedipc_event_creator[ids[i]] = struct{}{}
	}
}

// RemovedIpcEventCreator returns the removed IDs of the "ipc_event_creator" edge to the IPCEvent entity.
func (m *AdminMutation) RemovedIpcEventCreatorIDs() (ids []int) {
	for id := range m.removedipc_event_creator {
		ids = append(ids, id)
	}
	return
}

// IpcEventCreatorIDs returns the "ipc_event_creator" edge IDs in the mutation.
func (m *AdminMutation) IpcEventCreatorIDs() (ids []int) {
	for id := range m.ipc_event_creator {
		ids = append(ids, id)
	}
	return
}

// ResetIpcEventCreator resets all changes to the "ipc_event_creator" edge.
func (m *AdminMutation) ResetIpcEventCreator() {
	m.ipc_event_creator = nil
	m.clearedipc_event_creator = false
	m.removedipc_event_creator = nil
}

// AddIpcEventUpdaterIDs adds the "ipc_event_updater" edge to the IPCEvent entity by ids.
func (m *AdminMutation) AddIpcEventUpdaterIDs(ids ...int) {
	if m.ipc_event_updater == nil {
		m.ipc_event_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_event_updater[ids[i]] = struct{}{}
	}
}

// ClearIpcEventUpdater clears the "ipc_event_updater" edge to the IPCEvent entity.
func (m *AdminMutation) ClearIpcEventUpdater() {
	m.clearedipc_event_updater = true
}

// IpcEventUpdaterCleared reports if the "ipc_event_updater" edge to the IPCEvent entity was cleared.
func (m *AdminMutation) IpcEventUpdaterCleared() bool {
	return m.clearedipc_event_updater
}

// RemoveIpcEventUpdaterIDs removes the "ipc_event_updater" edge to the IPCEvent entity by IDs.
func (m *AdminMutation) RemoveIpcEventUpdaterIDs(ids ...int) {
	if m.removedipc_event_updater == nil {
		m.removedipc_event_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_event_updater, ids[i])
		m.removedipc_event_updater[ids[i]] = struct{}{}
	}
}

// RemovedIpcEventUpdater returns the removed IDs of the "ipc_event_updater" edge to the IPCEvent entity.
func (m *AdminMutation) RemovedIpcEventUpdaterIDs() (ids []int) {
	for id := range m.removedipc_event_updater {
		ids = append(ids, id)
	}
	return
}

// IpcEventUpdaterIDs returns the "ipc_event_updater" edge IDs in the mutation.
func (m *AdminMutation) IpcEventUpdaterIDs() (ids []int) {
	for id := range m.ipc_event_updater {
		ids = append(ids, id)
	}
	return
}

// ResetIpcEventUpdater resets all changes to the "ipc_event_updater" edge.
func (m *AdminMutation) ResetIpcEventUpdater() {
	m.ipc_event_updater = nil
	m.clearedipc_event_updater = false
	m.removedipc_event_updater = nil
}

// AddVideoCreatorIDs adds the "video_creator" edge to the Video entity by ids.
func (m *AdminMutation) AddVideoCreatorIDs(ids ...int) {
	if m.video_creator == nil {
		m.video_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.video_creator[ids[i]] = struct{}{}
	}
}

// ClearVideoCreator clears the "video_creator" edge to the Video entity.
func (m *AdminMutation) ClearVideoCreator() {
	m.clearedvideo_creator = true
}

// VideoCreatorCleared reports if the "video_creator" edge to the Video entity was cleared.
func (m *AdminMutation) VideoCreatorCleared() bool {
	return m.clearedvideo_creator
}

// RemoveVideoCreatorIDs removes the "video_creator" edge to the Video entity by IDs.
func (m *AdminMutation) RemoveVideoCreatorIDs(ids ...int) {
	if m.removedvideo_creator == nil {
		m.removedvideo_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.video_creator, ids[i])
		m.removedvideo_creator[ids[i]] = struct{}{}
	}
}

// RemovedVideoCreator returns the removed IDs of the "video_creator" edge to the Video entity.
func (m *AdminMutation) RemovedVideoCreatorIDs() (ids []int) {
	for id := range m.removedvideo_creator {
		ids = append(ids, id)
	}
	return
}

// VideoCreatorIDs returns the "video_creator" edge IDs in the mutation.
func (m *AdminMutation) VideoCreatorIDs() (ids []int) {
	for id := range m.video_creator {
		ids = append(ids, id)
	}
	return
}

// ResetVideoCreator resets all changes to the "video_creator" edge.
func (m *AdminMutation) ResetVideoCreator() {
	m.video_creator = nil
	m.clearedvideo_creator = false
	m.removedvideo_creator = nil
}

// AddVideoUpdaterIDs adds the "video_updater" edge to the Video entity by ids.
func (m *AdminMutation) AddVideoUpdaterIDs(ids ...int) {
	if m.video_updater == nil {
		m.video_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.video_updater[ids[i]] = struct{}{}
	}
}

// ClearVideoUpdater clears the "video_updater" edge to the Video entity.
func (m *AdminMutation) ClearVideoUpdater() {
	m.clearedvideo_updater = true
}

// VideoUpdaterCleared reports if the "video_updater" edge to the Video entity was cleared.
func (m *AdminMutation) VideoUpdaterCleared() bool {
	return m.clearedvideo_updater
}

// RemoveVideoUpdaterIDs removes the "video_updater" edge to the Video entity by IDs.
func (m *AdminMutation) RemoveVideoUpdaterIDs(ids ...int) {
	if m.removedvideo_updater == nil {
		m.removedvideo_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.video_updater, ids[i])
		m.removedvideo_updater[ids[i]] = struct{}{}
	}
}

// RemovedVideoUpdater returns the removed IDs of the "video_updater" edge to the Video entity.
func (m *AdminMutation) RemovedVideoUpdaterIDs() (ids []int) {
	for id := range m.removedvideo_updater {
		ids = append(ids, id)
	}
	return
}

// VideoUpdaterIDs returns the "video_updater" edge IDs in the mutation.
func (m *AdminMutation) VideoUpdaterIDs() (ids []int) {
	for id := range m.video_updater {
		ids = append(ids, id)
	}
	return
}

// ResetVideoUpdater resets all changes to the "video_updater" edge.
func (m *AdminMutation) ResetVideoUpdater() {
	m.video_updater = nil
	m.clearedvideo_updater = false
	m.removedvideo_updater = nil
}

// AddAreaCreatorIDs adds the "area_creator" edge to the Area entity by ids.
func (m *AdminMutation) AddAreaCreatorIDs(ids ...int) {
	if m.area_creator == nil {
		m.area_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.area_creator[ids[i]] = struct{}{}
	}
}

// ClearAreaCreator clears the "area_creator" edge to the Area entity.
func (m *AdminMutation) ClearAreaCreator() {
	m.clearedarea_creator = true
}

// AreaCreatorCleared reports if the "area_creator" edge to the Area entity was cleared.
func (m *AdminMutation) AreaCreatorCleared() bool {
	return m.clearedarea_creator
}

// RemoveAreaCreatorIDs removes the "area_creator" edge to the Area entity by IDs.
func (m *AdminMutation) RemoveAreaCreatorIDs(ids ...int) {
	if m.removedarea_creator == nil {
		m.removedarea_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.area_creator, ids[i])
		m.removedarea_creator[ids[i]] = struct{}{}
	}
}

// RemovedAreaCreator returns the removed IDs of the "area_creator" edge to the Area entity.
func (m *AdminMutation) RemovedAreaCreatorIDs() (ids []int) {
	for id := range m.removedarea_creator {
		ids = append(ids, id)
	}
	return
}

// AreaCreatorIDs returns the "area_creator" edge IDs in the mutation.
func (m *AdminMutation) AreaCreatorIDs() (ids []int) {
	for id := range m.area_creator {
		ids = append(ids, id)
	}
	return
}

// ResetAreaCreator resets all changes to the "area_creator" edge.
func (m *AdminMutation) ResetAreaCreator() {
	m.area_creator = nil
	m.clearedarea_creator = false
	m.removedarea_creator = nil
}

// AddAreaUpdaterIDs adds the "area_updater" edge to the Area entity by ids.
func (m *AdminMutation) AddAreaUpdaterIDs(ids ...int) {
	if m.area_updater == nil {
		m.area_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.area_updater[ids[i]] = struct{}{}
	}
}

// ClearAreaUpdater clears the "area_updater" edge to the Area entity.
func (m *AdminMutation) ClearAreaUpdater() {
	m.clearedarea_updater = true
}

// AreaUpdaterCleared reports if the "area_updater" edge to the Area entity was cleared.
func (m *AdminMutation) AreaUpdaterCleared() bool {
	return m.clearedarea_updater
}

// RemoveAreaUpdaterIDs removes the "area_updater" edge to the Area entity by IDs.
func (m *AdminMutation) RemoveAreaUpdaterIDs(ids ...int) {
	if m.removedarea_updater == nil {
		m.removedarea_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.area_updater, ids[i])
		m.removedarea_updater[ids[i]] = struct{}{}
	}
}

// RemovedAreaUpdater returns the removed IDs of the "area_updater" edge to the Area entity.
func (m *AdminMutation) RemovedAreaUpdaterIDs() (ids []int) {
	for id := range m.removedarea_updater {
		ids = append(ids, id)
	}
	return
}

// AreaUpdaterIDs returns the "area_updater" edge IDs in the mutation.
func (m *AdminMutation) AreaUpdaterIDs() (ids []int) {
	for id := range m.area_updater {
		ids = append(ids, id)
	}
	return
}

// ResetAreaUpdater resets all changes to the "area_updater" edge.
func (m *AdminMutation) ResetAreaUpdater() {
	m.area_updater = nil
	m.clearedarea_updater = false
	m.removedarea_updater = nil
}

// AddDeviceCreatorIDs adds the "device_creator" edge to the Device entity by ids.
func (m *AdminMutation) AddDeviceCreatorIDs(ids ...int) {
	if m.device_creator == nil {
		m.device_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.device_creator[ids[i]] = struct{}{}
	}
}

// ClearDeviceCreator clears the "device_creator" edge to the Device entity.
func (m *AdminMutation) ClearDeviceCreator() {
	m.cleareddevice_creator = true
}

// DeviceCreatorCleared reports if the "device_creator" edge to the Device entity was cleared.
func (m *AdminMutation) DeviceCreatorCleared() bool {
	return m.cleareddevice_creator
}

// RemoveDeviceCreatorIDs removes the "device_creator" edge to the Device entity by IDs.
func (m *AdminMutation) RemoveDeviceCreatorIDs(ids ...int) {
	if m.removeddevice_creator == nil {
		m.removeddevice_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_creator, ids[i])
		m.removeddevice_creator[ids[i]] = struct{}{}
	}
}

// RemovedDeviceCreator returns the removed IDs of the "device_creator" edge to the Device entity.
func (m *AdminMutation) RemovedDeviceCreatorIDs() (ids []int) {
	for id := range m.removeddevice_creator {
		ids = append(ids, id)
	}
	return
}

// DeviceCreatorIDs returns the "device_creator" edge IDs in the mutation.
func (m *AdminMutation) DeviceCreatorIDs() (ids []int) {
	for id := range m.device_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceCreator resets all changes to the "device_creator" edge.
func (m *AdminMutation) ResetDeviceCreator() {
	m.device_creator = nil
	m.cleareddevice_creator = false
	m.removeddevice_creator = nil
}

// AddDeviceUpdaterIDs adds the "device_updater" edge to the Device entity by ids.
func (m *AdminMutation) AddDeviceUpdaterIDs(ids ...int) {
	if m.device_updater == nil {
		m.device_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.device_updater[ids[i]] = struct{}{}
	}
}

// ClearDeviceUpdater clears the "device_updater" edge to the Device entity.
func (m *AdminMutation) ClearDeviceUpdater() {
	m.cleareddevice_updater = true
}

// DeviceUpdaterCleared reports if the "device_updater" edge to the Device entity was cleared.
func (m *AdminMutation) DeviceUpdaterCleared() bool {
	return m.cleareddevice_updater
}

// RemoveDeviceUpdaterIDs removes the "device_updater" edge to the Device entity by IDs.
func (m *AdminMutation) RemoveDeviceUpdaterIDs(ids ...int) {
	if m.removeddevice_updater == nil {
		m.removeddevice_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_updater, ids[i])
		m.removeddevice_updater[ids[i]] = struct{}{}
	}
}

// RemovedDeviceUpdater returns the removed IDs of the "device_updater" edge to the Device entity.
func (m *AdminMutation) RemovedDeviceUpdaterIDs() (ids []int) {
	for id := range m.removeddevice_updater {
		ids = append(ids, id)
	}
	return
}

// DeviceUpdaterIDs returns the "device_updater" edge IDs in the mutation.
func (m *AdminMutation) DeviceUpdaterIDs() (ids []int) {
	for id := range m.device_updater {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceUpdater resets all changes to the "device_updater" edge.
func (m *AdminMutation) ResetDeviceUpdater() {
	m.device_updater = nil
	m.cleareddevice_updater = false
	m.removeddevice_updater = nil
}

// AddDeviceInstallationCreatorIDs adds the "device_installation_creator" edge to the DeviceInstallation entity by ids.
func (m *AdminMutation) AddDeviceInstallationCreatorIDs(ids ...int) {
	if m.device_installation_creator == nil {
		m.device_installation_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation_creator[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallationCreator clears the "device_installation_creator" edge to the DeviceInstallation entity.
func (m *AdminMutation) ClearDeviceInstallationCreator() {
	m.cleareddevice_installation_creator = true
}

// DeviceInstallationCreatorCleared reports if the "device_installation_creator" edge to the DeviceInstallation entity was cleared.
func (m *AdminMutation) DeviceInstallationCreatorCleared() bool {
	return m.cleareddevice_installation_creator
}

// RemoveDeviceInstallationCreatorIDs removes the "device_installation_creator" edge to the DeviceInstallation entity by IDs.
func (m *AdminMutation) RemoveDeviceInstallationCreatorIDs(ids ...int) {
	if m.removeddevice_installation_creator == nil {
		m.removeddevice_installation_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation_creator, ids[i])
		m.removeddevice_installation_creator[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallationCreator returns the removed IDs of the "device_installation_creator" edge to the DeviceInstallation entity.
func (m *AdminMutation) RemovedDeviceInstallationCreatorIDs() (ids []int) {
	for id := range m.removeddevice_installation_creator {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationCreatorIDs returns the "device_installation_creator" edge IDs in the mutation.
func (m *AdminMutation) DeviceInstallationCreatorIDs() (ids []int) {
	for id := range m.device_installation_creator {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallationCreator resets all changes to the "device_installation_creator" edge.
func (m *AdminMutation) ResetDeviceInstallationCreator() {
	m.device_installation_creator = nil
	m.cleareddevice_installation_creator = false
	m.removeddevice_installation_creator = nil
}

// AddDeviceInstallationUpdaterIDs adds the "device_installation_updater" edge to the DeviceInstallation entity by ids.
func (m *AdminMutation) AddDeviceInstallationUpdaterIDs(ids ...int) {
	if m.device_installation_updater == nil {
		m.device_installation_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation_updater[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallationUpdater clears the "device_installation_updater" edge to the DeviceInstallation entity.
func (m *AdminMutation) ClearDeviceInstallationUpdater() {
	m.cleareddevice_installation_updater = true
}

// DeviceInstallationUpdaterCleared reports if the "device_installation_updater" edge to the DeviceInstallation entity was cleared.
func (m *AdminMutation) DeviceInstallationUpdaterCleared() bool {
	return m.cleareddevice_installation_updater
}

// RemoveDeviceInstallationUpdaterIDs removes the "device_installation_updater" edge to the DeviceInstallation entity by IDs.
func (m *AdminMutation) RemoveDeviceInstallationUpdaterIDs(ids ...int) {
	if m.removeddevice_installation_updater == nil {
		m.removeddevice_installation_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation_updater, ids[i])
		m.removeddevice_installation_updater[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallationUpdater returns the removed IDs of the "device_installation_updater" edge to the DeviceInstallation entity.
func (m *AdminMutation) RemovedDeviceInstallationUpdaterIDs() (ids []int) {
	for id := range m.removeddevice_installation_updater {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationUpdaterIDs returns the "device_installation_updater" edge IDs in the mutation.
func (m *AdminMutation) DeviceInstallationUpdaterIDs() (ids []int) {
	for id := range m.device_installation_updater {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallationUpdater resets all changes to the "device_installation_updater" edge.
func (m *AdminMutation) ResetDeviceInstallationUpdater() {
	m.device_installation_updater = nil
	m.cleareddevice_installation_updater = false
	m.removeddevice_installation_updater = nil
}

// AddEventLevelCreatorIDs adds the "event_level_creator" edge to the EventLevel entity by ids.
func (m *AdminMutation) AddEventLevelCreatorIDs(ids ...int) {
	if m.event_level_creator == nil {
		m.event_level_creator = make(map[int]struct{})
	}
	for i := range ids {
		m.event_level_creator[ids[i]] = struct{}{}
	}
}

// ClearEventLevelCreator clears the "event_level_creator" edge to the EventLevel entity.
func (m *AdminMutation) ClearEventLevelCreator() {
	m.clearedevent_level_creator = true
}

// EventLevelCreatorCleared reports if the "event_level_creator" edge to the EventLevel entity was cleared.
func (m *AdminMutation) EventLevelCreatorCleared() bool {
	return m.clearedevent_level_creator
}

// RemoveEventLevelCreatorIDs removes the "event_level_creator" edge to the EventLevel entity by IDs.
func (m *AdminMutation) RemoveEventLevelCreatorIDs(ids ...int) {
	if m.removedevent_level_creator == nil {
		m.removedevent_level_creator = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_level_creator, ids[i])
		m.removedevent_level_creator[ids[i]] = struct{}{}
	}
}

// RemovedEventLevelCreator returns the removed IDs of the "event_level_creator" edge to the EventLevel entity.
func (m *AdminMutation) RemovedEventLevelCreatorIDs() (ids []int) {
	for id := range m.removedevent_level_creator {
		ids = append(ids, id)
	}
	return
}

// EventLevelCreatorIDs returns the "event_level_creator" edge IDs in the mutation.
func (m *AdminMutation) EventLevelCreatorIDs() (ids []int) {
	for id := range m.event_level_creator {
		ids = append(ids, id)
	}
	return
}

// ResetEventLevelCreator resets all changes to the "event_level_creator" edge.
func (m *AdminMutation) ResetEventLevelCreator() {
	m.event_level_creator = nil
	m.clearedevent_level_creator = false
	m.removedevent_level_creator = nil
}

// AddEventLevelUpdaterIDs adds the "event_level_updater" edge to the EventLevel entity by ids.
func (m *AdminMutation) AddEventLevelUpdaterIDs(ids ...int) {
	if m.event_level_updater == nil {
		m.event_level_updater = make(map[int]struct{})
	}
	for i := range ids {
		m.event_level_updater[ids[i]] = struct{}{}
	}
}

// ClearEventLevelUpdater clears the "event_level_updater" edge to the EventLevel entity.
func (m *AdminMutation) ClearEventLevelUpdater() {
	m.clearedevent_level_updater = true
}

// EventLevelUpdaterCleared reports if the "event_level_updater" edge to the EventLevel entity was cleared.
func (m *AdminMutation) EventLevelUpdaterCleared() bool {
	return m.clearedevent_level_updater
}

// RemoveEventLevelUpdaterIDs removes the "event_level_updater" edge to the EventLevel entity by IDs.
func (m *AdminMutation) RemoveEventLevelUpdaterIDs(ids ...int) {
	if m.removedevent_level_updater == nil {
		m.removedevent_level_updater = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_level_updater, ids[i])
		m.removedevent_level_updater[ids[i]] = struct{}{}
	}
}

// RemovedEventLevelUpdater returns the removed IDs of the "event_level_updater" edge to the EventLevel entity.
func (m *AdminMutation) RemovedEventLevelUpdaterIDs() (ids []int) {
	for id := range m.removedevent_level_updater {
		ids = append(ids, id)
	}
	return
}

// EventLevelUpdaterIDs returns the "event_level_updater" edge IDs in the mutation.
func (m *AdminMutation) EventLevelUpdaterIDs() (ids []int) {
	for id := range m.event_level_updater {
		ids = append(ids, id)
	}
	return
}

// ResetEventLevelUpdater resets all changes to the "event_level_updater" edge.
func (m *AdminMutation) ResetEventLevelUpdater() {
	m.event_level_updater = nil
	m.clearedevent_level_updater = false
	m.removedevent_level_updater = nil
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Admin, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, admin.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, admin.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, admin.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, admin.FieldPassword)
	}
	if m.nickname != nil {
		fields = append(fields, admin.FieldNickname)
	}
	if m.real_name != nil {
		fields = append(fields, admin.FieldRealName)
	}
	if m.avatar != nil {
		fields = append(fields, admin.FieldAvatar)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldCreatedBy:
		return m.CreatedBy()
	case admin.FieldDeletedAt:
		return m.DeletedAt()
	case admin.FieldUpdatedBy:
		return m.UpdatedBy()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	case admin.FieldUsername:
		return m.Username()
	case admin.FieldPassword:
		return m.Password()
	case admin.FieldNickname:
		return m.Nickname()
	case admin.FieldRealName:
		return m.RealName()
	case admin.FieldAvatar:
		return m.Avatar()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case admin.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case admin.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admin.FieldUsername:
		return m.OldUsername(ctx)
	case admin.FieldPassword:
		return m.OldPassword(ctx)
	case admin.FieldNickname:
		return m.OldNickname(ctx)
	case admin.FieldRealName:
		return m.OldRealName(ctx)
	case admin.FieldAvatar:
		return m.OldAvatar(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case admin.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case admin.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admin.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case admin.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case admin.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case admin.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case admin.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldDeletedAt) {
		fields = append(fields, admin.FieldDeletedAt)
	}
	if m.FieldCleared(admin.FieldAvatar) {
		fields = append(fields, admin.FieldAvatar)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case admin.FieldAvatar:
		m.ClearAvatar()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case admin.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case admin.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admin.FieldUsername:
		m.ResetUsername()
		return nil
	case admin.FieldPassword:
		m.ResetPassword()
		return nil
	case admin.FieldNickname:
		m.ResetNickname()
		return nil
	case admin.FieldRealName:
		m.ResetRealName()
		return nil
	case admin.FieldAvatar:
		m.ResetAvatar()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 32)
	if m.creator != nil {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, admin.EdgeUpdater)
	}
	if m.admin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.admin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.admin_updater != nil {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.admin_role_creator != nil {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.admin_role_updater != nil {
		edges = append(edges, admin.EdgeAdminRoleUpdater)
	}
	if m.risk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.risk_updater != nil {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.risk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.risk_location_updater != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.risk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.risk_category_updater != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.department_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.department_updater != nil {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.employee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.employee_updater != nil {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.employee != nil {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.occupation_creator != nil {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.occupation_updater != nil {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.ipc_event_creator != nil {
		edges = append(edges, admin.EdgeIpcEventCreator)
	}
	if m.ipc_event_updater != nil {
		edges = append(edges, admin.EdgeIpcEventUpdater)
	}
	if m.video_creator != nil {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.video_updater != nil {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	if m.area_creator != nil {
		edges = append(edges, admin.EdgeAreaCreator)
	}
	if m.area_updater != nil {
		edges = append(edges, admin.EdgeAreaUpdater)
	}
	if m.device_creator != nil {
		edges = append(edges, admin.EdgeDeviceCreator)
	}
	if m.device_updater != nil {
		edges = append(edges, admin.EdgeDeviceUpdater)
	}
	if m.device_installation_creator != nil {
		edges = append(edges, admin.EdgeDeviceInstallationCreator)
	}
	if m.device_installation_updater != nil {
		edges = append(edges, admin.EdgeDeviceInstallationUpdater)
	}
	if m.event_level_creator != nil {
		edges = append(edges, admin.EdgeEventLevelCreator)
	}
	if m.event_level_updater != nil {
		edges = append(edges, admin.EdgeEventLevelUpdater)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.admin_roles))
		for id := range m.admin_roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.admin_creator))
		for id := range m.admin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdater:
		ids := make([]ent.Value, 0, len(m.admin_updater))
		for id := range m.admin_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleCreator:
		ids := make([]ent.Value, 0, len(m.admin_role_creator))
		for id := range m.admin_role_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleUpdater:
		ids := make([]ent.Value, 0, len(m.admin_role_updater))
		for id := range m.admin_role_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.risk_creator))
		for id := range m.risk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdater:
		ids := make([]ent.Value, 0, len(m.risk_updater))
		for id := range m.risk_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.risk_location_creator))
		for id := range m.risk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdater:
		ids := make([]ent.Value, 0, len(m.risk_location_updater))
		for id := range m.risk_location_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.risk_category_creator))
		for id := range m.risk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdater:
		ids := make([]ent.Value, 0, len(m.risk_category_updater))
		for id := range m.risk_category_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.department_creator))
		for id := range m.department_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdater:
		ids := make([]ent.Value, 0, len(m.department_updater))
		for id := range m.department_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.employee_creator))
		for id := range m.employee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdater:
		ids := make([]ent.Value, 0, len(m.employee_updater))
		for id := range m.employee_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.employee))
		for id := range m.employee {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationCreator:
		ids := make([]ent.Value, 0, len(m.occupation_creator))
		for id := range m.occupation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationUpdater:
		ids := make([]ent.Value, 0, len(m.occupation_updater))
		for id := range m.occupation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcEventCreator:
		ids := make([]ent.Value, 0, len(m.ipc_event_creator))
		for id := range m.ipc_event_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcEventUpdater:
		ids := make([]ent.Value, 0, len(m.ipc_event_updater))
		for id := range m.ipc_event_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoCreator:
		ids := make([]ent.Value, 0, len(m.video_creator))
		for id := range m.video_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoUpdater:
		ids := make([]ent.Value, 0, len(m.video_updater))
		for id := range m.video_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaCreator:
		ids := make([]ent.Value, 0, len(m.area_creator))
		for id := range m.area_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaUpdater:
		ids := make([]ent.Value, 0, len(m.area_updater))
		for id := range m.area_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceCreator:
		ids := make([]ent.Value, 0, len(m.device_creator))
		for id := range m.device_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceUpdater:
		ids := make([]ent.Value, 0, len(m.device_updater))
		for id := range m.device_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationCreator:
		ids := make([]ent.Value, 0, len(m.device_installation_creator))
		for id := range m.device_installation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationUpdater:
		ids := make([]ent.Value, 0, len(m.device_installation_updater))
		for id := range m.device_installation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelCreator:
		ids := make([]ent.Value, 0, len(m.event_level_creator))
		for id := range m.event_level_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelUpdater:
		ids := make([]ent.Value, 0, len(m.event_level_updater))
		for id := range m.event_level_updater {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 32)
	if m.removedadmin_roles != nil {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.removedadmin_creator != nil {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.removedadmin_updater != nil {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.removedadmin_role_creator != nil {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.removedadmin_role_updater != nil {
		edges = append(edges, admin.EdgeAdminRoleUpdater)
	}
	if m.removedrisk_creator != nil {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.removedrisk_updater != nil {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.removedrisk_location_creator != nil {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.removedrisk_location_updater != nil {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.removedrisk_category_creator != nil {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.removedrisk_category_updater != nil {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.removeddepartment_creator != nil {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.removeddepartment_updater != nil {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.removedemployee_creator != nil {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.removedemployee_updater != nil {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.removedemployee != nil {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.removedoccupation_creator != nil {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.removedoccupation_updater != nil {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.removedipc_event_creator != nil {
		edges = append(edges, admin.EdgeIpcEventCreator)
	}
	if m.removedipc_event_updater != nil {
		edges = append(edges, admin.EdgeIpcEventUpdater)
	}
	if m.removedvideo_creator != nil {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.removedvideo_updater != nil {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	if m.removedarea_creator != nil {
		edges = append(edges, admin.EdgeAreaCreator)
	}
	if m.removedarea_updater != nil {
		edges = append(edges, admin.EdgeAreaUpdater)
	}
	if m.removeddevice_creator != nil {
		edges = append(edges, admin.EdgeDeviceCreator)
	}
	if m.removeddevice_updater != nil {
		edges = append(edges, admin.EdgeDeviceUpdater)
	}
	if m.removeddevice_installation_creator != nil {
		edges = append(edges, admin.EdgeDeviceInstallationCreator)
	}
	if m.removeddevice_installation_updater != nil {
		edges = append(edges, admin.EdgeDeviceInstallationUpdater)
	}
	if m.removedevent_level_creator != nil {
		edges = append(edges, admin.EdgeEventLevelCreator)
	}
	if m.removedevent_level_updater != nil {
		edges = append(edges, admin.EdgeEventLevelUpdater)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeAdminRoles:
		ids := make([]ent.Value, 0, len(m.removedadmin_roles))
		for id := range m.removedadmin_roles {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminCreator:
		ids := make([]ent.Value, 0, len(m.removedadmin_creator))
		for id := range m.removedadmin_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminUpdater:
		ids := make([]ent.Value, 0, len(m.removedadmin_updater))
		for id := range m.removedadmin_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleCreator:
		ids := make([]ent.Value, 0, len(m.removedadmin_role_creator))
		for id := range m.removedadmin_role_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAdminRoleUpdater:
		ids := make([]ent.Value, 0, len(m.removedadmin_role_updater))
		for id := range m.removedadmin_role_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_creator))
		for id := range m.removedrisk_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_updater))
		for id := range m.removedrisk_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_creator))
		for id := range m.removedrisk_location_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskLocationUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_location_updater))
		for id := range m.removedrisk_location_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryCreator:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_creator))
		for id := range m.removedrisk_category_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeRiskCategoryUpdater:
		ids := make([]ent.Value, 0, len(m.removedrisk_category_updater))
		for id := range m.removedrisk_category_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentCreator:
		ids := make([]ent.Value, 0, len(m.removeddepartment_creator))
		for id := range m.removeddepartment_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDepartmentUpdater:
		ids := make([]ent.Value, 0, len(m.removeddepartment_updater))
		for id := range m.removeddepartment_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeCreator:
		ids := make([]ent.Value, 0, len(m.removedemployee_creator))
		for id := range m.removedemployee_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployeeUpdater:
		ids := make([]ent.Value, 0, len(m.removedemployee_updater))
		for id := range m.removedemployee_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEmployee:
		ids := make([]ent.Value, 0, len(m.removedemployee))
		for id := range m.removedemployee {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationCreator:
		ids := make([]ent.Value, 0, len(m.removedoccupation_creator))
		for id := range m.removedoccupation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeOccupationUpdater:
		ids := make([]ent.Value, 0, len(m.removedoccupation_updater))
		for id := range m.removedoccupation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcEventCreator:
		ids := make([]ent.Value, 0, len(m.removedipc_event_creator))
		for id := range m.removedipc_event_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeIpcEventUpdater:
		ids := make([]ent.Value, 0, len(m.removedipc_event_updater))
		for id := range m.removedipc_event_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoCreator:
		ids := make([]ent.Value, 0, len(m.removedvideo_creator))
		for id := range m.removedvideo_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeVideoUpdater:
		ids := make([]ent.Value, 0, len(m.removedvideo_updater))
		for id := range m.removedvideo_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaCreator:
		ids := make([]ent.Value, 0, len(m.removedarea_creator))
		for id := range m.removedarea_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeAreaUpdater:
		ids := make([]ent.Value, 0, len(m.removedarea_updater))
		for id := range m.removedarea_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceCreator:
		ids := make([]ent.Value, 0, len(m.removeddevice_creator))
		for id := range m.removeddevice_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceUpdater:
		ids := make([]ent.Value, 0, len(m.removeddevice_updater))
		for id := range m.removeddevice_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationCreator:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation_creator))
		for id := range m.removeddevice_installation_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeDeviceInstallationUpdater:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation_updater))
		for id := range m.removeddevice_installation_updater {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelCreator:
		ids := make([]ent.Value, 0, len(m.removedevent_level_creator))
		for id := range m.removedevent_level_creator {
			ids = append(ids, id)
		}
		return ids
	case admin.EdgeEventLevelUpdater:
		ids := make([]ent.Value, 0, len(m.removedevent_level_updater))
		for id := range m.removedevent_level_updater {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 32)
	if m.clearedcreator {
		edges = append(edges, admin.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, admin.EdgeUpdater)
	}
	if m.clearedadmin_roles {
		edges = append(edges, admin.EdgeAdminRoles)
	}
	if m.clearedadmin_creator {
		edges = append(edges, admin.EdgeAdminCreator)
	}
	if m.clearedadmin_updater {
		edges = append(edges, admin.EdgeAdminUpdater)
	}
	if m.clearedadmin_role_creator {
		edges = append(edges, admin.EdgeAdminRoleCreator)
	}
	if m.clearedadmin_role_updater {
		edges = append(edges, admin.EdgeAdminRoleUpdater)
	}
	if m.clearedrisk_creator {
		edges = append(edges, admin.EdgeRiskCreator)
	}
	if m.clearedrisk_updater {
		edges = append(edges, admin.EdgeRiskUpdater)
	}
	if m.clearedrisk_location_creator {
		edges = append(edges, admin.EdgeRiskLocationCreator)
	}
	if m.clearedrisk_location_updater {
		edges = append(edges, admin.EdgeRiskLocationUpdater)
	}
	if m.clearedrisk_category_creator {
		edges = append(edges, admin.EdgeRiskCategoryCreator)
	}
	if m.clearedrisk_category_updater {
		edges = append(edges, admin.EdgeRiskCategoryUpdater)
	}
	if m.cleareddepartment_creator {
		edges = append(edges, admin.EdgeDepartmentCreator)
	}
	if m.cleareddepartment_updater {
		edges = append(edges, admin.EdgeDepartmentUpdater)
	}
	if m.clearedemployee_creator {
		edges = append(edges, admin.EdgeEmployeeCreator)
	}
	if m.clearedemployee_updater {
		edges = append(edges, admin.EdgeEmployeeUpdater)
	}
	if m.clearedemployee {
		edges = append(edges, admin.EdgeEmployee)
	}
	if m.clearedoccupation_creator {
		edges = append(edges, admin.EdgeOccupationCreator)
	}
	if m.clearedoccupation_updater {
		edges = append(edges, admin.EdgeOccupationUpdater)
	}
	if m.clearedipc_event_creator {
		edges = append(edges, admin.EdgeIpcEventCreator)
	}
	if m.clearedipc_event_updater {
		edges = append(edges, admin.EdgeIpcEventUpdater)
	}
	if m.clearedvideo_creator {
		edges = append(edges, admin.EdgeVideoCreator)
	}
	if m.clearedvideo_updater {
		edges = append(edges, admin.EdgeVideoUpdater)
	}
	if m.clearedarea_creator {
		edges = append(edges, admin.EdgeAreaCreator)
	}
	if m.clearedarea_updater {
		edges = append(edges, admin.EdgeAreaUpdater)
	}
	if m.cleareddevice_creator {
		edges = append(edges, admin.EdgeDeviceCreator)
	}
	if m.cleareddevice_updater {
		edges = append(edges, admin.EdgeDeviceUpdater)
	}
	if m.cleareddevice_installation_creator {
		edges = append(edges, admin.EdgeDeviceInstallationCreator)
	}
	if m.cleareddevice_installation_updater {
		edges = append(edges, admin.EdgeDeviceInstallationUpdater)
	}
	if m.clearedevent_level_creator {
		edges = append(edges, admin.EdgeEventLevelCreator)
	}
	if m.clearedevent_level_updater {
		edges = append(edges, admin.EdgeEventLevelUpdater)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeCreator:
		return m.clearedcreator
	case admin.EdgeUpdater:
		return m.clearedupdater
	case admin.EdgeAdminRoles:
		return m.clearedadmin_roles
	case admin.EdgeAdminCreator:
		return m.clearedadmin_creator
	case admin.EdgeAdminUpdater:
		return m.clearedadmin_updater
	case admin.EdgeAdminRoleCreator:
		return m.clearedadmin_role_creator
	case admin.EdgeAdminRoleUpdater:
		return m.clearedadmin_role_updater
	case admin.EdgeRiskCreator:
		return m.clearedrisk_creator
	case admin.EdgeRiskUpdater:
		return m.clearedrisk_updater
	case admin.EdgeRiskLocationCreator:
		return m.clearedrisk_location_creator
	case admin.EdgeRiskLocationUpdater:
		return m.clearedrisk_location_updater
	case admin.EdgeRiskCategoryCreator:
		return m.clearedrisk_category_creator
	case admin.EdgeRiskCategoryUpdater:
		return m.clearedrisk_category_updater
	case admin.EdgeDepartmentCreator:
		return m.cleareddepartment_creator
	case admin.EdgeDepartmentUpdater:
		return m.cleareddepartment_updater
	case admin.EdgeEmployeeCreator:
		return m.clearedemployee_creator
	case admin.EdgeEmployeeUpdater:
		return m.clearedemployee_updater
	case admin.EdgeEmployee:
		return m.clearedemployee
	case admin.EdgeOccupationCreator:
		return m.clearedoccupation_creator
	case admin.EdgeOccupationUpdater:
		return m.clearedoccupation_updater
	case admin.EdgeIpcEventCreator:
		return m.clearedipc_event_creator
	case admin.EdgeIpcEventUpdater:
		return m.clearedipc_event_updater
	case admin.EdgeVideoCreator:
		return m.clearedvideo_creator
	case admin.EdgeVideoUpdater:
		return m.clearedvideo_updater
	case admin.EdgeAreaCreator:
		return m.clearedarea_creator
	case admin.EdgeAreaUpdater:
		return m.clearedarea_updater
	case admin.EdgeDeviceCreator:
		return m.cleareddevice_creator
	case admin.EdgeDeviceUpdater:
		return m.cleareddevice_updater
	case admin.EdgeDeviceInstallationCreator:
		return m.cleareddevice_installation_creator
	case admin.EdgeDeviceInstallationUpdater:
		return m.cleareddevice_installation_updater
	case admin.EdgeEventLevelCreator:
		return m.clearedevent_level_creator
	case admin.EdgeEventLevelUpdater:
		return m.clearedevent_level_updater
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ClearCreator()
		return nil
	case admin.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeCreator:
		m.ResetCreator()
		return nil
	case admin.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case admin.EdgeAdminRoles:
		m.ResetAdminRoles()
		return nil
	case admin.EdgeAdminCreator:
		m.ResetAdminCreator()
		return nil
	case admin.EdgeAdminUpdater:
		m.ResetAdminUpdater()
		return nil
	case admin.EdgeAdminRoleCreator:
		m.ResetAdminRoleCreator()
		return nil
	case admin.EdgeAdminRoleUpdater:
		m.ResetAdminRoleUpdater()
		return nil
	case admin.EdgeRiskCreator:
		m.ResetRiskCreator()
		return nil
	case admin.EdgeRiskUpdater:
		m.ResetRiskUpdater()
		return nil
	case admin.EdgeRiskLocationCreator:
		m.ResetRiskLocationCreator()
		return nil
	case admin.EdgeRiskLocationUpdater:
		m.ResetRiskLocationUpdater()
		return nil
	case admin.EdgeRiskCategoryCreator:
		m.ResetRiskCategoryCreator()
		return nil
	case admin.EdgeRiskCategoryUpdater:
		m.ResetRiskCategoryUpdater()
		return nil
	case admin.EdgeDepartmentCreator:
		m.ResetDepartmentCreator()
		return nil
	case admin.EdgeDepartmentUpdater:
		m.ResetDepartmentUpdater()
		return nil
	case admin.EdgeEmployeeCreator:
		m.ResetEmployeeCreator()
		return nil
	case admin.EdgeEmployeeUpdater:
		m.ResetEmployeeUpdater()
		return nil
	case admin.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case admin.EdgeOccupationCreator:
		m.ResetOccupationCreator()
		return nil
	case admin.EdgeOccupationUpdater:
		m.ResetOccupationUpdater()
		return nil
	case admin.EdgeIpcEventCreator:
		m.ResetIpcEventCreator()
		return nil
	case admin.EdgeIpcEventUpdater:
		m.ResetIpcEventUpdater()
		return nil
	case admin.EdgeVideoCreator:
		m.ResetVideoCreator()
		return nil
	case admin.EdgeVideoUpdater:
		m.ResetVideoUpdater()
		return nil
	case admin.EdgeAreaCreator:
		m.ResetAreaCreator()
		return nil
	case admin.EdgeAreaUpdater:
		m.ResetAreaUpdater()
		return nil
	case admin.EdgeDeviceCreator:
		m.ResetDeviceCreator()
		return nil
	case admin.EdgeDeviceUpdater:
		m.ResetDeviceUpdater()
		return nil
	case admin.EdgeDeviceInstallationCreator:
		m.ResetDeviceInstallationCreator()
		return nil
	case admin.EdgeDeviceInstallationUpdater:
		m.ResetDeviceInstallationUpdater()
		return nil
	case admin.EdgeEventLevelCreator:
		m.ResetEventLevelCreator()
		return nil
	case admin.EdgeEventLevelUpdater:
		m.ResetEventLevelUpdater()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AdminRoleMutation represents an operation that mutates the AdminRole nodes in the graph.
type AdminRoleMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	name           *string
	deleted_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	admins         map[int]struct{}
	removedadmins  map[int]struct{}
	clearedadmins  bool
	done           bool
	oldValue       func(context.Context) (*AdminRole, error)
	predicates     []predicate.AdminRole
}

var _ ent.Mutation = (*AdminRoleMutation)(nil)

// adminroleOption allows management of the mutation configuration using functional options.
type adminroleOption func(*AdminRoleMutation)

// newAdminRoleMutation creates new mutation for the AdminRole entity.
func newAdminRoleMutation(c config, op Op, opts ...adminroleOption) *AdminRoleMutation {
	m := &AdminRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminRoleID sets the ID field of the mutation.
func withAdminRoleID(id int) adminroleOption {
	return func(m *AdminRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminRole
		)
		m.oldValue = func(ctx context.Context) (*AdminRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminRole sets the old AdminRole of the mutation.
func withAdminRole(node *AdminRole) adminroleOption {
	return func(m *AdminRoleMutation) {
		m.oldValue = func(context.Context) (*AdminRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminRoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminRoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AdminRoleMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AdminRoleMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AdminRoleMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[adminrole.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AdminRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AdminRoleMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, adminrole.FieldCreatedBy)
}

// SetName sets the "name" field.
func (m *AdminRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdminRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdminRoleMutation) ResetName() {
	m.name = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AdminRoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AdminRoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AdminRoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[adminrole.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AdminRoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AdminRoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, adminrole.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AdminRoleMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AdminRoleMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AdminRoleMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[adminrole.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AdminRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[adminrole.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AdminRoleMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, adminrole.FieldUpdatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminRole entity.
// If the AdminRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *AdminRoleMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AdminRoleMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[adminrole.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *AdminRoleMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AdminRoleMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *AdminRoleMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *AdminRoleMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[adminrole.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *AdminRoleMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *AdminRoleMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *AdminRoleMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddAdminIDs adds the "admins" edge to the Admin entity by ids.
func (m *AdminRoleMutation) AddAdminIDs(ids ...int) {
	if m.admins == nil {
		m.admins = make(map[int]struct{})
	}
	for i := range ids {
		m.admins[ids[i]] = struct{}{}
	}
}

// ClearAdmins clears the "admins" edge to the Admin entity.
func (m *AdminRoleMutation) ClearAdmins() {
	m.clearedadmins = true
}

// AdminsCleared reports if the "admins" edge to the Admin entity was cleared.
func (m *AdminRoleMutation) AdminsCleared() bool {
	return m.clearedadmins
}

// RemoveAdminIDs removes the "admins" edge to the Admin entity by IDs.
func (m *AdminRoleMutation) RemoveAdminIDs(ids ...int) {
	if m.removedadmins == nil {
		m.removedadmins = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.admins, ids[i])
		m.removedadmins[ids[i]] = struct{}{}
	}
}

// RemovedAdmins returns the removed IDs of the "admins" edge to the Admin entity.
func (m *AdminRoleMutation) RemovedAdminsIDs() (ids []int) {
	for id := range m.removedadmins {
		ids = append(ids, id)
	}
	return
}

// AdminsIDs returns the "admins" edge IDs in the mutation.
func (m *AdminRoleMutation) AdminsIDs() (ids []int) {
	for id := range m.admins {
		ids = append(ids, id)
	}
	return
}

// ResetAdmins resets all changes to the "admins" edge.
func (m *AdminRoleMutation) ResetAdmins() {
	m.admins = nil
	m.clearedadmins = false
	m.removedadmins = nil
}

// Where appends a list predicates to the AdminRoleMutation builder.
func (m *AdminRoleMutation) Where(ps ...predicate.AdminRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminRole).
func (m *AdminRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminRoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, adminrole.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, adminrole.FieldCreatedBy)
	}
	if m.name != nil {
		fields = append(fields, adminrole.FieldName)
	}
	if m.deleted_at != nil {
		fields = append(fields, adminrole.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, adminrole.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, adminrole.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminrole.FieldCreatedAt:
		return m.CreatedAt()
	case adminrole.FieldCreatedBy:
		return m.CreatedBy()
	case adminrole.FieldName:
		return m.Name()
	case adminrole.FieldDeletedAt:
		return m.DeletedAt()
	case adminrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case adminrole.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case adminrole.FieldName:
		return m.OldName(ctx)
	case adminrole.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case adminrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case adminrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminrole.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case adminrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case adminrole.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case adminrole.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case adminrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminRoleMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminrole.FieldCreatedBy) {
		fields = append(fields, adminrole.FieldCreatedBy)
	}
	if m.FieldCleared(adminrole.FieldDeletedAt) {
		fields = append(fields, adminrole.FieldDeletedAt)
	}
	if m.FieldCleared(adminrole.FieldUpdatedBy) {
		fields = append(fields, adminrole.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminRoleMutation) ClearField(name string) error {
	switch name {
	case adminrole.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case adminrole.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case adminrole.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown AdminRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminRoleMutation) ResetField(name string) error {
	switch name {
	case adminrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case adminrole.FieldName:
		m.ResetName()
		return nil
	case adminrole.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case adminrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case adminrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, adminrole.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, adminrole.EdgeUpdater)
	}
	if m.admins != nil {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case adminrole.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.admins))
		for id := range m.admins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedadmins != nil {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adminrole.EdgeAdmins:
		ids := make([]ent.Value, 0, len(m.removedadmins))
		for id := range m.removedadmins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, adminrole.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, adminrole.EdgeUpdater)
	}
	if m.clearedadmins {
		edges = append(edges, adminrole.EdgeAdmins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case adminrole.EdgeCreator:
		return m.clearedcreator
	case adminrole.EdgeUpdater:
		return m.clearedupdater
	case adminrole.EdgeAdmins:
		return m.clearedadmins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminRoleMutation) ClearEdge(name string) error {
	switch name {
	case adminrole.EdgeCreator:
		m.ClearCreator()
		return nil
	case adminrole.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown AdminRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminRoleMutation) ResetEdge(name string) error {
	switch name {
	case adminrole.EdgeCreator:
		m.ResetCreator()
		return nil
	case adminrole.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case adminrole.EdgeAdmins:
		m.ResetAdmins()
		return nil
	}
	return fmt.Errorf("unknown AdminRole edge %s", name)
}

// AreaMutation represents an operation that mutates the Area nodes in the graph.
type AreaMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	created_at                      *time.Time
	deleted_at                      *time.Time
	updated_at                      *time.Time
	name                            *string
	description                     *string
	clearedFields                   map[string]struct{}
	creator                         *int
	clearedcreator                  bool
	updater                         *int
	clearedupdater                  bool
	device_installation_area        map[int]struct{}
	removeddevice_installation_area map[int]struct{}
	cleareddevice_installation_area bool
	done                            bool
	oldValue                        func(context.Context) (*Area, error)
	predicates                      []predicate.Area
}

var _ ent.Mutation = (*AreaMutation)(nil)

// areaOption allows management of the mutation configuration using functional options.
type areaOption func(*AreaMutation)

// newAreaMutation creates new mutation for the Area entity.
func newAreaMutation(c config, op Op, opts ...areaOption) *AreaMutation {
	m := &AreaMutation{
		config:        c,
		op:            op,
		typ:           TypeArea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAreaID sets the ID field of the mutation.
func withAreaID(id int) areaOption {
	return func(m *AreaMutation) {
		var (
			err   error
			once  sync.Once
			value *Area
		)
		m.oldValue = func(ctx context.Context) (*Area, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Area.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withArea sets the old Area of the mutation.
func withArea(node *Area) areaOption {
	return func(m *AreaMutation) {
		m.oldValue = func(context.Context) (*Area, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AreaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AreaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AreaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AreaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Area.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AreaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AreaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AreaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AreaMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AreaMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AreaMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AreaMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AreaMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AreaMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[area.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AreaMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[area.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AreaMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, area.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AreaMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AreaMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AreaMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AreaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AreaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AreaMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AreaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AreaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AreaMutation) ClearName() {
	m.name = nil
	m.clearedFields[area.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AreaMutation) NameCleared() bool {
	_, ok := m.clearedFields[area.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AreaMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, area.FieldName)
}

// SetDescription sets the "description" field.
func (m *AreaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AreaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Area entity.
// If the Area object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreaMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AreaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[area.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AreaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[area.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AreaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, area.FieldDescription)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *AreaMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *AreaMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[area.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *AreaMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *AreaMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *AreaMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *AreaMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *AreaMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *AreaMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[area.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *AreaMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *AreaMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *AreaMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *AreaMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddDeviceInstallationAreaIDs adds the "device_installation_area" edge to the DeviceInstallation entity by ids.
func (m *AreaMutation) AddDeviceInstallationAreaIDs(ids ...int) {
	if m.device_installation_area == nil {
		m.device_installation_area = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation_area[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallationArea clears the "device_installation_area" edge to the DeviceInstallation entity.
func (m *AreaMutation) ClearDeviceInstallationArea() {
	m.cleareddevice_installation_area = true
}

// DeviceInstallationAreaCleared reports if the "device_installation_area" edge to the DeviceInstallation entity was cleared.
func (m *AreaMutation) DeviceInstallationAreaCleared() bool {
	return m.cleareddevice_installation_area
}

// RemoveDeviceInstallationAreaIDs removes the "device_installation_area" edge to the DeviceInstallation entity by IDs.
func (m *AreaMutation) RemoveDeviceInstallationAreaIDs(ids ...int) {
	if m.removeddevice_installation_area == nil {
		m.removeddevice_installation_area = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation_area, ids[i])
		m.removeddevice_installation_area[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallationArea returns the removed IDs of the "device_installation_area" edge to the DeviceInstallation entity.
func (m *AreaMutation) RemovedDeviceInstallationAreaIDs() (ids []int) {
	for id := range m.removeddevice_installation_area {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationAreaIDs returns the "device_installation_area" edge IDs in the mutation.
func (m *AreaMutation) DeviceInstallationAreaIDs() (ids []int) {
	for id := range m.device_installation_area {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallationArea resets all changes to the "device_installation_area" edge.
func (m *AreaMutation) ResetDeviceInstallationArea() {
	m.device_installation_area = nil
	m.cleareddevice_installation_area = false
	m.removeddevice_installation_area = nil
}

// Where appends a list predicates to the AreaMutation builder.
func (m *AreaMutation) Where(ps ...predicate.Area) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AreaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AreaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Area, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AreaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AreaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Area).
func (m *AreaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AreaMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, area.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, area.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, area.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, area.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, area.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, area.FieldName)
	}
	if m.description != nil {
		fields = append(fields, area.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AreaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case area.FieldCreatedAt:
		return m.CreatedAt()
	case area.FieldCreatedBy:
		return m.CreatedBy()
	case area.FieldDeletedAt:
		return m.DeletedAt()
	case area.FieldUpdatedBy:
		return m.UpdatedBy()
	case area.FieldUpdatedAt:
		return m.UpdatedAt()
	case area.FieldName:
		return m.Name()
	case area.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AreaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case area.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case area.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case area.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case area.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case area.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case area.FieldName:
		return m.OldName(ctx)
	case area.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Area field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case area.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case area.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case area.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case area.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case area.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case area.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case area.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AreaMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AreaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Area numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AreaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(area.FieldDeletedAt) {
		fields = append(fields, area.FieldDeletedAt)
	}
	if m.FieldCleared(area.FieldName) {
		fields = append(fields, area.FieldName)
	}
	if m.FieldCleared(area.FieldDescription) {
		fields = append(fields, area.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AreaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AreaMutation) ClearField(name string) error {
	switch name {
	case area.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case area.FieldName:
		m.ClearName()
		return nil
	case area.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Area nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AreaMutation) ResetField(name string) error {
	switch name {
	case area.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case area.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case area.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case area.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case area.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case area.FieldName:
		m.ResetName()
		return nil
	case area.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Area field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AreaMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, area.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, area.EdgeUpdater)
	}
	if m.device_installation_area != nil {
		edges = append(edges, area.EdgeDeviceInstallationArea)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AreaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case area.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case area.EdgeDeviceInstallationArea:
		ids := make([]ent.Value, 0, len(m.device_installation_area))
		for id := range m.device_installation_area {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AreaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddevice_installation_area != nil {
		edges = append(edges, area.EdgeDeviceInstallationArea)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AreaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case area.EdgeDeviceInstallationArea:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation_area))
		for id := range m.removeddevice_installation_area {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AreaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, area.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, area.EdgeUpdater)
	}
	if m.cleareddevice_installation_area {
		edges = append(edges, area.EdgeDeviceInstallationArea)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AreaMutation) EdgeCleared(name string) bool {
	switch name {
	case area.EdgeCreator:
		return m.clearedcreator
	case area.EdgeUpdater:
		return m.clearedupdater
	case area.EdgeDeviceInstallationArea:
		return m.cleareddevice_installation_area
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AreaMutation) ClearEdge(name string) error {
	switch name {
	case area.EdgeCreator:
		m.ClearCreator()
		return nil
	case area.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Area unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AreaMutation) ResetEdge(name string) error {
	switch name {
	case area.EdgeCreator:
		m.ResetCreator()
		return nil
	case area.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case area.EdgeDeviceInstallationArea:
		m.ResetDeviceInstallationArea()
		return nil
	}
	return fmt.Errorf("unknown Area edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	deleted_at       *time.Time
	updated_at       *time.Time
	name             *string
	clearedFields    map[string]struct{}
	creator          *int
	clearedcreator   bool
	updater          *int
	clearedupdater   bool
	parent           *int
	clearedparent    bool
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	clearedemployees bool
	children         map[int]struct{}
	removedchildren  map[int]struct{}
	clearedchildren  bool
	done             bool
	oldValue         func(context.Context) (*Department, error)
	predicates       []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DepartmentMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DepartmentMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DepartmentMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DepartmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DepartmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DepartmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[department.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DepartmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DepartmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, department.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DepartmentMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DepartmentMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DepartmentMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, department.FieldParentID)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *DepartmentMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DepartmentMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[department.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DepartmentMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *DepartmentMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DepartmentMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *DepartmentMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *DepartmentMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[department.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *DepartmentMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *DepartmentMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *DepartmentMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *DepartmentMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *DepartmentMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *DepartmentMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *DepartmentMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *DepartmentMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *DepartmentMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *DepartmentMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, department.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, department.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.parent != nil {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldCreatedBy:
		return m.CreatedBy()
	case department.FieldDeletedAt:
		return m.DeletedAt()
	case department.FieldUpdatedBy:
		return m.UpdatedBy()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	case department.FieldName:
		return m.Name()
	case department.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case department.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case department.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case department.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case department.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDeletedAt) {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case department.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case department.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, department.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, department.EdgeUpdater)
	}
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.employees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedemployees != nil {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, department.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, department.EdgeUpdater)
	}
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedemployees {
		edges = append(edges, department.EdgeEmployees)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeCreator:
		return m.clearedcreator
	case department.EdgeUpdater:
		return m.clearedupdater
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeEmployees:
		return m.clearedemployees
	case department.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ClearCreator()
		return nil
	case department.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case department.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeCreator:
		m.ResetCreator()
		return nil
	case department.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeEmployees:
		m.ResetEmployees()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	created_at                        *time.Time
	deleted_at                        *time.Time
	updated_at                        *time.Time
	brand                             *enums.DeviceBrand
	addbrand                          *enums.DeviceBrand
	model                             *enums.DeviceModel
	addmodel                          *enums.DeviceModel
	name                              *string
	sn                                *string
	device_type                       *enums.DeviceType
	adddevice_type                    *enums.DeviceType
	clearedFields                     map[string]struct{}
	creator                           *int
	clearedcreator                    bool
	updater                           *int
	clearedupdater                    bool
	ipc_event_device                  map[int]struct{}
	removedipc_event_device           map[int]struct{}
	clearedipc_event_device           bool
	device_installation_device        map[int]struct{}
	removeddevice_installation_device map[int]struct{}
	cleareddevice_installation_device bool
	done                              bool
	oldValue                          func(context.Context) (*Device, error)
	predicates                        []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id int) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[device.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[device.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, device.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBrand sets the "brand" field.
func (m *DeviceMutation) SetBrand(eb enums.DeviceBrand) {
	m.brand = &eb
	m.addbrand = nil
}

// Brand returns the value of the "brand" field in the mutation.
func (m *DeviceMutation) Brand() (r enums.DeviceBrand, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldBrand(ctx context.Context) (v enums.DeviceBrand, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// AddBrand adds eb to the "brand" field.
func (m *DeviceMutation) AddBrand(eb enums.DeviceBrand) {
	if m.addbrand != nil {
		*m.addbrand += eb
	} else {
		m.addbrand = &eb
	}
}

// AddedBrand returns the value that was added to the "brand" field in this mutation.
func (m *DeviceMutation) AddedBrand() (r enums.DeviceBrand, exists bool) {
	v := m.addbrand
	if v == nil {
		return
	}
	return *v, true
}

// ClearBrand clears the value of the "brand" field.
func (m *DeviceMutation) ClearBrand() {
	m.brand = nil
	m.addbrand = nil
	m.clearedFields[device.FieldBrand] = struct{}{}
}

// BrandCleared returns if the "brand" field was cleared in this mutation.
func (m *DeviceMutation) BrandCleared() bool {
	_, ok := m.clearedFields[device.FieldBrand]
	return ok
}

// ResetBrand resets all changes to the "brand" field.
func (m *DeviceMutation) ResetBrand() {
	m.brand = nil
	m.addbrand = nil
	delete(m.clearedFields, device.FieldBrand)
}

// SetModel sets the "model" field.
func (m *DeviceMutation) SetModel(em enums.DeviceModel) {
	m.model = &em
	m.addmodel = nil
}

// Model returns the value of the "model" field in the mutation.
func (m *DeviceMutation) Model() (r enums.DeviceModel, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldModel(ctx context.Context) (v enums.DeviceModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// AddModel adds em to the "model" field.
func (m *DeviceMutation) AddModel(em enums.DeviceModel) {
	if m.addmodel != nil {
		*m.addmodel += em
	} else {
		m.addmodel = &em
	}
}

// AddedModel returns the value that was added to the "model" field in this mutation.
func (m *DeviceMutation) AddedModel() (r enums.DeviceModel, exists bool) {
	v := m.addmodel
	if v == nil {
		return
	}
	return *v, true
}

// ClearModel clears the value of the "model" field.
func (m *DeviceMutation) ClearModel() {
	m.model = nil
	m.addmodel = nil
	m.clearedFields[device.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *DeviceMutation) ModelCleared() bool {
	_, ok := m.clearedFields[device.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *DeviceMutation) ResetModel() {
	m.model = nil
	m.addmodel = nil
	delete(m.clearedFields, device.FieldModel)
}

// SetName sets the "name" field.
func (m *DeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *DeviceMutation) ClearName() {
	m.name = nil
	m.clearedFields[device.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *DeviceMutation) NameCleared() bool {
	_, ok := m.clearedFields[device.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *DeviceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, device.FieldName)
}

// SetSn sets the "sn" field.
func (m *DeviceMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *DeviceMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *DeviceMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[device.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *DeviceMutation) SnCleared() bool {
	_, ok := m.clearedFields[device.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *DeviceMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, device.FieldSn)
}

// SetDeviceType sets the "device_type" field.
func (m *DeviceMutation) SetDeviceType(et enums.DeviceType) {
	m.device_type = &et
	m.adddevice_type = nil
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *DeviceMutation) DeviceType() (r enums.DeviceType, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceType(ctx context.Context) (v enums.DeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// AddDeviceType adds et to the "device_type" field.
func (m *DeviceMutation) AddDeviceType(et enums.DeviceType) {
	if m.adddevice_type != nil {
		*m.adddevice_type += et
	} else {
		m.adddevice_type = &et
	}
}

// AddedDeviceType returns the value that was added to the "device_type" field in this mutation.
func (m *DeviceMutation) AddedDeviceType() (r enums.DeviceType, exists bool) {
	v := m.adddevice_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *DeviceMutation) ResetDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *DeviceMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DeviceMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[device.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DeviceMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *DeviceMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DeviceMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *DeviceMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *DeviceMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[device.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *DeviceMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *DeviceMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *DeviceMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddIpcEventDeviceIDs adds the "ipc_event_device" edge to the IPCEvent entity by ids.
func (m *DeviceMutation) AddIpcEventDeviceIDs(ids ...int) {
	if m.ipc_event_device == nil {
		m.ipc_event_device = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_event_device[ids[i]] = struct{}{}
	}
}

// ClearIpcEventDevice clears the "ipc_event_device" edge to the IPCEvent entity.
func (m *DeviceMutation) ClearIpcEventDevice() {
	m.clearedipc_event_device = true
}

// IpcEventDeviceCleared reports if the "ipc_event_device" edge to the IPCEvent entity was cleared.
func (m *DeviceMutation) IpcEventDeviceCleared() bool {
	return m.clearedipc_event_device
}

// RemoveIpcEventDeviceIDs removes the "ipc_event_device" edge to the IPCEvent entity by IDs.
func (m *DeviceMutation) RemoveIpcEventDeviceIDs(ids ...int) {
	if m.removedipc_event_device == nil {
		m.removedipc_event_device = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_event_device, ids[i])
		m.removedipc_event_device[ids[i]] = struct{}{}
	}
}

// RemovedIpcEventDevice returns the removed IDs of the "ipc_event_device" edge to the IPCEvent entity.
func (m *DeviceMutation) RemovedIpcEventDeviceIDs() (ids []int) {
	for id := range m.removedipc_event_device {
		ids = append(ids, id)
	}
	return
}

// IpcEventDeviceIDs returns the "ipc_event_device" edge IDs in the mutation.
func (m *DeviceMutation) IpcEventDeviceIDs() (ids []int) {
	for id := range m.ipc_event_device {
		ids = append(ids, id)
	}
	return
}

// ResetIpcEventDevice resets all changes to the "ipc_event_device" edge.
func (m *DeviceMutation) ResetIpcEventDevice() {
	m.ipc_event_device = nil
	m.clearedipc_event_device = false
	m.removedipc_event_device = nil
}

// AddDeviceInstallationDeviceIDs adds the "device_installation_device" edge to the DeviceInstallation entity by ids.
func (m *DeviceMutation) AddDeviceInstallationDeviceIDs(ids ...int) {
	if m.device_installation_device == nil {
		m.device_installation_device = make(map[int]struct{})
	}
	for i := range ids {
		m.device_installation_device[ids[i]] = struct{}{}
	}
}

// ClearDeviceInstallationDevice clears the "device_installation_device" edge to the DeviceInstallation entity.
func (m *DeviceMutation) ClearDeviceInstallationDevice() {
	m.cleareddevice_installation_device = true
}

// DeviceInstallationDeviceCleared reports if the "device_installation_device" edge to the DeviceInstallation entity was cleared.
func (m *DeviceMutation) DeviceInstallationDeviceCleared() bool {
	return m.cleareddevice_installation_device
}

// RemoveDeviceInstallationDeviceIDs removes the "device_installation_device" edge to the DeviceInstallation entity by IDs.
func (m *DeviceMutation) RemoveDeviceInstallationDeviceIDs(ids ...int) {
	if m.removeddevice_installation_device == nil {
		m.removeddevice_installation_device = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.device_installation_device, ids[i])
		m.removeddevice_installation_device[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInstallationDevice returns the removed IDs of the "device_installation_device" edge to the DeviceInstallation entity.
func (m *DeviceMutation) RemovedDeviceInstallationDeviceIDs() (ids []int) {
	for id := range m.removeddevice_installation_device {
		ids = append(ids, id)
	}
	return
}

// DeviceInstallationDeviceIDs returns the "device_installation_device" edge IDs in the mutation.
func (m *DeviceMutation) DeviceInstallationDeviceIDs() (ids []int) {
	for id := range m.device_installation_device {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInstallationDevice resets all changes to the "device_installation_device" edge.
func (m *DeviceMutation) ResetDeviceInstallationDevice() {
	m.device_installation_device = nil
	m.cleareddevice_installation_device = false
	m.removeddevice_installation_device = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, device.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, device.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.brand != nil {
		fields = append(fields, device.FieldBrand)
	}
	if m.model != nil {
		fields = append(fields, device.FieldModel)
	}
	if m.name != nil {
		fields = append(fields, device.FieldName)
	}
	if m.sn != nil {
		fields = append(fields, device.FieldSn)
	}
	if m.device_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreatedAt:
		return m.CreatedAt()
	case device.FieldCreatedBy:
		return m.CreatedBy()
	case device.FieldDeletedAt:
		return m.DeletedAt()
	case device.FieldUpdatedBy:
		return m.UpdatedBy()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldBrand:
		return m.Brand()
	case device.FieldModel:
		return m.Model()
	case device.FieldName:
		return m.Name()
	case device.FieldSn:
		return m.Sn()
	case device.FieldDeviceType:
		return m.DeviceType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case device.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case device.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case device.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldBrand:
		return m.OldBrand(ctx)
	case device.FieldModel:
		return m.OldModel(ctx)
	case device.FieldName:
		return m.OldName(ctx)
	case device.FieldSn:
		return m.OldSn(ctx)
	case device.FieldDeviceType:
		return m.OldDeviceType(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case device.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case device.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case device.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldBrand:
		v, ok := value.(enums.DeviceBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case device.FieldModel:
		v, ok := value.(enums.DeviceModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case device.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case device.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(enums.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	if m.addbrand != nil {
		fields = append(fields, device.FieldBrand)
	}
	if m.addmodel != nil {
		fields = append(fields, device.FieldModel)
	}
	if m.adddevice_type != nil {
		fields = append(fields, device.FieldDeviceType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case device.FieldBrand:
		return m.AddedBrand()
	case device.FieldModel:
		return m.AddedModel()
	case device.FieldDeviceType:
		return m.AddedDeviceType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case device.FieldBrand:
		v, ok := value.(enums.DeviceBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBrand(v)
		return nil
	case device.FieldModel:
		v, ok := value.(enums.DeviceModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddModel(v)
		return nil
	case device.FieldDeviceType:
		v, ok := value.(enums.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceType(v)
		return nil
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldDeletedAt) {
		fields = append(fields, device.FieldDeletedAt)
	}
	if m.FieldCleared(device.FieldBrand) {
		fields = append(fields, device.FieldBrand)
	}
	if m.FieldCleared(device.FieldModel) {
		fields = append(fields, device.FieldModel)
	}
	if m.FieldCleared(device.FieldName) {
		fields = append(fields, device.FieldName)
	}
	if m.FieldCleared(device.FieldSn) {
		fields = append(fields, device.FieldSn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case device.FieldBrand:
		m.ClearBrand()
		return nil
	case device.FieldModel:
		m.ClearModel()
		return nil
	case device.FieldName:
		m.ClearName()
		return nil
	case device.FieldSn:
		m.ClearSn()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case device.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case device.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case device.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldBrand:
		m.ResetBrand()
		return nil
	case device.FieldModel:
		m.ResetModel()
		return nil
	case device.FieldName:
		m.ResetName()
		return nil
	case device.FieldSn:
		m.ResetSn()
		return nil
	case device.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, device.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, device.EdgeUpdater)
	}
	if m.ipc_event_device != nil {
		edges = append(edges, device.EdgeIpcEventDevice)
	}
	if m.device_installation_device != nil {
		edges = append(edges, device.EdgeDeviceInstallationDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case device.EdgeIpcEventDevice:
		ids := make([]ent.Value, 0, len(m.ipc_event_device))
		for id := range m.ipc_event_device {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceInstallationDevice:
		ids := make([]ent.Value, 0, len(m.device_installation_device))
		for id := range m.device_installation_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedipc_event_device != nil {
		edges = append(edges, device.EdgeIpcEventDevice)
	}
	if m.removeddevice_installation_device != nil {
		edges = append(edges, device.EdgeDeviceInstallationDevice)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeIpcEventDevice:
		ids := make([]ent.Value, 0, len(m.removedipc_event_device))
		for id := range m.removedipc_event_device {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeDeviceInstallationDevice:
		ids := make([]ent.Value, 0, len(m.removeddevice_installation_device))
		for id := range m.removeddevice_installation_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, device.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, device.EdgeUpdater)
	}
	if m.clearedipc_event_device {
		edges = append(edges, device.EdgeIpcEventDevice)
	}
	if m.cleareddevice_installation_device {
		edges = append(edges, device.EdgeDeviceInstallationDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeCreator:
		return m.clearedcreator
	case device.EdgeUpdater:
		return m.clearedupdater
	case device.EdgeIpcEventDevice:
		return m.clearedipc_event_device
	case device.EdgeDeviceInstallationDevice:
		return m.cleareddevice_installation_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeCreator:
		m.ClearCreator()
		return nil
	case device.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeCreator:
		m.ResetCreator()
		return nil
	case device.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case device.EdgeIpcEventDevice:
		m.ResetIpcEventDevice()
		return nil
	case device.EdgeDeviceInstallationDevice:
		m.ResetDeviceInstallationDevice()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// DeviceInstallationMutation represents an operation that mutates the DeviceInstallation nodes in the graph.
type DeviceInstallationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	deleted_at     *time.Time
	updated_at     *time.Time
	alias_name     *string
	longitude      *float64
	addlongitude   *float64
	latitude       *float64
	addlatitude    *float64
	location_data  *string
	location       *string
	installer      *string
	install_time   *time.Time
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	area           *int
	clearedarea    bool
	device         *int
	cleareddevice  bool
	done           bool
	oldValue       func(context.Context) (*DeviceInstallation, error)
	predicates     []predicate.DeviceInstallation
}

var _ ent.Mutation = (*DeviceInstallationMutation)(nil)

// deviceinstallationOption allows management of the mutation configuration using functional options.
type deviceinstallationOption func(*DeviceInstallationMutation)

// newDeviceInstallationMutation creates new mutation for the DeviceInstallation entity.
func newDeviceInstallationMutation(c config, op Op, opts ...deviceinstallationOption) *DeviceInstallationMutation {
	m := &DeviceInstallationMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInstallation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInstallationID sets the ID field of the mutation.
func withDeviceInstallationID(id int) deviceinstallationOption {
	return func(m *DeviceInstallationMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInstallation
		)
		m.oldValue = func(ctx context.Context) (*DeviceInstallation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInstallation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInstallation sets the old DeviceInstallation of the mutation.
func withDeviceInstallation(node *DeviceInstallation) deviceinstallationOption {
	return func(m *DeviceInstallationMutation) {
		m.oldValue = func(context.Context) (*DeviceInstallation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInstallationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInstallationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInstallationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInstallationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInstallation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInstallationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInstallationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInstallationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DeviceInstallationMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DeviceInstallationMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DeviceInstallationMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DeviceInstallationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DeviceInstallationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DeviceInstallationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[deviceinstallation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DeviceInstallationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DeviceInstallationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, deviceinstallation.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DeviceInstallationMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DeviceInstallationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DeviceInstallationMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInstallationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInstallationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInstallationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *DeviceInstallationMutation) SetDeviceID(i int) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *DeviceInstallationMutation) DeviceID() (r int, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldDeviceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *DeviceInstallationMutation) ResetDeviceID() {
	m.device = nil
}

// SetAreaID sets the "area_id" field.
func (m *DeviceInstallationMutation) SetAreaID(i int) {
	m.area = &i
}

// AreaID returns the value of the "area_id" field in the mutation.
func (m *DeviceInstallationMutation) AreaID() (r int, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaID returns the old "area_id" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldAreaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaID: %w", err)
	}
	return oldValue.AreaID, nil
}

// ResetAreaID resets all changes to the "area_id" field.
func (m *DeviceInstallationMutation) ResetAreaID() {
	m.area = nil
}

// SetAliasName sets the "alias_name" field.
func (m *DeviceInstallationMutation) SetAliasName(s string) {
	m.alias_name = &s
}

// AliasName returns the value of the "alias_name" field in the mutation.
func (m *DeviceInstallationMutation) AliasName() (r string, exists bool) {
	v := m.alias_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAliasName returns the old "alias_name" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldAliasName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAliasName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAliasName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAliasName: %w", err)
	}
	return oldValue.AliasName, nil
}

// ClearAliasName clears the value of the "alias_name" field.
func (m *DeviceInstallationMutation) ClearAliasName() {
	m.alias_name = nil
	m.clearedFields[deviceinstallation.FieldAliasName] = struct{}{}
}

// AliasNameCleared returns if the "alias_name" field was cleared in this mutation.
func (m *DeviceInstallationMutation) AliasNameCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldAliasName]
	return ok
}

// ResetAliasName resets all changes to the "alias_name" field.
func (m *DeviceInstallationMutation) ResetAliasName() {
	m.alias_name = nil
	delete(m.clearedFields, deviceinstallation.FieldAliasName)
}

// SetLongitude sets the "longitude" field.
func (m *DeviceInstallationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *DeviceInstallationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *DeviceInstallationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *DeviceInstallationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *DeviceInstallationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetLatitude sets the "latitude" field.
func (m *DeviceInstallationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *DeviceInstallationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *DeviceInstallationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *DeviceInstallationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *DeviceInstallationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLocationData sets the "location_data" field.
func (m *DeviceInstallationMutation) SetLocationData(s string) {
	m.location_data = &s
}

// LocationData returns the value of the "location_data" field in the mutation.
func (m *DeviceInstallationMutation) LocationData() (r string, exists bool) {
	v := m.location_data
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationData returns the old "location_data" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLocationData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationData: %w", err)
	}
	return oldValue.LocationData, nil
}

// ClearLocationData clears the value of the "location_data" field.
func (m *DeviceInstallationMutation) ClearLocationData() {
	m.location_data = nil
	m.clearedFields[deviceinstallation.FieldLocationData] = struct{}{}
}

// LocationDataCleared returns if the "location_data" field was cleared in this mutation.
func (m *DeviceInstallationMutation) LocationDataCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldLocationData]
	return ok
}

// ResetLocationData resets all changes to the "location_data" field.
func (m *DeviceInstallationMutation) ResetLocationData() {
	m.location_data = nil
	delete(m.clearedFields, deviceinstallation.FieldLocationData)
}

// SetLocation sets the "location" field.
func (m *DeviceInstallationMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *DeviceInstallationMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *DeviceInstallationMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[deviceinstallation.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *DeviceInstallationMutation) LocationCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *DeviceInstallationMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, deviceinstallation.FieldLocation)
}

// SetInstaller sets the "installer" field.
func (m *DeviceInstallationMutation) SetInstaller(s string) {
	m.installer = &s
}

// Installer returns the value of the "installer" field in the mutation.
func (m *DeviceInstallationMutation) Installer() (r string, exists bool) {
	v := m.installer
	if v == nil {
		return
	}
	return *v, true
}

// OldInstaller returns the old "installer" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldInstaller(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstaller is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstaller requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstaller: %w", err)
	}
	return oldValue.Installer, nil
}

// ClearInstaller clears the value of the "installer" field.
func (m *DeviceInstallationMutation) ClearInstaller() {
	m.installer = nil
	m.clearedFields[deviceinstallation.FieldInstaller] = struct{}{}
}

// InstallerCleared returns if the "installer" field was cleared in this mutation.
func (m *DeviceInstallationMutation) InstallerCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldInstaller]
	return ok
}

// ResetInstaller resets all changes to the "installer" field.
func (m *DeviceInstallationMutation) ResetInstaller() {
	m.installer = nil
	delete(m.clearedFields, deviceinstallation.FieldInstaller)
}

// SetInstallTime sets the "install_time" field.
func (m *DeviceInstallationMutation) SetInstallTime(t time.Time) {
	m.install_time = &t
}

// InstallTime returns the value of the "install_time" field in the mutation.
func (m *DeviceInstallationMutation) InstallTime() (r time.Time, exists bool) {
	v := m.install_time
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallTime returns the old "install_time" field's value of the DeviceInstallation entity.
// If the DeviceInstallation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInstallationMutation) OldInstallTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallTime: %w", err)
	}
	return oldValue.InstallTime, nil
}

// ClearInstallTime clears the value of the "install_time" field.
func (m *DeviceInstallationMutation) ClearInstallTime() {
	m.install_time = nil
	m.clearedFields[deviceinstallation.FieldInstallTime] = struct{}{}
}

// InstallTimeCleared returns if the "install_time" field was cleared in this mutation.
func (m *DeviceInstallationMutation) InstallTimeCleared() bool {
	_, ok := m.clearedFields[deviceinstallation.FieldInstallTime]
	return ok
}

// ResetInstallTime resets all changes to the "install_time" field.
func (m *DeviceInstallationMutation) ResetInstallTime() {
	m.install_time = nil
	delete(m.clearedFields, deviceinstallation.FieldInstallTime)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *DeviceInstallationMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *DeviceInstallationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[deviceinstallation.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *DeviceInstallationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *DeviceInstallationMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *DeviceInstallationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *DeviceInstallationMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *DeviceInstallationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[deviceinstallation.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *DeviceInstallationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *DeviceInstallationMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *DeviceInstallationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearArea clears the "area" edge to the Area entity.
func (m *DeviceInstallationMutation) ClearArea() {
	m.clearedarea = true
	m.clearedFields[deviceinstallation.FieldAreaID] = struct{}{}
}

// AreaCleared reports if the "area" edge to the Area entity was cleared.
func (m *DeviceInstallationMutation) AreaCleared() bool {
	return m.clearedarea
}

// AreaIDs returns the "area" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AreaID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) AreaIDs() (ids []int) {
	if id := m.area; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArea resets all changes to the "area" edge.
func (m *DeviceInstallationMutation) ResetArea() {
	m.area = nil
	m.clearedarea = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *DeviceInstallationMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[deviceinstallation.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *DeviceInstallationMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *DeviceInstallationMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *DeviceInstallationMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the DeviceInstallationMutation builder.
func (m *DeviceInstallationMutation) Where(ps ...predicate.DeviceInstallation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInstallationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInstallationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInstallation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInstallationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInstallationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInstallation).
func (m *DeviceInstallationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInstallationMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, deviceinstallation.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, deviceinstallation.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, deviceinstallation.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, deviceinstallation.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinstallation.FieldUpdatedAt)
	}
	if m.device != nil {
		fields = append(fields, deviceinstallation.FieldDeviceID)
	}
	if m.area != nil {
		fields = append(fields, deviceinstallation.FieldAreaID)
	}
	if m.alias_name != nil {
		fields = append(fields, deviceinstallation.FieldAliasName)
	}
	if m.longitude != nil {
		fields = append(fields, deviceinstallation.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, deviceinstallation.FieldLatitude)
	}
	if m.location_data != nil {
		fields = append(fields, deviceinstallation.FieldLocationData)
	}
	if m.location != nil {
		fields = append(fields, deviceinstallation.FieldLocation)
	}
	if m.installer != nil {
		fields = append(fields, deviceinstallation.FieldInstaller)
	}
	if m.install_time != nil {
		fields = append(fields, deviceinstallation.FieldInstallTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInstallationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinstallation.FieldCreatedAt:
		return m.CreatedAt()
	case deviceinstallation.FieldCreatedBy:
		return m.CreatedBy()
	case deviceinstallation.FieldDeletedAt:
		return m.DeletedAt()
	case deviceinstallation.FieldUpdatedBy:
		return m.UpdatedBy()
	case deviceinstallation.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceinstallation.FieldDeviceID:
		return m.DeviceID()
	case deviceinstallation.FieldAreaID:
		return m.AreaID()
	case deviceinstallation.FieldAliasName:
		return m.AliasName()
	case deviceinstallation.FieldLongitude:
		return m.Longitude()
	case deviceinstallation.FieldLatitude:
		return m.Latitude()
	case deviceinstallation.FieldLocationData:
		return m.LocationData()
	case deviceinstallation.FieldLocation:
		return m.Location()
	case deviceinstallation.FieldInstaller:
		return m.Installer()
	case deviceinstallation.FieldInstallTime:
		return m.InstallTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInstallationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinstallation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deviceinstallation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case deviceinstallation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case deviceinstallation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case deviceinstallation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceinstallation.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case deviceinstallation.FieldAreaID:
		return m.OldAreaID(ctx)
	case deviceinstallation.FieldAliasName:
		return m.OldAliasName(ctx)
	case deviceinstallation.FieldLongitude:
		return m.OldLongitude(ctx)
	case deviceinstallation.FieldLatitude:
		return m.OldLatitude(ctx)
	case deviceinstallation.FieldLocationData:
		return m.OldLocationData(ctx)
	case deviceinstallation.FieldLocation:
		return m.OldLocation(ctx)
	case deviceinstallation.FieldInstaller:
		return m.OldInstaller(ctx)
	case deviceinstallation.FieldInstallTime:
		return m.OldInstallTime(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInstallation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInstallationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinstallation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deviceinstallation.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case deviceinstallation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case deviceinstallation.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case deviceinstallation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceinstallation.FieldDeviceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case deviceinstallation.FieldAreaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaID(v)
		return nil
	case deviceinstallation.FieldAliasName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAliasName(v)
		return nil
	case deviceinstallation.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case deviceinstallation.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case deviceinstallation.FieldLocationData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationData(v)
		return nil
	case deviceinstallation.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case deviceinstallation.FieldInstaller:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstaller(v)
		return nil
	case deviceinstallation.FieldInstallTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallTime(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInstallationMutation) AddedFields() []string {
	var fields []string
	if m.addlongitude != nil {
		fields = append(fields, deviceinstallation.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, deviceinstallation.FieldLatitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInstallationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deviceinstallation.FieldLongitude:
		return m.AddedLongitude()
	case deviceinstallation.FieldLatitude:
		return m.AddedLatitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInstallationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deviceinstallation.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case deviceinstallation.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInstallationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deviceinstallation.FieldDeletedAt) {
		fields = append(fields, deviceinstallation.FieldDeletedAt)
	}
	if m.FieldCleared(deviceinstallation.FieldAliasName) {
		fields = append(fields, deviceinstallation.FieldAliasName)
	}
	if m.FieldCleared(deviceinstallation.FieldLocationData) {
		fields = append(fields, deviceinstallation.FieldLocationData)
	}
	if m.FieldCleared(deviceinstallation.FieldLocation) {
		fields = append(fields, deviceinstallation.FieldLocation)
	}
	if m.FieldCleared(deviceinstallation.FieldInstaller) {
		fields = append(fields, deviceinstallation.FieldInstaller)
	}
	if m.FieldCleared(deviceinstallation.FieldInstallTime) {
		fields = append(fields, deviceinstallation.FieldInstallTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInstallationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInstallationMutation) ClearField(name string) error {
	switch name {
	case deviceinstallation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case deviceinstallation.FieldAliasName:
		m.ClearAliasName()
		return nil
	case deviceinstallation.FieldLocationData:
		m.ClearLocationData()
		return nil
	case deviceinstallation.FieldLocation:
		m.ClearLocation()
		return nil
	case deviceinstallation.FieldInstaller:
		m.ClearInstaller()
		return nil
	case deviceinstallation.FieldInstallTime:
		m.ClearInstallTime()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInstallationMutation) ResetField(name string) error {
	switch name {
	case deviceinstallation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deviceinstallation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case deviceinstallation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case deviceinstallation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case deviceinstallation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceinstallation.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case deviceinstallation.FieldAreaID:
		m.ResetAreaID()
		return nil
	case deviceinstallation.FieldAliasName:
		m.ResetAliasName()
		return nil
	case deviceinstallation.FieldLongitude:
		m.ResetLongitude()
		return nil
	case deviceinstallation.FieldLatitude:
		m.ResetLatitude()
		return nil
	case deviceinstallation.FieldLocationData:
		m.ResetLocationData()
		return nil
	case deviceinstallation.FieldLocation:
		m.ResetLocation()
		return nil
	case deviceinstallation.FieldInstaller:
		m.ResetInstaller()
		return nil
	case deviceinstallation.FieldInstallTime:
		m.ResetInstallTime()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInstallationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, deviceinstallation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, deviceinstallation.EdgeUpdater)
	}
	if m.area != nil {
		edges = append(edges, deviceinstallation.EdgeArea)
	}
	if m.device != nil {
		edges = append(edges, deviceinstallation.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInstallationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinstallation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case deviceinstallation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case deviceinstallation.EdgeArea:
		if id := m.area; id != nil {
			return []ent.Value{*id}
		}
	case deviceinstallation.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInstallationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInstallationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInstallationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, deviceinstallation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, deviceinstallation.EdgeUpdater)
	}
	if m.clearedarea {
		edges = append(edges, deviceinstallation.EdgeArea)
	}
	if m.cleareddevice {
		edges = append(edges, deviceinstallation.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInstallationMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinstallation.EdgeCreator:
		return m.clearedcreator
	case deviceinstallation.EdgeUpdater:
		return m.clearedupdater
	case deviceinstallation.EdgeArea:
		return m.clearedarea
	case deviceinstallation.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInstallationMutation) ClearEdge(name string) error {
	switch name {
	case deviceinstallation.EdgeCreator:
		m.ClearCreator()
		return nil
	case deviceinstallation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case deviceinstallation.EdgeArea:
		m.ClearArea()
		return nil
	case deviceinstallation.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInstallationMutation) ResetEdge(name string) error {
	switch name {
	case deviceinstallation.EdgeCreator:
		m.ResetCreator()
		return nil
	case deviceinstallation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case deviceinstallation.EdgeArea:
		m.ResetArea()
		return nil
	case deviceinstallation.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceInstallation edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	deleted_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	creator                *int
	clearedcreator         bool
	updater                *int
	clearedupdater         bool
	admin                  *int
	clearedadmin           bool
	department             *int
	cleareddepartment      bool
	occupations            map[int]struct{}
	removedoccupations     map[int]struct{}
	clearedoccupations     bool
	ipc_events             map[int]struct{}
	removedipc_events      map[int]struct{}
	clearedipc_events      bool
	risk_reporter          map[int]struct{}
	removedrisk_reporter   map[int]struct{}
	clearedrisk_reporter   bool
	risk_maintainer        map[int]struct{}
	removedrisk_maintainer map[int]struct{}
	clearedrisk_maintainer bool
	done                   bool
	oldValue               func(context.Context) (*Employee, error)
	predicates             []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EmployeeMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EmployeeMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EmployeeMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EmployeeMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EmployeeMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EmployeeMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAdminID sets the "admin_id" field.
func (m *EmployeeMutation) SetAdminID(i int) {
	m.admin = &i
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *EmployeeMutation) AdminID() (r int, exists bool) {
	v := m.admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *EmployeeMutation) ResetAdminID() {
	m.admin = nil
}

// SetDepartmentID sets the "department_id" field.
func (m *EmployeeMutation) SetDepartmentID(i int) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *EmployeeMutation) DepartmentID() (r int, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDepartmentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *EmployeeMutation) ResetDepartmentID() {
	m.department = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *EmployeeMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EmployeeMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[employee.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EmployeeMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *EmployeeMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EmployeeMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *EmployeeMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *EmployeeMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[employee.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *EmployeeMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *EmployeeMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *EmployeeMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *EmployeeMutation) ClearAdmin() {
	m.clearedadmin = true
	m.clearedFields[employee.FieldAdminID] = struct{}{}
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *EmployeeMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) AdminIDs() (ids []int) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *EmployeeMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *EmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[employee.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *EmployeeMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *EmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddOccupationIDs adds the "occupations" edge to the Occupation entity by ids.
func (m *EmployeeMutation) AddOccupationIDs(ids ...int) {
	if m.occupations == nil {
		m.occupations = make(map[int]struct{})
	}
	for i := range ids {
		m.occupations[ids[i]] = struct{}{}
	}
}

// ClearOccupations clears the "occupations" edge to the Occupation entity.
func (m *EmployeeMutation) ClearOccupations() {
	m.clearedoccupations = true
}

// OccupationsCleared reports if the "occupations" edge to the Occupation entity was cleared.
func (m *EmployeeMutation) OccupationsCleared() bool {
	return m.clearedoccupations
}

// RemoveOccupationIDs removes the "occupations" edge to the Occupation entity by IDs.
func (m *EmployeeMutation) RemoveOccupationIDs(ids ...int) {
	if m.removedoccupations == nil {
		m.removedoccupations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.occupations, ids[i])
		m.removedoccupations[ids[i]] = struct{}{}
	}
}

// RemovedOccupations returns the removed IDs of the "occupations" edge to the Occupation entity.
func (m *EmployeeMutation) RemovedOccupationsIDs() (ids []int) {
	for id := range m.removedoccupations {
		ids = append(ids, id)
	}
	return
}

// OccupationsIDs returns the "occupations" edge IDs in the mutation.
func (m *EmployeeMutation) OccupationsIDs() (ids []int) {
	for id := range m.occupations {
		ids = append(ids, id)
	}
	return
}

// ResetOccupations resets all changes to the "occupations" edge.
func (m *EmployeeMutation) ResetOccupations() {
	m.occupations = nil
	m.clearedoccupations = false
	m.removedoccupations = nil
}

// AddIpcEventIDs adds the "ipc_events" edge to the IPCEvent entity by ids.
func (m *EmployeeMutation) AddIpcEventIDs(ids ...int) {
	if m.ipc_events == nil {
		m.ipc_events = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_events[ids[i]] = struct{}{}
	}
}

// ClearIpcEvents clears the "ipc_events" edge to the IPCEvent entity.
func (m *EmployeeMutation) ClearIpcEvents() {
	m.clearedipc_events = true
}

// IpcEventsCleared reports if the "ipc_events" edge to the IPCEvent entity was cleared.
func (m *EmployeeMutation) IpcEventsCleared() bool {
	return m.clearedipc_events
}

// RemoveIpcEventIDs removes the "ipc_events" edge to the IPCEvent entity by IDs.
func (m *EmployeeMutation) RemoveIpcEventIDs(ids ...int) {
	if m.removedipc_events == nil {
		m.removedipc_events = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_events, ids[i])
		m.removedipc_events[ids[i]] = struct{}{}
	}
}

// RemovedIpcEvents returns the removed IDs of the "ipc_events" edge to the IPCEvent entity.
func (m *EmployeeMutation) RemovedIpcEventsIDs() (ids []int) {
	for id := range m.removedipc_events {
		ids = append(ids, id)
	}
	return
}

// IpcEventsIDs returns the "ipc_events" edge IDs in the mutation.
func (m *EmployeeMutation) IpcEventsIDs() (ids []int) {
	for id := range m.ipc_events {
		ids = append(ids, id)
	}
	return
}

// ResetIpcEvents resets all changes to the "ipc_events" edge.
func (m *EmployeeMutation) ResetIpcEvents() {
	m.ipc_events = nil
	m.clearedipc_events = false
	m.removedipc_events = nil
}

// AddRiskReporterIDs adds the "risk_reporter" edge to the Risk entity by ids.
func (m *EmployeeMutation) AddRiskReporterIDs(ids ...int) {
	if m.risk_reporter == nil {
		m.risk_reporter = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_reporter[ids[i]] = struct{}{}
	}
}

// ClearRiskReporter clears the "risk_reporter" edge to the Risk entity.
func (m *EmployeeMutation) ClearRiskReporter() {
	m.clearedrisk_reporter = true
}

// RiskReporterCleared reports if the "risk_reporter" edge to the Risk entity was cleared.
func (m *EmployeeMutation) RiskReporterCleared() bool {
	return m.clearedrisk_reporter
}

// RemoveRiskReporterIDs removes the "risk_reporter" edge to the Risk entity by IDs.
func (m *EmployeeMutation) RemoveRiskReporterIDs(ids ...int) {
	if m.removedrisk_reporter == nil {
		m.removedrisk_reporter = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_reporter, ids[i])
		m.removedrisk_reporter[ids[i]] = struct{}{}
	}
}

// RemovedRiskReporter returns the removed IDs of the "risk_reporter" edge to the Risk entity.
func (m *EmployeeMutation) RemovedRiskReporterIDs() (ids []int) {
	for id := range m.removedrisk_reporter {
		ids = append(ids, id)
	}
	return
}

// RiskReporterIDs returns the "risk_reporter" edge IDs in the mutation.
func (m *EmployeeMutation) RiskReporterIDs() (ids []int) {
	for id := range m.risk_reporter {
		ids = append(ids, id)
	}
	return
}

// ResetRiskReporter resets all changes to the "risk_reporter" edge.
func (m *EmployeeMutation) ResetRiskReporter() {
	m.risk_reporter = nil
	m.clearedrisk_reporter = false
	m.removedrisk_reporter = nil
}

// AddRiskMaintainerIDs adds the "risk_maintainer" edge to the Risk entity by ids.
func (m *EmployeeMutation) AddRiskMaintainerIDs(ids ...int) {
	if m.risk_maintainer == nil {
		m.risk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		m.risk_maintainer[ids[i]] = struct{}{}
	}
}

// ClearRiskMaintainer clears the "risk_maintainer" edge to the Risk entity.
func (m *EmployeeMutation) ClearRiskMaintainer() {
	m.clearedrisk_maintainer = true
}

// RiskMaintainerCleared reports if the "risk_maintainer" edge to the Risk entity was cleared.
func (m *EmployeeMutation) RiskMaintainerCleared() bool {
	return m.clearedrisk_maintainer
}

// RemoveRiskMaintainerIDs removes the "risk_maintainer" edge to the Risk entity by IDs.
func (m *EmployeeMutation) RemoveRiskMaintainerIDs(ids ...int) {
	if m.removedrisk_maintainer == nil {
		m.removedrisk_maintainer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk_maintainer, ids[i])
		m.removedrisk_maintainer[ids[i]] = struct{}{}
	}
}

// RemovedRiskMaintainer returns the removed IDs of the "risk_maintainer" edge to the Risk entity.
func (m *EmployeeMutation) RemovedRiskMaintainerIDs() (ids []int) {
	for id := range m.removedrisk_maintainer {
		ids = append(ids, id)
	}
	return
}

// RiskMaintainerIDs returns the "risk_maintainer" edge IDs in the mutation.
func (m *EmployeeMutation) RiskMaintainerIDs() (ids []int) {
	for id := range m.risk_maintainer {
		ids = append(ids, id)
	}
	return
}

// ResetRiskMaintainer resets all changes to the "risk_maintainer" edge.
func (m *EmployeeMutation) ResetRiskMaintainer() {
	m.risk_maintainer = nil
	m.clearedrisk_maintainer = false
	m.removedrisk_maintainer = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, employee.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, employee.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.admin != nil {
		fields = append(fields, employee.FieldAdminID)
	}
	if m.department != nil {
		fields = append(fields, employee.FieldDepartmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldCreatedBy:
		return m.CreatedBy()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldUpdatedBy:
		return m.UpdatedBy()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldAdminID:
		return m.AdminID()
	case employee.FieldDepartmentID:
		return m.DepartmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldAdminID:
		return m.OldAdminID(ctx)
	case employee.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case employee.FieldDepartmentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldAdminID:
		m.ResetAdminID()
		return nil
	case employee.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.creator != nil {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, employee.EdgeUpdater)
	}
	if m.admin != nil {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.department != nil {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.occupations != nil {
		edges = append(edges, employee.EdgeOccupations)
	}
	if m.ipc_events != nil {
		edges = append(edges, employee.EdgeIpcEvents)
	}
	if m.risk_reporter != nil {
		edges = append(edges, employee.EdgeRiskReporter)
	}
	if m.risk_maintainer != nil {
		edges = append(edges, employee.EdgeRiskMaintainer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeOccupations:
		ids := make([]ent.Value, 0, len(m.occupations))
		for id := range m.occupations {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeIpcEvents:
		ids := make([]ent.Value, 0, len(m.ipc_events))
		for id := range m.ipc_events {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskReporter:
		ids := make([]ent.Value, 0, len(m.risk_reporter))
		for id := range m.risk_reporter {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.risk_maintainer))
		for id := range m.risk_maintainer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedoccupations != nil {
		edges = append(edges, employee.EdgeOccupations)
	}
	if m.removedipc_events != nil {
		edges = append(edges, employee.EdgeIpcEvents)
	}
	if m.removedrisk_reporter != nil {
		edges = append(edges, employee.EdgeRiskReporter)
	}
	if m.removedrisk_maintainer != nil {
		edges = append(edges, employee.EdgeRiskMaintainer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeOccupations:
		ids := make([]ent.Value, 0, len(m.removedoccupations))
		for id := range m.removedoccupations {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeIpcEvents:
		ids := make([]ent.Value, 0, len(m.removedipc_events))
		for id := range m.removedipc_events {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskReporter:
		ids := make([]ent.Value, 0, len(m.removedrisk_reporter))
		for id := range m.removedrisk_reporter {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeRiskMaintainer:
		ids := make([]ent.Value, 0, len(m.removedrisk_maintainer))
		for id := range m.removedrisk_maintainer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcreator {
		edges = append(edges, employee.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, employee.EdgeUpdater)
	}
	if m.clearedadmin {
		edges = append(edges, employee.EdgeAdmin)
	}
	if m.cleareddepartment {
		edges = append(edges, employee.EdgeDepartment)
	}
	if m.clearedoccupations {
		edges = append(edges, employee.EdgeOccupations)
	}
	if m.clearedipc_events {
		edges = append(edges, employee.EdgeIpcEvents)
	}
	if m.clearedrisk_reporter {
		edges = append(edges, employee.EdgeRiskReporter)
	}
	if m.clearedrisk_maintainer {
		edges = append(edges, employee.EdgeRiskMaintainer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCreator:
		return m.clearedcreator
	case employee.EdgeUpdater:
		return m.clearedupdater
	case employee.EdgeAdmin:
		return m.clearedadmin
	case employee.EdgeDepartment:
		return m.cleareddepartment
	case employee.EdgeOccupations:
		return m.clearedoccupations
	case employee.EdgeIpcEvents:
		return m.clearedipc_events
	case employee.EdgeRiskReporter:
		return m.clearedrisk_reporter
	case employee.EdgeRiskMaintainer:
		return m.clearedrisk_maintainer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ClearCreator()
		return nil
	case employee.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case employee.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case employee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCreator:
		m.ResetCreator()
		return nil
	case employee.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case employee.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case employee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case employee.EdgeOccupations:
		m.ResetOccupations()
		return nil
	case employee.EdgeIpcEvents:
		m.ResetIpcEvents()
		return nil
	case employee.EdgeRiskReporter:
		m.ResetRiskReporter()
		return nil
	case employee.EdgeRiskMaintainer:
		m.ResetRiskMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// EventLevelMutation represents an operation that mutates the EventLevel nodes in the graph.
type EventLevelMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	deleted_at        *time.Time
	updated_at        *time.Time
	name              *string
	event_types       *[]enums.EventType
	appendevent_types []enums.EventType
	description       *string
	is_report         *bool
	clearedFields     map[string]struct{}
	creator           *int
	clearedcreator    bool
	updater           *int
	clearedupdater    bool
	done              bool
	oldValue          func(context.Context) (*EventLevel, error)
	predicates        []predicate.EventLevel
}

var _ ent.Mutation = (*EventLevelMutation)(nil)

// eventlevelOption allows management of the mutation configuration using functional options.
type eventlevelOption func(*EventLevelMutation)

// newEventLevelMutation creates new mutation for the EventLevel entity.
func newEventLevelMutation(c config, op Op, opts ...eventlevelOption) *EventLevelMutation {
	m := &EventLevelMutation{
		config:        c,
		op:            op,
		typ:           TypeEventLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventLevelID sets the ID field of the mutation.
func withEventLevelID(id int) eventlevelOption {
	return func(m *EventLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *EventLevel
		)
		m.oldValue = func(ctx context.Context) (*EventLevel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventLevel sets the old EventLevel of the mutation.
func withEventLevel(node *EventLevel) eventlevelOption {
	return func(m *EventLevelMutation) {
		m.oldValue = func(context.Context) (*EventLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventLevelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventLevelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventLevel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventLevelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventLevelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventLevelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *EventLevelMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *EventLevelMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *EventLevelMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventLevelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventLevelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventLevelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[eventlevel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventLevelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventLevelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, eventlevel.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *EventLevelMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *EventLevelMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *EventLevelMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventLevelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventLevelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventLevelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EventLevelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EventLevelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *EventLevelMutation) ClearName() {
	m.name = nil
	m.clearedFields[eventlevel.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *EventLevelMutation) NameCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *EventLevelMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, eventlevel.FieldName)
}

// SetEventTypes sets the "event_types" field.
func (m *EventLevelMutation) SetEventTypes(et []enums.EventType) {
	m.event_types = &et
	m.appendevent_types = nil
}

// EventTypes returns the value of the "event_types" field in the mutation.
func (m *EventLevelMutation) EventTypes() (r []enums.EventType, exists bool) {
	v := m.event_types
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTypes returns the old "event_types" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldEventTypes(ctx context.Context) (v []enums.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTypes: %w", err)
	}
	return oldValue.EventTypes, nil
}

// AppendEventTypes adds et to the "event_types" field.
func (m *EventLevelMutation) AppendEventTypes(et []enums.EventType) {
	m.appendevent_types = append(m.appendevent_types, et...)
}

// AppendedEventTypes returns the list of values that were appended to the "event_types" field in this mutation.
func (m *EventLevelMutation) AppendedEventTypes() ([]enums.EventType, bool) {
	if len(m.appendevent_types) == 0 {
		return nil, false
	}
	return m.appendevent_types, true
}

// ResetEventTypes resets all changes to the "event_types" field.
func (m *EventLevelMutation) ResetEventTypes() {
	m.event_types = nil
	m.appendevent_types = nil
}

// SetDescription sets the "description" field.
func (m *EventLevelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EventLevelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EventLevelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[eventlevel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EventLevelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EventLevelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, eventlevel.FieldDescription)
}

// SetIsReport sets the "is_report" field.
func (m *EventLevelMutation) SetIsReport(b bool) {
	m.is_report = &b
}

// IsReport returns the value of the "is_report" field in the mutation.
func (m *EventLevelMutation) IsReport() (r bool, exists bool) {
	v := m.is_report
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReport returns the old "is_report" field's value of the EventLevel entity.
// If the EventLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventLevelMutation) OldIsReport(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReport: %w", err)
	}
	return oldValue.IsReport, nil
}

// ClearIsReport clears the value of the "is_report" field.
func (m *EventLevelMutation) ClearIsReport() {
	m.is_report = nil
	m.clearedFields[eventlevel.FieldIsReport] = struct{}{}
}

// IsReportCleared returns if the "is_report" field was cleared in this mutation.
func (m *EventLevelMutation) IsReportCleared() bool {
	_, ok := m.clearedFields[eventlevel.FieldIsReport]
	return ok
}

// ResetIsReport resets all changes to the "is_report" field.
func (m *EventLevelMutation) ResetIsReport() {
	m.is_report = nil
	delete(m.clearedFields, eventlevel.FieldIsReport)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *EventLevelMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *EventLevelMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[eventlevel.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *EventLevelMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *EventLevelMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EventLevelMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EventLevelMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *EventLevelMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *EventLevelMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[eventlevel.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *EventLevelMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *EventLevelMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *EventLevelMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *EventLevelMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// Where appends a list predicates to the EventLevelMutation builder.
func (m *EventLevelMutation) Where(ps ...predicate.EventLevel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventLevelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventLevelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventLevel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventLevelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventLevelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventLevel).
func (m *EventLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventLevelMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, eventlevel.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, eventlevel.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, eventlevel.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, eventlevel.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, eventlevel.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, eventlevel.FieldName)
	}
	if m.event_types != nil {
		fields = append(fields, eventlevel.FieldEventTypes)
	}
	if m.description != nil {
		fields = append(fields, eventlevel.FieldDescription)
	}
	if m.is_report != nil {
		fields = append(fields, eventlevel.FieldIsReport)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventlevel.FieldCreatedAt:
		return m.CreatedAt()
	case eventlevel.FieldCreatedBy:
		return m.CreatedBy()
	case eventlevel.FieldDeletedAt:
		return m.DeletedAt()
	case eventlevel.FieldUpdatedBy:
		return m.UpdatedBy()
	case eventlevel.FieldUpdatedAt:
		return m.UpdatedAt()
	case eventlevel.FieldName:
		return m.Name()
	case eventlevel.FieldEventTypes:
		return m.EventTypes()
	case eventlevel.FieldDescription:
		return m.Description()
	case eventlevel.FieldIsReport:
		return m.IsReport()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventlevel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case eventlevel.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case eventlevel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case eventlevel.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case eventlevel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case eventlevel.FieldName:
		return m.OldName(ctx)
	case eventlevel.FieldEventTypes:
		return m.OldEventTypes(ctx)
	case eventlevel.FieldDescription:
		return m.OldDescription(ctx)
	case eventlevel.FieldIsReport:
		return m.OldIsReport(ctx)
	}
	return nil, fmt.Errorf("unknown EventLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventlevel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case eventlevel.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case eventlevel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case eventlevel.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case eventlevel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case eventlevel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case eventlevel.FieldEventTypes:
		v, ok := value.([]enums.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTypes(v)
		return nil
	case eventlevel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case eventlevel.FieldIsReport:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReport(v)
		return nil
	}
	return fmt.Errorf("unknown EventLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventLevelMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventLevelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventLevelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(eventlevel.FieldDeletedAt) {
		fields = append(fields, eventlevel.FieldDeletedAt)
	}
	if m.FieldCleared(eventlevel.FieldName) {
		fields = append(fields, eventlevel.FieldName)
	}
	if m.FieldCleared(eventlevel.FieldDescription) {
		fields = append(fields, eventlevel.FieldDescription)
	}
	if m.FieldCleared(eventlevel.FieldIsReport) {
		fields = append(fields, eventlevel.FieldIsReport)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventLevelMutation) ClearField(name string) error {
	switch name {
	case eventlevel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case eventlevel.FieldName:
		m.ClearName()
		return nil
	case eventlevel.FieldDescription:
		m.ClearDescription()
		return nil
	case eventlevel.FieldIsReport:
		m.ClearIsReport()
		return nil
	}
	return fmt.Errorf("unknown EventLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventLevelMutation) ResetField(name string) error {
	switch name {
	case eventlevel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case eventlevel.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case eventlevel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case eventlevel.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case eventlevel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case eventlevel.FieldName:
		m.ResetName()
		return nil
	case eventlevel.FieldEventTypes:
		m.ResetEventTypes()
		return nil
	case eventlevel.FieldDescription:
		m.ResetDescription()
		return nil
	case eventlevel.FieldIsReport:
		m.ResetIsReport()
		return nil
	}
	return fmt.Errorf("unknown EventLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, eventlevel.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, eventlevel.EdgeUpdater)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventLevelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventlevel.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case eventlevel.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventLevelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, eventlevel.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, eventlevel.EdgeUpdater)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventLevelMutation) EdgeCleared(name string) bool {
	switch name {
	case eventlevel.EdgeCreator:
		return m.clearedcreator
	case eventlevel.EdgeUpdater:
		return m.clearedupdater
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventLevelMutation) ClearEdge(name string) error {
	switch name {
	case eventlevel.EdgeCreator:
		m.ClearCreator()
		return nil
	case eventlevel.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown EventLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventLevelMutation) ResetEdge(name string) error {
	switch name {
	case eventlevel.EdgeCreator:
		m.ResetCreator()
		return nil
	case eventlevel.EdgeUpdater:
		m.ResetUpdater()
		return nil
	}
	return fmt.Errorf("unknown EventLevel edge %s", name)
}

// IPCEventMutation represents an operation that mutates the IPCEvent nodes in the graph.
type IPCEventMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	deleted_at           *time.Time
	updated_at           *time.Time
	event_time           *time.Time
	event_type           *enums.EventType
	addevent_type        *enums.EventType
	event_status         *enums.EventStatus
	addevent_status      *enums.EventStatus
	images               *[]*types.UploadedImage
	appendimages         []*types.UploadedImage
	labeled_images       *[]*types.UploadedImage
	appendlabeled_images []*types.UploadedImage
	event_id             *string
	description          *string
	raw_data             *string
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	updater              *int
	clearedupdater       bool
	video                *int
	clearedvideo         bool
	device               *int
	cleareddevice        bool
	fixers               map[int]struct{}
	removedfixers        map[int]struct{}
	clearedfixers        bool
	done                 bool
	oldValue             func(context.Context) (*IPCEvent, error)
	predicates           []predicate.IPCEvent
}

var _ ent.Mutation = (*IPCEventMutation)(nil)

// ipceventOption allows management of the mutation configuration using functional options.
type ipceventOption func(*IPCEventMutation)

// newIPCEventMutation creates new mutation for the IPCEvent entity.
func newIPCEventMutation(c config, op Op, opts ...ipceventOption) *IPCEventMutation {
	m := &IPCEventMutation{
		config:        c,
		op:            op,
		typ:           TypeIPCEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIPCEventID sets the ID field of the mutation.
func withIPCEventID(id int) ipceventOption {
	return func(m *IPCEventMutation) {
		var (
			err   error
			once  sync.Once
			value *IPCEvent
		)
		m.oldValue = func(ctx context.Context) (*IPCEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IPCEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIPCEvent sets the old IPCEvent of the mutation.
func withIPCEvent(node *IPCEvent) ipceventOption {
	return func(m *IPCEventMutation) {
		m.oldValue = func(context.Context) (*IPCEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IPCEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IPCEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IPCEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IPCEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IPCEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IPCEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IPCEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IPCEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *IPCEventMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *IPCEventMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *IPCEventMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *IPCEventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *IPCEventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *IPCEventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ipcevent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *IPCEventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ipcevent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *IPCEventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ipcevent.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *IPCEventMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *IPCEventMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *IPCEventMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IPCEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IPCEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IPCEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeviceID sets the "device_id" field.
func (m *IPCEventMutation) SetDeviceID(i int) {
	m.device = &i
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *IPCEventMutation) DeviceID() (r int, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldDeviceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *IPCEventMutation) ResetDeviceID() {
	m.device = nil
}

// SetVideoID sets the "video_id" field.
func (m *IPCEventMutation) SetVideoID(i int) {
	m.video = &i
}

// VideoID returns the value of the "video_id" field in the mutation.
func (m *IPCEventMutation) VideoID() (r int, exists bool) {
	v := m.video
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoID returns the old "video_id" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldVideoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoID: %w", err)
	}
	return oldValue.VideoID, nil
}

// ClearVideoID clears the value of the "video_id" field.
func (m *IPCEventMutation) ClearVideoID() {
	m.video = nil
	m.clearedFields[ipcevent.FieldVideoID] = struct{}{}
}

// VideoIDCleared returns if the "video_id" field was cleared in this mutation.
func (m *IPCEventMutation) VideoIDCleared() bool {
	_, ok := m.clearedFields[ipcevent.FieldVideoID]
	return ok
}

// ResetVideoID resets all changes to the "video_id" field.
func (m *IPCEventMutation) ResetVideoID() {
	m.video = nil
	delete(m.clearedFields, ipcevent.FieldVideoID)
}

// SetEventTime sets the "event_time" field.
func (m *IPCEventMutation) SetEventTime(t time.Time) {
	m.event_time = &t
}

// EventTime returns the value of the "event_time" field in the mutation.
func (m *IPCEventMutation) EventTime() (r time.Time, exists bool) {
	v := m.event_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTime returns the old "event_time" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldEventTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTime: %w", err)
	}
	return oldValue.EventTime, nil
}

// ResetEventTime resets all changes to the "event_time" field.
func (m *IPCEventMutation) ResetEventTime() {
	m.event_time = nil
}

// SetEventType sets the "event_type" field.
func (m *IPCEventMutation) SetEventType(et enums.EventType) {
	m.event_type = &et
	m.addevent_type = nil
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *IPCEventMutation) EventType() (r enums.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldEventType(ctx context.Context) (v enums.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// AddEventType adds et to the "event_type" field.
func (m *IPCEventMutation) AddEventType(et enums.EventType) {
	if m.addevent_type != nil {
		*m.addevent_type += et
	} else {
		m.addevent_type = &et
	}
}

// AddedEventType returns the value that was added to the "event_type" field in this mutation.
func (m *IPCEventMutation) AddedEventType() (r enums.EventType, exists bool) {
	v := m.addevent_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventType resets all changes to the "event_type" field.
func (m *IPCEventMutation) ResetEventType() {
	m.event_type = nil
	m.addevent_type = nil
}

// SetEventStatus sets the "event_status" field.
func (m *IPCEventMutation) SetEventStatus(es enums.EventStatus) {
	m.event_status = &es
	m.addevent_status = nil
}

// EventStatus returns the value of the "event_status" field in the mutation.
func (m *IPCEventMutation) EventStatus() (r enums.EventStatus, exists bool) {
	v := m.event_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEventStatus returns the old "event_status" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldEventStatus(ctx context.Context) (v enums.EventStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventStatus: %w", err)
	}
	return oldValue.EventStatus, nil
}

// AddEventStatus adds es to the "event_status" field.
func (m *IPCEventMutation) AddEventStatus(es enums.EventStatus) {
	if m.addevent_status != nil {
		*m.addevent_status += es
	} else {
		m.addevent_status = &es
	}
}

// AddedEventStatus returns the value that was added to the "event_status" field in this mutation.
func (m *IPCEventMutation) AddedEventStatus() (r enums.EventStatus, exists bool) {
	v := m.addevent_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetEventStatus resets all changes to the "event_status" field.
func (m *IPCEventMutation) ResetEventStatus() {
	m.event_status = nil
	m.addevent_status = nil
}

// SetImages sets the "images" field.
func (m *IPCEventMutation) SetImages(ti []*types.UploadedImage) {
	m.images = &ti
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *IPCEventMutation) Images() (r []*types.UploadedImage, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldImages(ctx context.Context) (v []*types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds ti to the "images" field.
func (m *IPCEventMutation) AppendImages(ti []*types.UploadedImage) {
	m.appendimages = append(m.appendimages, ti...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *IPCEventMutation) AppendedImages() ([]*types.UploadedImage, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *IPCEventMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[ipcevent.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *IPCEventMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[ipcevent.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *IPCEventMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, ipcevent.FieldImages)
}

// SetLabeledImages sets the "labeled_images" field.
func (m *IPCEventMutation) SetLabeledImages(ti []*types.UploadedImage) {
	m.labeled_images = &ti
	m.appendlabeled_images = nil
}

// LabeledImages returns the value of the "labeled_images" field in the mutation.
func (m *IPCEventMutation) LabeledImages() (r []*types.UploadedImage, exists bool) {
	v := m.labeled_images
	if v == nil {
		return
	}
	return *v, true
}

// OldLabeledImages returns the old "labeled_images" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldLabeledImages(ctx context.Context) (v []*types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabeledImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabeledImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabeledImages: %w", err)
	}
	return oldValue.LabeledImages, nil
}

// AppendLabeledImages adds ti to the "labeled_images" field.
func (m *IPCEventMutation) AppendLabeledImages(ti []*types.UploadedImage) {
	m.appendlabeled_images = append(m.appendlabeled_images, ti...)
}

// AppendedLabeledImages returns the list of values that were appended to the "labeled_images" field in this mutation.
func (m *IPCEventMutation) AppendedLabeledImages() ([]*types.UploadedImage, bool) {
	if len(m.appendlabeled_images) == 0 {
		return nil, false
	}
	return m.appendlabeled_images, true
}

// ClearLabeledImages clears the value of the "labeled_images" field.
func (m *IPCEventMutation) ClearLabeledImages() {
	m.labeled_images = nil
	m.appendlabeled_images = nil
	m.clearedFields[ipcevent.FieldLabeledImages] = struct{}{}
}

// LabeledImagesCleared returns if the "labeled_images" field was cleared in this mutation.
func (m *IPCEventMutation) LabeledImagesCleared() bool {
	_, ok := m.clearedFields[ipcevent.FieldLabeledImages]
	return ok
}

// ResetLabeledImages resets all changes to the "labeled_images" field.
func (m *IPCEventMutation) ResetLabeledImages() {
	m.labeled_images = nil
	m.appendlabeled_images = nil
	delete(m.clearedFields, ipcevent.FieldLabeledImages)
}

// SetEventID sets the "event_id" field.
func (m *IPCEventMutation) SetEventID(s string) {
	m.event_id = &s
}

// EventID returns the value of the "event_id" field in the mutation.
func (m *IPCEventMutation) EventID() (r string, exists bool) {
	v := m.event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventID returns the old "event_id" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventID: %w", err)
	}
	return oldValue.EventID, nil
}

// ResetEventID resets all changes to the "event_id" field.
func (m *IPCEventMutation) ResetEventID() {
	m.event_id = nil
}

// SetDescription sets the "description" field.
func (m *IPCEventMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *IPCEventMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *IPCEventMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[ipcevent.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *IPCEventMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[ipcevent.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *IPCEventMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, ipcevent.FieldDescription)
}

// SetRawData sets the "raw_data" field.
func (m *IPCEventMutation) SetRawData(s string) {
	m.raw_data = &s
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *IPCEventMutation) RawData() (r string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the IPCEvent entity.
// If the IPCEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IPCEventMutation) OldRawData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ClearRawData clears the value of the "raw_data" field.
func (m *IPCEventMutation) ClearRawData() {
	m.raw_data = nil
	m.clearedFields[ipcevent.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *IPCEventMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[ipcevent.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *IPCEventMutation) ResetRawData() {
	m.raw_data = nil
	delete(m.clearedFields, ipcevent.FieldRawData)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *IPCEventMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *IPCEventMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[ipcevent.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *IPCEventMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *IPCEventMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *IPCEventMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *IPCEventMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *IPCEventMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *IPCEventMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[ipcevent.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *IPCEventMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *IPCEventMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *IPCEventMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *IPCEventMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *IPCEventMutation) ClearVideo() {
	m.clearedvideo = true
	m.clearedFields[ipcevent.FieldVideoID] = struct{}{}
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *IPCEventMutation) VideoCleared() bool {
	return m.VideoIDCleared() || m.clearedvideo
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *IPCEventMutation) VideoIDs() (ids []int) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *IPCEventMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *IPCEventMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[ipcevent.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *IPCEventMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *IPCEventMutation) DeviceIDs() (ids []int) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *IPCEventMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddFixerIDs adds the "fixers" edge to the Employee entity by ids.
func (m *IPCEventMutation) AddFixerIDs(ids ...int) {
	if m.fixers == nil {
		m.fixers = make(map[int]struct{})
	}
	for i := range ids {
		m.fixers[ids[i]] = struct{}{}
	}
}

// ClearFixers clears the "fixers" edge to the Employee entity.
func (m *IPCEventMutation) ClearFixers() {
	m.clearedfixers = true
}

// FixersCleared reports if the "fixers" edge to the Employee entity was cleared.
func (m *IPCEventMutation) FixersCleared() bool {
	return m.clearedfixers
}

// RemoveFixerIDs removes the "fixers" edge to the Employee entity by IDs.
func (m *IPCEventMutation) RemoveFixerIDs(ids ...int) {
	if m.removedfixers == nil {
		m.removedfixers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixers, ids[i])
		m.removedfixers[ids[i]] = struct{}{}
	}
}

// RemovedFixers returns the removed IDs of the "fixers" edge to the Employee entity.
func (m *IPCEventMutation) RemovedFixersIDs() (ids []int) {
	for id := range m.removedfixers {
		ids = append(ids, id)
	}
	return
}

// FixersIDs returns the "fixers" edge IDs in the mutation.
func (m *IPCEventMutation) FixersIDs() (ids []int) {
	for id := range m.fixers {
		ids = append(ids, id)
	}
	return
}

// ResetFixers resets all changes to the "fixers" edge.
func (m *IPCEventMutation) ResetFixers() {
	m.fixers = nil
	m.clearedfixers = false
	m.removedfixers = nil
}

// Where appends a list predicates to the IPCEventMutation builder.
func (m *IPCEventMutation) Where(ps ...predicate.IPCEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IPCEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IPCEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IPCEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IPCEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IPCEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IPCEvent).
func (m *IPCEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IPCEventMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, ipcevent.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, ipcevent.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, ipcevent.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, ipcevent.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, ipcevent.FieldUpdatedAt)
	}
	if m.device != nil {
		fields = append(fields, ipcevent.FieldDeviceID)
	}
	if m.video != nil {
		fields = append(fields, ipcevent.FieldVideoID)
	}
	if m.event_time != nil {
		fields = append(fields, ipcevent.FieldEventTime)
	}
	if m.event_type != nil {
		fields = append(fields, ipcevent.FieldEventType)
	}
	if m.event_status != nil {
		fields = append(fields, ipcevent.FieldEventStatus)
	}
	if m.images != nil {
		fields = append(fields, ipcevent.FieldImages)
	}
	if m.labeled_images != nil {
		fields = append(fields, ipcevent.FieldLabeledImages)
	}
	if m.event_id != nil {
		fields = append(fields, ipcevent.FieldEventID)
	}
	if m.description != nil {
		fields = append(fields, ipcevent.FieldDescription)
	}
	if m.raw_data != nil {
		fields = append(fields, ipcevent.FieldRawData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IPCEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ipcevent.FieldCreatedAt:
		return m.CreatedAt()
	case ipcevent.FieldCreatedBy:
		return m.CreatedBy()
	case ipcevent.FieldDeletedAt:
		return m.DeletedAt()
	case ipcevent.FieldUpdatedBy:
		return m.UpdatedBy()
	case ipcevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case ipcevent.FieldDeviceID:
		return m.DeviceID()
	case ipcevent.FieldVideoID:
		return m.VideoID()
	case ipcevent.FieldEventTime:
		return m.EventTime()
	case ipcevent.FieldEventType:
		return m.EventType()
	case ipcevent.FieldEventStatus:
		return m.EventStatus()
	case ipcevent.FieldImages:
		return m.Images()
	case ipcevent.FieldLabeledImages:
		return m.LabeledImages()
	case ipcevent.FieldEventID:
		return m.EventID()
	case ipcevent.FieldDescription:
		return m.Description()
	case ipcevent.FieldRawData:
		return m.RawData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IPCEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ipcevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ipcevent.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case ipcevent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ipcevent.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case ipcevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ipcevent.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case ipcevent.FieldVideoID:
		return m.OldVideoID(ctx)
	case ipcevent.FieldEventTime:
		return m.OldEventTime(ctx)
	case ipcevent.FieldEventType:
		return m.OldEventType(ctx)
	case ipcevent.FieldEventStatus:
		return m.OldEventStatus(ctx)
	case ipcevent.FieldImages:
		return m.OldImages(ctx)
	case ipcevent.FieldLabeledImages:
		return m.OldLabeledImages(ctx)
	case ipcevent.FieldEventID:
		return m.OldEventID(ctx)
	case ipcevent.FieldDescription:
		return m.OldDescription(ctx)
	case ipcevent.FieldRawData:
		return m.OldRawData(ctx)
	}
	return nil, fmt.Errorf("unknown IPCEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPCEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ipcevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ipcevent.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case ipcevent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ipcevent.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case ipcevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ipcevent.FieldDeviceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case ipcevent.FieldVideoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoID(v)
		return nil
	case ipcevent.FieldEventTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTime(v)
		return nil
	case ipcevent.FieldEventType:
		v, ok := value.(enums.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case ipcevent.FieldEventStatus:
		v, ok := value.(enums.EventStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventStatus(v)
		return nil
	case ipcevent.FieldImages:
		v, ok := value.([]*types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case ipcevent.FieldLabeledImages:
		v, ok := value.([]*types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabeledImages(v)
		return nil
	case ipcevent.FieldEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventID(v)
		return nil
	case ipcevent.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case ipcevent.FieldRawData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	}
	return fmt.Errorf("unknown IPCEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IPCEventMutation) AddedFields() []string {
	var fields []string
	if m.addevent_type != nil {
		fields = append(fields, ipcevent.FieldEventType)
	}
	if m.addevent_status != nil {
		fields = append(fields, ipcevent.FieldEventStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IPCEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ipcevent.FieldEventType:
		return m.AddedEventType()
	case ipcevent.FieldEventStatus:
		return m.AddedEventStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IPCEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ipcevent.FieldEventType:
		v, ok := value.(enums.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventType(v)
		return nil
	case ipcevent.FieldEventStatus:
		v, ok := value.(enums.EventStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEventStatus(v)
		return nil
	}
	return fmt.Errorf("unknown IPCEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IPCEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ipcevent.FieldDeletedAt) {
		fields = append(fields, ipcevent.FieldDeletedAt)
	}
	if m.FieldCleared(ipcevent.FieldVideoID) {
		fields = append(fields, ipcevent.FieldVideoID)
	}
	if m.FieldCleared(ipcevent.FieldImages) {
		fields = append(fields, ipcevent.FieldImages)
	}
	if m.FieldCleared(ipcevent.FieldLabeledImages) {
		fields = append(fields, ipcevent.FieldLabeledImages)
	}
	if m.FieldCleared(ipcevent.FieldDescription) {
		fields = append(fields, ipcevent.FieldDescription)
	}
	if m.FieldCleared(ipcevent.FieldRawData) {
		fields = append(fields, ipcevent.FieldRawData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IPCEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IPCEventMutation) ClearField(name string) error {
	switch name {
	case ipcevent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ipcevent.FieldVideoID:
		m.ClearVideoID()
		return nil
	case ipcevent.FieldImages:
		m.ClearImages()
		return nil
	case ipcevent.FieldLabeledImages:
		m.ClearLabeledImages()
		return nil
	case ipcevent.FieldDescription:
		m.ClearDescription()
		return nil
	case ipcevent.FieldRawData:
		m.ClearRawData()
		return nil
	}
	return fmt.Errorf("unknown IPCEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IPCEventMutation) ResetField(name string) error {
	switch name {
	case ipcevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ipcevent.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case ipcevent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ipcevent.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case ipcevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ipcevent.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case ipcevent.FieldVideoID:
		m.ResetVideoID()
		return nil
	case ipcevent.FieldEventTime:
		m.ResetEventTime()
		return nil
	case ipcevent.FieldEventType:
		m.ResetEventType()
		return nil
	case ipcevent.FieldEventStatus:
		m.ResetEventStatus()
		return nil
	case ipcevent.FieldImages:
		m.ResetImages()
		return nil
	case ipcevent.FieldLabeledImages:
		m.ResetLabeledImages()
		return nil
	case ipcevent.FieldEventID:
		m.ResetEventID()
		return nil
	case ipcevent.FieldDescription:
		m.ResetDescription()
		return nil
	case ipcevent.FieldRawData:
		m.ResetRawData()
		return nil
	}
	return fmt.Errorf("unknown IPCEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IPCEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, ipcevent.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, ipcevent.EdgeUpdater)
	}
	if m.video != nil {
		edges = append(edges, ipcevent.EdgeVideo)
	}
	if m.device != nil {
		edges = append(edges, ipcevent.EdgeDevice)
	}
	if m.fixers != nil {
		edges = append(edges, ipcevent.EdgeFixers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IPCEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ipcevent.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case ipcevent.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case ipcevent.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	case ipcevent.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case ipcevent.EdgeFixers:
		ids := make([]ent.Value, 0, len(m.fixers))
		for id := range m.fixers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IPCEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedfixers != nil {
		edges = append(edges, ipcevent.EdgeFixers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IPCEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ipcevent.EdgeFixers:
		ids := make([]ent.Value, 0, len(m.removedfixers))
		for id := range m.removedfixers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IPCEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, ipcevent.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, ipcevent.EdgeUpdater)
	}
	if m.clearedvideo {
		edges = append(edges, ipcevent.EdgeVideo)
	}
	if m.cleareddevice {
		edges = append(edges, ipcevent.EdgeDevice)
	}
	if m.clearedfixers {
		edges = append(edges, ipcevent.EdgeFixers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IPCEventMutation) EdgeCleared(name string) bool {
	switch name {
	case ipcevent.EdgeCreator:
		return m.clearedcreator
	case ipcevent.EdgeUpdater:
		return m.clearedupdater
	case ipcevent.EdgeVideo:
		return m.clearedvideo
	case ipcevent.EdgeDevice:
		return m.cleareddevice
	case ipcevent.EdgeFixers:
		return m.clearedfixers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IPCEventMutation) ClearEdge(name string) error {
	switch name {
	case ipcevent.EdgeCreator:
		m.ClearCreator()
		return nil
	case ipcevent.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case ipcevent.EdgeVideo:
		m.ClearVideo()
		return nil
	case ipcevent.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown IPCEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IPCEventMutation) ResetEdge(name string) error {
	switch name {
	case ipcevent.EdgeCreator:
		m.ResetCreator()
		return nil
	case ipcevent.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case ipcevent.EdgeVideo:
		m.ResetVideo()
		return nil
	case ipcevent.EdgeDevice:
		m.ResetDevice()
		return nil
	case ipcevent.EdgeFixers:
		m.ResetFixers()
		return nil
	}
	return fmt.Errorf("unknown IPCEvent edge %s", name)
}

// OccupationMutation represents an operation that mutates the Occupation nodes in the graph.
type OccupationMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	deleted_at       *time.Time
	updated_at       *time.Time
	name             *string
	description      *string
	clearedFields    map[string]struct{}
	creator          *int
	clearedcreator   bool
	updater          *int
	clearedupdater   bool
	employees        map[int]struct{}
	removedemployees map[int]struct{}
	clearedemployees bool
	done             bool
	oldValue         func(context.Context) (*Occupation, error)
	predicates       []predicate.Occupation
}

var _ ent.Mutation = (*OccupationMutation)(nil)

// occupationOption allows management of the mutation configuration using functional options.
type occupationOption func(*OccupationMutation)

// newOccupationMutation creates new mutation for the Occupation entity.
func newOccupationMutation(c config, op Op, opts ...occupationOption) *OccupationMutation {
	m := &OccupationMutation{
		config:        c,
		op:            op,
		typ:           TypeOccupation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccupationID sets the ID field of the mutation.
func withOccupationID(id int) occupationOption {
	return func(m *OccupationMutation) {
		var (
			err   error
			once  sync.Once
			value *Occupation
		)
		m.oldValue = func(ctx context.Context) (*Occupation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occupation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccupation sets the old Occupation of the mutation.
func withOccupation(node *Occupation) occupationOption {
	return func(m *OccupationMutation) {
		m.oldValue = func(context.Context) (*Occupation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccupationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccupationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OccupationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OccupationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Occupation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OccupationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OccupationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OccupationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OccupationMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OccupationMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OccupationMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OccupationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OccupationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OccupationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[occupation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OccupationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[occupation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OccupationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, occupation.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OccupationMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OccupationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OccupationMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OccupationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OccupationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OccupationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *OccupationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OccupationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OccupationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *OccupationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OccupationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Occupation entity.
// If the Occupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OccupationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[occupation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OccupationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[occupation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OccupationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, occupation.FieldDescription)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *OccupationMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *OccupationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[occupation.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *OccupationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *OccupationMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *OccupationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *OccupationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *OccupationMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *OccupationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[occupation.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *OccupationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *OccupationMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *OccupationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *OccupationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddEmployeeIDs adds the "employees" edge to the Employee entity by ids.
func (m *OccupationMutation) AddEmployeeIDs(ids ...int) {
	if m.employees == nil {
		m.employees = make(map[int]struct{})
	}
	for i := range ids {
		m.employees[ids[i]] = struct{}{}
	}
}

// ClearEmployees clears the "employees" edge to the Employee entity.
func (m *OccupationMutation) ClearEmployees() {
	m.clearedemployees = true
}

// EmployeesCleared reports if the "employees" edge to the Employee entity was cleared.
func (m *OccupationMutation) EmployeesCleared() bool {
	return m.clearedemployees
}

// RemoveEmployeeIDs removes the "employees" edge to the Employee entity by IDs.
func (m *OccupationMutation) RemoveEmployeeIDs(ids ...int) {
	if m.removedemployees == nil {
		m.removedemployees = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.employees, ids[i])
		m.removedemployees[ids[i]] = struct{}{}
	}
}

// RemovedEmployees returns the removed IDs of the "employees" edge to the Employee entity.
func (m *OccupationMutation) RemovedEmployeesIDs() (ids []int) {
	for id := range m.removedemployees {
		ids = append(ids, id)
	}
	return
}

// EmployeesIDs returns the "employees" edge IDs in the mutation.
func (m *OccupationMutation) EmployeesIDs() (ids []int) {
	for id := range m.employees {
		ids = append(ids, id)
	}
	return
}

// ResetEmployees resets all changes to the "employees" edge.
func (m *OccupationMutation) ResetEmployees() {
	m.employees = nil
	m.clearedemployees = false
	m.removedemployees = nil
}

// Where appends a list predicates to the OccupationMutation builder.
func (m *OccupationMutation) Where(ps ...predicate.Occupation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OccupationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OccupationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Occupation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OccupationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OccupationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Occupation).
func (m *OccupationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccupationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, occupation.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, occupation.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, occupation.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, occupation.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, occupation.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, occupation.FieldName)
	}
	if m.description != nil {
		fields = append(fields, occupation.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccupationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occupation.FieldCreatedAt:
		return m.CreatedAt()
	case occupation.FieldCreatedBy:
		return m.CreatedBy()
	case occupation.FieldDeletedAt:
		return m.DeletedAt()
	case occupation.FieldUpdatedBy:
		return m.UpdatedBy()
	case occupation.FieldUpdatedAt:
		return m.UpdatedAt()
	case occupation.FieldName:
		return m.Name()
	case occupation.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccupationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occupation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case occupation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case occupation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case occupation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case occupation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case occupation.FieldName:
		return m.OldName(ctx)
	case occupation.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Occupation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occupation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case occupation.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case occupation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case occupation.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case occupation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case occupation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case occupation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Occupation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccupationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccupationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Occupation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccupationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occupation.FieldDeletedAt) {
		fields = append(fields, occupation.FieldDeletedAt)
	}
	if m.FieldCleared(occupation.FieldDescription) {
		fields = append(fields, occupation.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccupationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccupationMutation) ClearField(name string) error {
	switch name {
	case occupation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case occupation.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Occupation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccupationMutation) ResetField(name string) error {
	switch name {
	case occupation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case occupation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case occupation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case occupation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case occupation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case occupation.FieldName:
		m.ResetName()
		return nil
	case occupation.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Occupation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccupationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, occupation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, occupation.EdgeUpdater)
	}
	if m.employees != nil {
		edges = append(edges, occupation.EdgeEmployees)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccupationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case occupation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case occupation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case occupation.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.employees))
		for id := range m.employees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccupationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedemployees != nil {
		edges = append(edges, occupation.EdgeEmployees)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccupationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case occupation.EdgeEmployees:
		ids := make([]ent.Value, 0, len(m.removedemployees))
		for id := range m.removedemployees {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccupationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, occupation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, occupation.EdgeUpdater)
	}
	if m.clearedemployees {
		edges = append(edges, occupation.EdgeEmployees)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccupationMutation) EdgeCleared(name string) bool {
	switch name {
	case occupation.EdgeCreator:
		return m.clearedcreator
	case occupation.EdgeUpdater:
		return m.clearedupdater
	case occupation.EdgeEmployees:
		return m.clearedemployees
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccupationMutation) ClearEdge(name string) error {
	switch name {
	case occupation.EdgeCreator:
		m.ClearCreator()
		return nil
	case occupation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Occupation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccupationMutation) ResetEdge(name string) error {
	switch name {
	case occupation.EdgeCreator:
		m.ResetCreator()
		return nil
	case occupation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case occupation.EdgeEmployees:
		m.ResetEmployees()
		return nil
	}
	return fmt.Errorf("unknown Occupation edge %s", name)
}

// RiskMutation represents an operation that mutates the Risk nodes in the graph.
type RiskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	deleted_at           *time.Time
	updated_at           *time.Time
	title                *string
	content              *string
	images               *[]types.UploadedImage
	appendimages         []types.UploadedImage
	measures             *string
	maintain_status      *maintain_status.MaintainStatus
	addmaintain_status   *maintain_status.MaintainStatus
	due_time             *time.Time
	clearedFields        map[string]struct{}
	creator              *int
	clearedcreator       bool
	updater              *int
	clearedupdater       bool
	risk_category        *int
	clearedrisk_category bool
	risk_location        *int
	clearedrisk_location bool
	reporter             *int
	clearedreporter      bool
	maintainer           *int
	clearedmaintainer    bool
	done                 bool
	oldValue             func(context.Context) (*Risk, error)
	predicates           []predicate.Risk
}

var _ ent.Mutation = (*RiskMutation)(nil)

// riskOption allows management of the mutation configuration using functional options.
type riskOption func(*RiskMutation)

// newRiskMutation creates new mutation for the Risk entity.
func newRiskMutation(c config, op Op, opts ...riskOption) *RiskMutation {
	m := &RiskMutation{
		config:        c,
		op:            op,
		typ:           TypeRisk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskID sets the ID field of the mutation.
func withRiskID(id int) riskOption {
	return func(m *RiskMutation) {
		var (
			err   error
			once  sync.Once
			value *Risk
		)
		m.oldValue = func(ctx context.Context) (*Risk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Risk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRisk sets the old Risk of the mutation.
func withRisk(node *Risk) riskOption {
	return func(m *RiskMutation) {
		m.oldValue = func(context.Context) (*Risk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Risk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[risk.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[risk.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, risk.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *RiskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RiskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RiskMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *RiskMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *RiskMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *RiskMutation) ClearContent() {
	m.content = nil
	m.clearedFields[risk.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *RiskMutation) ContentCleared() bool {
	_, ok := m.clearedFields[risk.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *RiskMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, risk.FieldContent)
}

// SetImages sets the "images" field.
func (m *RiskMutation) SetImages(ti []types.UploadedImage) {
	m.images = &ti
	m.appendimages = nil
}

// Images returns the value of the "images" field in the mutation.
func (m *RiskMutation) Images() (r []types.UploadedImage, exists bool) {
	v := m.images
	if v == nil {
		return
	}
	return *v, true
}

// OldImages returns the old "images" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldImages(ctx context.Context) (v []types.UploadedImage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImages: %w", err)
	}
	return oldValue.Images, nil
}

// AppendImages adds ti to the "images" field.
func (m *RiskMutation) AppendImages(ti []types.UploadedImage) {
	m.appendimages = append(m.appendimages, ti...)
}

// AppendedImages returns the list of values that were appended to the "images" field in this mutation.
func (m *RiskMutation) AppendedImages() ([]types.UploadedImage, bool) {
	if len(m.appendimages) == 0 {
		return nil, false
	}
	return m.appendimages, true
}

// ClearImages clears the value of the "images" field.
func (m *RiskMutation) ClearImages() {
	m.images = nil
	m.appendimages = nil
	m.clearedFields[risk.FieldImages] = struct{}{}
}

// ImagesCleared returns if the "images" field was cleared in this mutation.
func (m *RiskMutation) ImagesCleared() bool {
	_, ok := m.clearedFields[risk.FieldImages]
	return ok
}

// ResetImages resets all changes to the "images" field.
func (m *RiskMutation) ResetImages() {
	m.images = nil
	m.appendimages = nil
	delete(m.clearedFields, risk.FieldImages)
}

// SetRiskCategoryID sets the "risk_category_id" field.
func (m *RiskMutation) SetRiskCategoryID(i int) {
	m.risk_category = &i
}

// RiskCategoryID returns the value of the "risk_category_id" field in the mutation.
func (m *RiskMutation) RiskCategoryID() (r int, exists bool) {
	v := m.risk_category
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskCategoryID returns the old "risk_category_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskCategoryID: %w", err)
	}
	return oldValue.RiskCategoryID, nil
}

// ResetRiskCategoryID resets all changes to the "risk_category_id" field.
func (m *RiskMutation) ResetRiskCategoryID() {
	m.risk_category = nil
}

// SetRiskLocationID sets the "risk_location_id" field.
func (m *RiskMutation) SetRiskLocationID(i int) {
	m.risk_location = &i
}

// RiskLocationID returns the value of the "risk_location_id" field in the mutation.
func (m *RiskMutation) RiskLocationID() (r int, exists bool) {
	v := m.risk_location
	if v == nil {
		return
	}
	return *v, true
}

// OldRiskLocationID returns the old "risk_location_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldRiskLocationID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiskLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiskLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiskLocationID: %w", err)
	}
	return oldValue.RiskLocationID, nil
}

// ResetRiskLocationID resets all changes to the "risk_location_id" field.
func (m *RiskMutation) ResetRiskLocationID() {
	m.risk_location = nil
}

// SetReporterID sets the "reporter_id" field.
func (m *RiskMutation) SetReporterID(i int) {
	m.reporter = &i
}

// ReporterID returns the value of the "reporter_id" field in the mutation.
func (m *RiskMutation) ReporterID() (r int, exists bool) {
	v := m.reporter
	if v == nil {
		return
	}
	return *v, true
}

// OldReporterID returns the old "reporter_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldReporterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporterID: %w", err)
	}
	return oldValue.ReporterID, nil
}

// ResetReporterID resets all changes to the "reporter_id" field.
func (m *RiskMutation) ResetReporterID() {
	m.reporter = nil
}

// SetMaintainerID sets the "maintainer_id" field.
func (m *RiskMutation) SetMaintainerID(i int) {
	m.maintainer = &i
}

// MaintainerID returns the value of the "maintainer_id" field in the mutation.
func (m *RiskMutation) MaintainerID() (r int, exists bool) {
	v := m.maintainer
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainerID returns the old "maintainer_id" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainerID: %w", err)
	}
	return oldValue.MaintainerID, nil
}

// ResetMaintainerID resets all changes to the "maintainer_id" field.
func (m *RiskMutation) ResetMaintainerID() {
	m.maintainer = nil
}

// SetMeasures sets the "measures" field.
func (m *RiskMutation) SetMeasures(s string) {
	m.measures = &s
}

// Measures returns the value of the "measures" field in the mutation.
func (m *RiskMutation) Measures() (r string, exists bool) {
	v := m.measures
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasures returns the old "measures" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMeasures(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasures: %w", err)
	}
	return oldValue.Measures, nil
}

// ClearMeasures clears the value of the "measures" field.
func (m *RiskMutation) ClearMeasures() {
	m.measures = nil
	m.clearedFields[risk.FieldMeasures] = struct{}{}
}

// MeasuresCleared returns if the "measures" field was cleared in this mutation.
func (m *RiskMutation) MeasuresCleared() bool {
	_, ok := m.clearedFields[risk.FieldMeasures]
	return ok
}

// ResetMeasures resets all changes to the "measures" field.
func (m *RiskMutation) ResetMeasures() {
	m.measures = nil
	delete(m.clearedFields, risk.FieldMeasures)
}

// SetMaintainStatus sets the "maintain_status" field.
func (m *RiskMutation) SetMaintainStatus(mss maintain_status.MaintainStatus) {
	m.maintain_status = &mss
	m.addmaintain_status = nil
}

// MaintainStatus returns the value of the "maintain_status" field in the mutation.
func (m *RiskMutation) MaintainStatus() (r maintain_status.MaintainStatus, exists bool) {
	v := m.maintain_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintainStatus returns the old "maintain_status" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldMaintainStatus(ctx context.Context) (v maintain_status.MaintainStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintainStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintainStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintainStatus: %w", err)
	}
	return oldValue.MaintainStatus, nil
}

// AddMaintainStatus adds mss to the "maintain_status" field.
func (m *RiskMutation) AddMaintainStatus(mss maintain_status.MaintainStatus) {
	if m.addmaintain_status != nil {
		*m.addmaintain_status += mss
	} else {
		m.addmaintain_status = &mss
	}
}

// AddedMaintainStatus returns the value that was added to the "maintain_status" field in this mutation.
func (m *RiskMutation) AddedMaintainStatus() (r maintain_status.MaintainStatus, exists bool) {
	v := m.addmaintain_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaintainStatus resets all changes to the "maintain_status" field.
func (m *RiskMutation) ResetMaintainStatus() {
	m.maintain_status = nil
	m.addmaintain_status = nil
}

// SetDueTime sets the "due_time" field.
func (m *RiskMutation) SetDueTime(t time.Time) {
	m.due_time = &t
}

// DueTime returns the value of the "due_time" field in the mutation.
func (m *RiskMutation) DueTime() (r time.Time, exists bool) {
	v := m.due_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDueTime returns the old "due_time" field's value of the Risk entity.
// If the Risk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskMutation) OldDueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueTime: %w", err)
	}
	return oldValue.DueTime, nil
}

// ResetDueTime resets all changes to the "due_time" field.
func (m *RiskMutation) ResetDueTime() {
	m.due_time = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risk.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *RiskMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[risk.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *RiskMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearRiskCategory clears the "risk_category" edge to the RiskCategory entity.
func (m *RiskMutation) ClearRiskCategory() {
	m.clearedrisk_category = true
	m.clearedFields[risk.FieldRiskCategoryID] = struct{}{}
}

// RiskCategoryCleared reports if the "risk_category" edge to the RiskCategory entity was cleared.
func (m *RiskMutation) RiskCategoryCleared() bool {
	return m.clearedrisk_category
}

// RiskCategoryIDs returns the "risk_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskCategoryID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) RiskCategoryIDs() (ids []int) {
	if id := m.risk_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskCategory resets all changes to the "risk_category" edge.
func (m *RiskMutation) ResetRiskCategory() {
	m.risk_category = nil
	m.clearedrisk_category = false
}

// ClearRiskLocation clears the "risk_location" edge to the RiskLocation entity.
func (m *RiskMutation) ClearRiskLocation() {
	m.clearedrisk_location = true
	m.clearedFields[risk.FieldRiskLocationID] = struct{}{}
}

// RiskLocationCleared reports if the "risk_location" edge to the RiskLocation entity was cleared.
func (m *RiskMutation) RiskLocationCleared() bool {
	return m.clearedrisk_location
}

// RiskLocationIDs returns the "risk_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiskLocationID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) RiskLocationIDs() (ids []int) {
	if id := m.risk_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRiskLocation resets all changes to the "risk_location" edge.
func (m *RiskMutation) ResetRiskLocation() {
	m.risk_location = nil
	m.clearedrisk_location = false
}

// ClearReporter clears the "reporter" edge to the Employee entity.
func (m *RiskMutation) ClearReporter() {
	m.clearedreporter = true
	m.clearedFields[risk.FieldReporterID] = struct{}{}
}

// ReporterCleared reports if the "reporter" edge to the Employee entity was cleared.
func (m *RiskMutation) ReporterCleared() bool {
	return m.clearedreporter
}

// ReporterIDs returns the "reporter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReporterID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) ReporterIDs() (ids []int) {
	if id := m.reporter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReporter resets all changes to the "reporter" edge.
func (m *RiskMutation) ResetReporter() {
	m.reporter = nil
	m.clearedreporter = false
}

// ClearMaintainer clears the "maintainer" edge to the Employee entity.
func (m *RiskMutation) ClearMaintainer() {
	m.clearedmaintainer = true
	m.clearedFields[risk.FieldMaintainerID] = struct{}{}
}

// MaintainerCleared reports if the "maintainer" edge to the Employee entity was cleared.
func (m *RiskMutation) MaintainerCleared() bool {
	return m.clearedmaintainer
}

// MaintainerIDs returns the "maintainer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MaintainerID instead. It exists only for internal usage by the builders.
func (m *RiskMutation) MaintainerIDs() (ids []int) {
	if id := m.maintainer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMaintainer resets all changes to the "maintainer" edge.
func (m *RiskMutation) ResetMaintainer() {
	m.maintainer = nil
	m.clearedmaintainer = false
}

// Where appends a list predicates to the RiskMutation builder.
func (m *RiskMutation) Where(ps ...predicate.Risk) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Risk, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Risk).
func (m *RiskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, risk.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, risk.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, risk.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, risk.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, risk.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, risk.FieldContent)
	}
	if m.images != nil {
		fields = append(fields, risk.FieldImages)
	}
	if m.risk_category != nil {
		fields = append(fields, risk.FieldRiskCategoryID)
	}
	if m.risk_location != nil {
		fields = append(fields, risk.FieldRiskLocationID)
	}
	if m.reporter != nil {
		fields = append(fields, risk.FieldReporterID)
	}
	if m.maintainer != nil {
		fields = append(fields, risk.FieldMaintainerID)
	}
	if m.measures != nil {
		fields = append(fields, risk.FieldMeasures)
	}
	if m.maintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	if m.due_time != nil {
		fields = append(fields, risk.FieldDueTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldCreatedAt:
		return m.CreatedAt()
	case risk.FieldCreatedBy:
		return m.CreatedBy()
	case risk.FieldDeletedAt:
		return m.DeletedAt()
	case risk.FieldUpdatedBy:
		return m.UpdatedBy()
	case risk.FieldUpdatedAt:
		return m.UpdatedAt()
	case risk.FieldTitle:
		return m.Title()
	case risk.FieldContent:
		return m.Content()
	case risk.FieldImages:
		return m.Images()
	case risk.FieldRiskCategoryID:
		return m.RiskCategoryID()
	case risk.FieldRiskLocationID:
		return m.RiskLocationID()
	case risk.FieldReporterID:
		return m.ReporterID()
	case risk.FieldMaintainerID:
		return m.MaintainerID()
	case risk.FieldMeasures:
		return m.Measures()
	case risk.FieldMaintainStatus:
		return m.MaintainStatus()
	case risk.FieldDueTime:
		return m.DueTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case risk.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case risk.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case risk.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case risk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case risk.FieldTitle:
		return m.OldTitle(ctx)
	case risk.FieldContent:
		return m.OldContent(ctx)
	case risk.FieldImages:
		return m.OldImages(ctx)
	case risk.FieldRiskCategoryID:
		return m.OldRiskCategoryID(ctx)
	case risk.FieldRiskLocationID:
		return m.OldRiskLocationID(ctx)
	case risk.FieldReporterID:
		return m.OldReporterID(ctx)
	case risk.FieldMaintainerID:
		return m.OldMaintainerID(ctx)
	case risk.FieldMeasures:
		return m.OldMeasures(ctx)
	case risk.FieldMaintainStatus:
		return m.OldMaintainStatus(ctx)
	case risk.FieldDueTime:
		return m.OldDueTime(ctx)
	}
	return nil, fmt.Errorf("unknown Risk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case risk.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case risk.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case risk.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case risk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case risk.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case risk.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case risk.FieldImages:
		v, ok := value.([]types.UploadedImage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImages(v)
		return nil
	case risk.FieldRiskCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskCategoryID(v)
		return nil
	case risk.FieldRiskLocationID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiskLocationID(v)
		return nil
	case risk.FieldReporterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporterID(v)
		return nil
	case risk.FieldMaintainerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainerID(v)
		return nil
	case risk.FieldMeasures:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasures(v)
		return nil
	case risk.FieldMaintainStatus:
		v, ok := value.(maintain_status.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintainStatus(v)
		return nil
	case risk.FieldDueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueTime(v)
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskMutation) AddedFields() []string {
	var fields []string
	if m.addmaintain_status != nil {
		fields = append(fields, risk.FieldMaintainStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case risk.FieldMaintainStatus:
		return m.AddedMaintainStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case risk.FieldMaintainStatus:
		v, ok := value.(maintain_status.MaintainStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaintainStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Risk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risk.FieldDeletedAt) {
		fields = append(fields, risk.FieldDeletedAt)
	}
	if m.FieldCleared(risk.FieldContent) {
		fields = append(fields, risk.FieldContent)
	}
	if m.FieldCleared(risk.FieldImages) {
		fields = append(fields, risk.FieldImages)
	}
	if m.FieldCleared(risk.FieldMeasures) {
		fields = append(fields, risk.FieldMeasures)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskMutation) ClearField(name string) error {
	switch name {
	case risk.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case risk.FieldContent:
		m.ClearContent()
		return nil
	case risk.FieldImages:
		m.ClearImages()
		return nil
	case risk.FieldMeasures:
		m.ClearMeasures()
		return nil
	}
	return fmt.Errorf("unknown Risk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskMutation) ResetField(name string) error {
	switch name {
	case risk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case risk.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case risk.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case risk.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case risk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case risk.FieldTitle:
		m.ResetTitle()
		return nil
	case risk.FieldContent:
		m.ResetContent()
		return nil
	case risk.FieldImages:
		m.ResetImages()
		return nil
	case risk.FieldRiskCategoryID:
		m.ResetRiskCategoryID()
		return nil
	case risk.FieldRiskLocationID:
		m.ResetRiskLocationID()
		return nil
	case risk.FieldReporterID:
		m.ResetReporterID()
		return nil
	case risk.FieldMaintainerID:
		m.ResetMaintainerID()
		return nil
	case risk.FieldMeasures:
		m.ResetMeasures()
		return nil
	case risk.FieldMaintainStatus:
		m.ResetMaintainStatus()
		return nil
	case risk.FieldDueTime:
		m.ResetDueTime()
		return nil
	}
	return fmt.Errorf("unknown Risk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.creator != nil {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, risk.EdgeUpdater)
	}
	if m.risk_category != nil {
		edges = append(edges, risk.EdgeRiskCategory)
	}
	if m.risk_location != nil {
		edges = append(edges, risk.EdgeRiskLocation)
	}
	if m.reporter != nil {
		edges = append(edges, risk.EdgeReporter)
	}
	if m.maintainer != nil {
		edges = append(edges, risk.EdgeMaintainer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risk.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeRiskCategory:
		if id := m.risk_category; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeRiskLocation:
		if id := m.risk_location; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeReporter:
		if id := m.reporter; id != nil {
			return []ent.Value{*id}
		}
	case risk.EdgeMaintainer:
		if id := m.maintainer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcreator {
		edges = append(edges, risk.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, risk.EdgeUpdater)
	}
	if m.clearedrisk_category {
		edges = append(edges, risk.EdgeRiskCategory)
	}
	if m.clearedrisk_location {
		edges = append(edges, risk.EdgeRiskLocation)
	}
	if m.clearedreporter {
		edges = append(edges, risk.EdgeReporter)
	}
	if m.clearedmaintainer {
		edges = append(edges, risk.EdgeMaintainer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskMutation) EdgeCleared(name string) bool {
	switch name {
	case risk.EdgeCreator:
		return m.clearedcreator
	case risk.EdgeUpdater:
		return m.clearedupdater
	case risk.EdgeRiskCategory:
		return m.clearedrisk_category
	case risk.EdgeRiskLocation:
		return m.clearedrisk_location
	case risk.EdgeReporter:
		return m.clearedreporter
	case risk.EdgeMaintainer:
		return m.clearedmaintainer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskMutation) ClearEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ClearCreator()
		return nil
	case risk.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case risk.EdgeRiskCategory:
		m.ClearRiskCategory()
		return nil
	case risk.EdgeRiskLocation:
		m.ClearRiskLocation()
		return nil
	case risk.EdgeReporter:
		m.ClearReporter()
		return nil
	case risk.EdgeMaintainer:
		m.ClearMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Risk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskMutation) ResetEdge(name string) error {
	switch name {
	case risk.EdgeCreator:
		m.ResetCreator()
		return nil
	case risk.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case risk.EdgeRiskCategory:
		m.ResetRiskCategory()
		return nil
	case risk.EdgeRiskLocation:
		m.ResetRiskLocation()
		return nil
	case risk.EdgeReporter:
		m.ResetReporter()
		return nil
	case risk.EdgeMaintainer:
		m.ResetMaintainer()
		return nil
	}
	return fmt.Errorf("unknown Risk edge %s", name)
}

// RiskCategoryMutation represents an operation that mutates the RiskCategory nodes in the graph.
type RiskCategoryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	deleted_at     *time.Time
	updated_at     *time.Time
	name           *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	risk           map[int]struct{}
	removedrisk    map[int]struct{}
	clearedrisk    bool
	done           bool
	oldValue       func(context.Context) (*RiskCategory, error)
	predicates     []predicate.RiskCategory
}

var _ ent.Mutation = (*RiskCategoryMutation)(nil)

// riskcategoryOption allows management of the mutation configuration using functional options.
type riskcategoryOption func(*RiskCategoryMutation)

// newRiskCategoryMutation creates new mutation for the RiskCategory entity.
func newRiskCategoryMutation(c config, op Op, opts ...riskcategoryOption) *RiskCategoryMutation {
	m := &RiskCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskCategoryID sets the ID field of the mutation.
func withRiskCategoryID(id int) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskCategory
		)
		m.oldValue = func(ctx context.Context) (*RiskCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskCategory sets the old RiskCategory of the mutation.
func withRiskCategory(node *RiskCategory) riskcategoryOption {
	return func(m *RiskCategoryMutation) {
		m.oldValue = func(context.Context) (*RiskCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskCategoryMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskCategoryMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskCategoryMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskCategoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskCategoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskCategoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[riskcategory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskCategoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[riskcategory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskCategoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, riskcategory.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskCategoryMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskCategoryMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskCategoryMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RiskCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskCategory entity.
// If the RiskCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskCategoryMutation) ResetName() {
	m.name = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskCategoryMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskCategoryMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[riskcategory.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskCategoryMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskCategoryMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskCategoryMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskCategoryMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *RiskCategoryMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskCategoryMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[riskcategory.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskCategoryMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *RiskCategoryMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskCategoryMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskCategoryMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddRiskIDs adds the "risk" edge to the Risk entity by ids.
func (m *RiskCategoryMutation) AddRiskIDs(ids ...int) {
	if m.risk == nil {
		m.risk = make(map[int]struct{})
	}
	for i := range ids {
		m.risk[ids[i]] = struct{}{}
	}
}

// ClearRisk clears the "risk" edge to the Risk entity.
func (m *RiskCategoryMutation) ClearRisk() {
	m.clearedrisk = true
}

// RiskCleared reports if the "risk" edge to the Risk entity was cleared.
func (m *RiskCategoryMutation) RiskCleared() bool {
	return m.clearedrisk
}

// RemoveRiskIDs removes the "risk" edge to the Risk entity by IDs.
func (m *RiskCategoryMutation) RemoveRiskIDs(ids ...int) {
	if m.removedrisk == nil {
		m.removedrisk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk, ids[i])
		m.removedrisk[ids[i]] = struct{}{}
	}
}

// RemovedRisk returns the removed IDs of the "risk" edge to the Risk entity.
func (m *RiskCategoryMutation) RemovedRiskIDs() (ids []int) {
	for id := range m.removedrisk {
		ids = append(ids, id)
	}
	return
}

// RiskIDs returns the "risk" edge IDs in the mutation.
func (m *RiskCategoryMutation) RiskIDs() (ids []int) {
	for id := range m.risk {
		ids = append(ids, id)
	}
	return
}

// ResetRisk resets all changes to the "risk" edge.
func (m *RiskCategoryMutation) ResetRisk() {
	m.risk = nil
	m.clearedrisk = false
	m.removedrisk = nil
}

// Where appends a list predicates to the RiskCategoryMutation builder.
func (m *RiskCategoryMutation) Where(ps ...predicate.RiskCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskCategory).
func (m *RiskCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, riskcategory.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, riskcategory.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, riskcategory.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, riskcategory.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, riskcategory.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, riskcategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case riskcategory.FieldCreatedAt:
		return m.CreatedAt()
	case riskcategory.FieldCreatedBy:
		return m.CreatedBy()
	case riskcategory.FieldDeletedAt:
		return m.DeletedAt()
	case riskcategory.FieldUpdatedBy:
		return m.UpdatedBy()
	case riskcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case riskcategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case riskcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case riskcategory.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case riskcategory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case riskcategory.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case riskcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case riskcategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RiskCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case riskcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case riskcategory.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case riskcategory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case riskcategory.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case riskcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case riskcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskCategoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiskCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(riskcategory.FieldDeletedAt) {
		fields = append(fields, riskcategory.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ClearField(name string) error {
	switch name {
	case riskcategory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskCategoryMutation) ResetField(name string) error {
	switch name {
	case riskcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case riskcategory.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case riskcategory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case riskcategory.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case riskcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case riskcategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, riskcategory.EdgeUpdater)
	}
	if m.risk != nil {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case riskcategory.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case riskcategory.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.risk))
		for id := range m.risk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrisk != nil {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case riskcategory.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.removedrisk))
		for id := range m.removedrisk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, riskcategory.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, riskcategory.EdgeUpdater)
	}
	if m.clearedrisk {
		edges = append(edges, riskcategory.EdgeRisk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case riskcategory.EdgeCreator:
		return m.clearedcreator
	case riskcategory.EdgeUpdater:
		return m.clearedupdater
	case riskcategory.EdgeRisk:
		return m.clearedrisk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskCategoryMutation) ClearEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ClearCreator()
		return nil
	case riskcategory.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskCategoryMutation) ResetEdge(name string) error {
	switch name {
	case riskcategory.EdgeCreator:
		m.ResetCreator()
		return nil
	case riskcategory.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case riskcategory.EdgeRisk:
		m.ResetRisk()
		return nil
	}
	return fmt.Errorf("unknown RiskCategory edge %s", name)
}

// RiskLocationMutation represents an operation that mutates the RiskLocation nodes in the graph.
type RiskLocationMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	deleted_at     *time.Time
	updated_at     *time.Time
	name           *string
	clearedFields  map[string]struct{}
	creator        *int
	clearedcreator bool
	updater        *int
	clearedupdater bool
	risk           map[int]struct{}
	removedrisk    map[int]struct{}
	clearedrisk    bool
	done           bool
	oldValue       func(context.Context) (*RiskLocation, error)
	predicates     []predicate.RiskLocation
}

var _ ent.Mutation = (*RiskLocationMutation)(nil)

// risklocationOption allows management of the mutation configuration using functional options.
type risklocationOption func(*RiskLocationMutation)

// newRiskLocationMutation creates new mutation for the RiskLocation entity.
func newRiskLocationMutation(c config, op Op, opts ...risklocationOption) *RiskLocationMutation {
	m := &RiskLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeRiskLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiskLocationID sets the ID field of the mutation.
func withRiskLocationID(id int) risklocationOption {
	return func(m *RiskLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *RiskLocation
		)
		m.oldValue = func(ctx context.Context) (*RiskLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiskLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiskLocation sets the old RiskLocation of the mutation.
func withRiskLocation(node *RiskLocation) risklocationOption {
	return func(m *RiskLocationMutation) {
		m.oldValue = func(context.Context) (*RiskLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiskLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiskLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiskLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiskLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiskLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiskLocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiskLocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiskLocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RiskLocationMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RiskLocationMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RiskLocationMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiskLocationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiskLocationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiskLocationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[risklocation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiskLocationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[risklocation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiskLocationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, risklocation.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RiskLocationMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RiskLocationMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RiskLocationMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiskLocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiskLocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiskLocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *RiskLocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiskLocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RiskLocation entity.
// If the RiskLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiskLocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RiskLocationMutation) ResetName() {
	m.name = nil
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *RiskLocationMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *RiskLocationMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[risklocation.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *RiskLocationMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *RiskLocationMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *RiskLocationMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *RiskLocationMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *RiskLocationMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *RiskLocationMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[risklocation.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *RiskLocationMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *RiskLocationMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *RiskLocationMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *RiskLocationMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddRiskIDs adds the "risk" edge to the Risk entity by ids.
func (m *RiskLocationMutation) AddRiskIDs(ids ...int) {
	if m.risk == nil {
		m.risk = make(map[int]struct{})
	}
	for i := range ids {
		m.risk[ids[i]] = struct{}{}
	}
}

// ClearRisk clears the "risk" edge to the Risk entity.
func (m *RiskLocationMutation) ClearRisk() {
	m.clearedrisk = true
}

// RiskCleared reports if the "risk" edge to the Risk entity was cleared.
func (m *RiskLocationMutation) RiskCleared() bool {
	return m.clearedrisk
}

// RemoveRiskIDs removes the "risk" edge to the Risk entity by IDs.
func (m *RiskLocationMutation) RemoveRiskIDs(ids ...int) {
	if m.removedrisk == nil {
		m.removedrisk = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.risk, ids[i])
		m.removedrisk[ids[i]] = struct{}{}
	}
}

// RemovedRisk returns the removed IDs of the "risk" edge to the Risk entity.
func (m *RiskLocationMutation) RemovedRiskIDs() (ids []int) {
	for id := range m.removedrisk {
		ids = append(ids, id)
	}
	return
}

// RiskIDs returns the "risk" edge IDs in the mutation.
func (m *RiskLocationMutation) RiskIDs() (ids []int) {
	for id := range m.risk {
		ids = append(ids, id)
	}
	return
}

// ResetRisk resets all changes to the "risk" edge.
func (m *RiskLocationMutation) ResetRisk() {
	m.risk = nil
	m.clearedrisk = false
	m.removedrisk = nil
}

// Where appends a list predicates to the RiskLocationMutation builder.
func (m *RiskLocationMutation) Where(ps ...predicate.RiskLocation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiskLocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiskLocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiskLocation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiskLocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiskLocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiskLocation).
func (m *RiskLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiskLocationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, risklocation.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, risklocation.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, risklocation.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, risklocation.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, risklocation.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, risklocation.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiskLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case risklocation.FieldCreatedAt:
		return m.CreatedAt()
	case risklocation.FieldCreatedBy:
		return m.CreatedBy()
	case risklocation.FieldDeletedAt:
		return m.DeletedAt()
	case risklocation.FieldUpdatedBy:
		return m.UpdatedBy()
	case risklocation.FieldUpdatedAt:
		return m.UpdatedAt()
	case risklocation.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiskLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case risklocation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case risklocation.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case risklocation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case risklocation.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case risklocation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case risklocation.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown RiskLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case risklocation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case risklocation.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case risklocation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case risklocation.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case risklocation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case risklocation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiskLocationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiskLocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiskLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiskLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiskLocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(risklocation.FieldDeletedAt) {
		fields = append(fields, risklocation.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiskLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiskLocationMutation) ClearField(name string) error {
	switch name {
	case risklocation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiskLocationMutation) ResetField(name string) error {
	switch name {
	case risklocation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case risklocation.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case risklocation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case risklocation.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case risklocation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case risklocation.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiskLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, risklocation.EdgeUpdater)
	}
	if m.risk != nil {
		edges = append(edges, risklocation.EdgeRisk)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiskLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case risklocation.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case risklocation.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.risk))
		for id := range m.risk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiskLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrisk != nil {
		edges = append(edges, risklocation.EdgeRisk)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiskLocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case risklocation.EdgeRisk:
		ids := make([]ent.Value, 0, len(m.removedrisk))
		for id := range m.removedrisk {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiskLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, risklocation.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, risklocation.EdgeUpdater)
	}
	if m.clearedrisk {
		edges = append(edges, risklocation.EdgeRisk)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiskLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case risklocation.EdgeCreator:
		return m.clearedcreator
	case risklocation.EdgeUpdater:
		return m.clearedupdater
	case risklocation.EdgeRisk:
		return m.clearedrisk
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiskLocationMutation) ClearEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ClearCreator()
		return nil
	case risklocation.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiskLocationMutation) ResetEdge(name string) error {
	switch name {
	case risklocation.EdgeCreator:
		m.ResetCreator()
		return nil
	case risklocation.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case risklocation.EdgeRisk:
		m.ResetRisk()
		return nil
	}
	return fmt.Errorf("unknown RiskLocation edge %s", name)
}

// VideoMutation represents an operation that mutates the Video nodes in the graph.
type VideoMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	deleted_at             *time.Time
	updated_at             *time.Time
	name                   *string
	url                    *string
	size                   *int64
	addsize                *int64
	duration               *string
	uploaded_at            *time.Time
	uploaded_at2           *time.Time
	clearedFields          map[string]struct{}
	creator                *int
	clearedcreator         bool
	updater                *int
	clearedupdater         bool
	ipc_event_video        map[int]struct{}
	removedipc_event_video map[int]struct{}
	clearedipc_event_video bool
	done                   bool
	oldValue               func(context.Context) (*Video, error)
	predicates             []predicate.Video
}

var _ ent.Mutation = (*VideoMutation)(nil)

// videoOption allows management of the mutation configuration using functional options.
type videoOption func(*VideoMutation)

// newVideoMutation creates new mutation for the Video entity.
func newVideoMutation(c config, op Op, opts ...videoOption) *VideoMutation {
	m := &VideoMutation{
		config:        c,
		op:            op,
		typ:           TypeVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoID sets the ID field of the mutation.
func withVideoID(id int) videoOption {
	return func(m *VideoMutation) {
		var (
			err   error
			once  sync.Once
			value *Video
		)
		m.oldValue = func(ctx context.Context) (*Video, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Video.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideo sets the old Video of the mutation.
func withVideo(node *Video) videoOption {
	return func(m *VideoMutation) {
		m.oldValue = func(context.Context) (*Video, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("dao: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Video.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *VideoMutation) SetCreatedBy(i int) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *VideoMutation) CreatedBy() (r int, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *VideoMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VideoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VideoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VideoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[video.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VideoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[video.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VideoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, video.FieldDeletedAt)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *VideoMutation) SetUpdatedBy(i int) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *VideoMutation) UpdatedBy() (r int, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdatedBy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *VideoMutation) ResetUpdatedBy() {
	m.updater = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VideoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VideoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *VideoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VideoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VideoMutation) ClearName() {
	m.name = nil
	m.clearedFields[video.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VideoMutation) NameCleared() bool {
	_, ok := m.clearedFields[video.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VideoMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, video.FieldName)
}

// SetURL sets the "url" field.
func (m *VideoMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *VideoMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *VideoMutation) ClearURL() {
	m.url = nil
	m.clearedFields[video.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *VideoMutation) URLCleared() bool {
	_, ok := m.clearedFields[video.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *VideoMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, video.FieldURL)
}

// SetSize sets the "size" field.
func (m *VideoMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VideoMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VideoMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VideoMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VideoMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDuration sets the "duration" field.
func (m *VideoMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *VideoMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ClearDuration clears the value of the "duration" field.
func (m *VideoMutation) ClearDuration() {
	m.duration = nil
	m.clearedFields[video.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *VideoMutation) DurationCleared() bool {
	_, ok := m.clearedFields[video.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *VideoMutation) ResetDuration() {
	m.duration = nil
	delete(m.clearedFields, video.FieldDuration)
}

// SetUploadedAt sets the "uploaded_at" field.
func (m *VideoMutation) SetUploadedAt(t time.Time) {
	m.uploaded_at = &t
}

// UploadedAt returns the value of the "uploaded_at" field in the mutation.
func (m *VideoMutation) UploadedAt() (r time.Time, exists bool) {
	v := m.uploaded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedAt returns the old "uploaded_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUploadedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedAt: %w", err)
	}
	return oldValue.UploadedAt, nil
}

// ClearUploadedAt clears the value of the "uploaded_at" field.
func (m *VideoMutation) ClearUploadedAt() {
	m.uploaded_at = nil
	m.clearedFields[video.FieldUploadedAt] = struct{}{}
}

// UploadedAtCleared returns if the "uploaded_at" field was cleared in this mutation.
func (m *VideoMutation) UploadedAtCleared() bool {
	_, ok := m.clearedFields[video.FieldUploadedAt]
	return ok
}

// ResetUploadedAt resets all changes to the "uploaded_at" field.
func (m *VideoMutation) ResetUploadedAt() {
	m.uploaded_at = nil
	delete(m.clearedFields, video.FieldUploadedAt)
}

// SetUploadedAt2 sets the "uploaded_at2" field.
func (m *VideoMutation) SetUploadedAt2(t time.Time) {
	m.uploaded_at2 = &t
}

// UploadedAt2 returns the value of the "uploaded_at2" field in the mutation.
func (m *VideoMutation) UploadedAt2() (r time.Time, exists bool) {
	v := m.uploaded_at2
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedAt2 returns the old "uploaded_at2" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldUploadedAt2(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedAt2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedAt2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedAt2: %w", err)
	}
	return oldValue.UploadedAt2, nil
}

// ClearUploadedAt2 clears the value of the "uploaded_at2" field.
func (m *VideoMutation) ClearUploadedAt2() {
	m.uploaded_at2 = nil
	m.clearedFields[video.FieldUploadedAt2] = struct{}{}
}

// UploadedAt2Cleared returns if the "uploaded_at2" field was cleared in this mutation.
func (m *VideoMutation) UploadedAt2Cleared() bool {
	_, ok := m.clearedFields[video.FieldUploadedAt2]
	return ok
}

// ResetUploadedAt2 resets all changes to the "uploaded_at2" field.
func (m *VideoMutation) ResetUploadedAt2() {
	m.uploaded_at2 = nil
	delete(m.clearedFields, video.FieldUploadedAt2)
}

// SetCreatorID sets the "creator" edge to the Admin entity by id.
func (m *VideoMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Admin entity.
func (m *VideoMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[video.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Admin entity was cleared.
func (m *VideoMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *VideoMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *VideoMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Admin entity by id.
func (m *VideoMutation) SetUpdaterID(id int) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Admin entity.
func (m *VideoMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[video.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Admin entity was cleared.
func (m *VideoMutation) UpdaterCleared() bool {
	return m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *VideoMutation) UpdaterID() (id int, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) UpdaterIDs() (ids []int) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *VideoMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddIpcEventVideoIDs adds the "ipc_event_video" edge to the IPCEvent entity by ids.
func (m *VideoMutation) AddIpcEventVideoIDs(ids ...int) {
	if m.ipc_event_video == nil {
		m.ipc_event_video = make(map[int]struct{})
	}
	for i := range ids {
		m.ipc_event_video[ids[i]] = struct{}{}
	}
}

// ClearIpcEventVideo clears the "ipc_event_video" edge to the IPCEvent entity.
func (m *VideoMutation) ClearIpcEventVideo() {
	m.clearedipc_event_video = true
}

// IpcEventVideoCleared reports if the "ipc_event_video" edge to the IPCEvent entity was cleared.
func (m *VideoMutation) IpcEventVideoCleared() bool {
	return m.clearedipc_event_video
}

// RemoveIpcEventVideoIDs removes the "ipc_event_video" edge to the IPCEvent entity by IDs.
func (m *VideoMutation) RemoveIpcEventVideoIDs(ids ...int) {
	if m.removedipc_event_video == nil {
		m.removedipc_event_video = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.ipc_event_video, ids[i])
		m.removedipc_event_video[ids[i]] = struct{}{}
	}
}

// RemovedIpcEventVideo returns the removed IDs of the "ipc_event_video" edge to the IPCEvent entity.
func (m *VideoMutation) RemovedIpcEventVideoIDs() (ids []int) {
	for id := range m.removedipc_event_video {
		ids = append(ids, id)
	}
	return
}

// IpcEventVideoIDs returns the "ipc_event_video" edge IDs in the mutation.
func (m *VideoMutation) IpcEventVideoIDs() (ids []int) {
	for id := range m.ipc_event_video {
		ids = append(ids, id)
	}
	return
}

// ResetIpcEventVideo resets all changes to the "ipc_event_video" edge.
func (m *VideoMutation) ResetIpcEventVideo() {
	m.ipc_event_video = nil
	m.clearedipc_event_video = false
	m.removedipc_event_video = nil
}

// Where appends a list predicates to the VideoMutation builder.
func (m *VideoMutation) Where(ps ...predicate.Video) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Video, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Video).
func (m *VideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, video.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, video.FieldCreatedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, video.FieldDeletedAt)
	}
	if m.updater != nil {
		fields = append(fields, video.FieldUpdatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, video.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, video.FieldName)
	}
	if m.url != nil {
		fields = append(fields, video.FieldURL)
	}
	if m.size != nil {
		fields = append(fields, video.FieldSize)
	}
	if m.duration != nil {
		fields = append(fields, video.FieldDuration)
	}
	if m.uploaded_at != nil {
		fields = append(fields, video.FieldUploadedAt)
	}
	if m.uploaded_at2 != nil {
		fields = append(fields, video.FieldUploadedAt2)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case video.FieldCreatedAt:
		return m.CreatedAt()
	case video.FieldCreatedBy:
		return m.CreatedBy()
	case video.FieldDeletedAt:
		return m.DeletedAt()
	case video.FieldUpdatedBy:
		return m.UpdatedBy()
	case video.FieldUpdatedAt:
		return m.UpdatedAt()
	case video.FieldName:
		return m.Name()
	case video.FieldURL:
		return m.URL()
	case video.FieldSize:
		return m.Size()
	case video.FieldDuration:
		return m.Duration()
	case video.FieldUploadedAt:
		return m.UploadedAt()
	case video.FieldUploadedAt2:
		return m.UploadedAt2()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case video.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case video.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case video.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case video.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case video.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case video.FieldName:
		return m.OldName(ctx)
	case video.FieldURL:
		return m.OldURL(ctx)
	case video.FieldSize:
		return m.OldSize(ctx)
	case video.FieldDuration:
		return m.OldDuration(ctx)
	case video.FieldUploadedAt:
		return m.OldUploadedAt(ctx)
	case video.FieldUploadedAt2:
		return m.OldUploadedAt2(ctx)
	}
	return nil, fmt.Errorf("unknown Video field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case video.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case video.FieldCreatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case video.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case video.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case video.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case video.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case video.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case video.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case video.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case video.FieldUploadedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedAt(v)
		return nil
	case video.FieldUploadedAt2:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedAt2(v)
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, video.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case video.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case video.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Video numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(video.FieldDeletedAt) {
		fields = append(fields, video.FieldDeletedAt)
	}
	if m.FieldCleared(video.FieldName) {
		fields = append(fields, video.FieldName)
	}
	if m.FieldCleared(video.FieldURL) {
		fields = append(fields, video.FieldURL)
	}
	if m.FieldCleared(video.FieldDuration) {
		fields = append(fields, video.FieldDuration)
	}
	if m.FieldCleared(video.FieldUploadedAt) {
		fields = append(fields, video.FieldUploadedAt)
	}
	if m.FieldCleared(video.FieldUploadedAt2) {
		fields = append(fields, video.FieldUploadedAt2)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMutation) ClearField(name string) error {
	switch name {
	case video.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case video.FieldName:
		m.ClearName()
		return nil
	case video.FieldURL:
		m.ClearURL()
		return nil
	case video.FieldDuration:
		m.ClearDuration()
		return nil
	case video.FieldUploadedAt:
		m.ClearUploadedAt()
		return nil
	case video.FieldUploadedAt2:
		m.ClearUploadedAt2()
		return nil
	}
	return fmt.Errorf("unknown Video nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMutation) ResetField(name string) error {
	switch name {
	case video.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case video.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case video.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case video.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case video.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case video.FieldName:
		m.ResetName()
		return nil
	case video.FieldURL:
		m.ResetURL()
		return nil
	case video.FieldSize:
		m.ResetSize()
		return nil
	case video.FieldDuration:
		m.ResetDuration()
		return nil
	case video.FieldUploadedAt:
		m.ResetUploadedAt()
		return nil
	case video.FieldUploadedAt2:
		m.ResetUploadedAt2()
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, video.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, video.EdgeUpdater)
	}
	if m.ipc_event_video != nil {
		edges = append(edges, video.EdgeIpcEventVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case video.EdgeIpcEventVideo:
		ids := make([]ent.Value, 0, len(m.ipc_event_video))
		for id := range m.ipc_event_video {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedipc_event_video != nil {
		edges = append(edges, video.EdgeIpcEventVideo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case video.EdgeIpcEventVideo:
		ids := make([]ent.Value, 0, len(m.removedipc_event_video))
		for id := range m.removedipc_event_video {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, video.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, video.EdgeUpdater)
	}
	if m.clearedipc_event_video {
		edges = append(edges, video.EdgeIpcEventVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMutation) EdgeCleared(name string) bool {
	switch name {
	case video.EdgeCreator:
		return m.clearedcreator
	case video.EdgeUpdater:
		return m.clearedupdater
	case video.EdgeIpcEventVideo:
		return m.clearedipc_event_video
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMutation) ClearEdge(name string) error {
	switch name {
	case video.EdgeCreator:
		m.ClearCreator()
		return nil
	case video.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown Video unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMutation) ResetEdge(name string) error {
	switch name {
	case video.EdgeCreator:
		m.ResetCreator()
		return nil
	case video.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case video.EdgeIpcEventVideo:
		m.ResetIpcEventVideo()
		return nil
	}
	return fmt.Errorf("unknown Video edge %s", name)
}
